<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄老师</title>
  
  <subtitle>Life Note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://veryjj.github.io/"/>
  <updated>2021-01-10T09:14:10.653Z</updated>
  <id>https://veryjj.github.io/</id>
  
  <author>
    <name>黄老师</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RocketMQ小笔记</title>
    <link href="https://veryjj.github.io/2021/01/09/RocketMQ%E5%B0%8F%E7%AC%94%E8%AE%B0/"/>
    <id>https://veryjj.github.io/2021/01/09/RocketMQ小笔记/</id>
    <published>2021-01-09T13:41:04.000Z</published>
    <updated>2021-01-10T09:14:10.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RocketMQ小笔记"><a href="#RocketMQ小笔记" class="headerlink" title="RocketMQ小笔记"></a>RocketMQ小笔记</h2><h2 id="6种消息类型"><a href="#6种消息类型" class="headerlink" title="6种消息类型"></a>6种消息类型</h2><ul><li>普通消息</li><li>顺序消息</li><li>广播消息</li><li>延时消息</li><li>批量消息</li><li>事务消息</li></ul><p><br></p><h2 id="2种消费模式"><a href="#2种消费模式" class="headerlink" title="2种消费模式"></a>2种消费模式</h2><ul><li>集群消费：一个Group ID内只消费一次</li><li>广播消费：一个Group ID内所有Consumer都消费</li></ul><a id="more"></a><p><br></p><h2 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h2><p><img src="/2021/01/09/RocketMQ小笔记/image-20210109210809255.png" alt="image-20210109210809255"></p><ul><li>Name Server + broker（主/备） + producer + consumer</li><li>【broker】与所有Name Server建立长连接</li><li>【producer】与某个Name Server建立连接，查询topic所在broker，并与broker master建立连接</li><li>【consumer】与某个Name Server建立连接，查询topic所在broker，与broker master 和broker slave 分别建立连接。broker master会根据情况建议consumer从哪里拉消息</li></ul><p><br></p><h2 id="broker原理"><a href="#broker原理" class="headerlink" title="broker原理"></a>broker原理</h2><h4 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h4><ul><li>一个broker一个commitLog（用于顺序写），broker上的多个topic共用一个commitLog。</li><li>基于commitLog ，会根据topic情况分别生成consumer queue，并建立indexFile，用于快速读取</li></ul><p><br></p><h4 id="高性能原理"><a href="#高性能原理" class="headerlink" title="高性能原理"></a>高性能原理</h4><p><strong>核心设计 - 1：（写优化）commitlog的顺序写PageCache</strong></p><ul><li><code>【页缓存 PageCache】</code>PageCache是操作系统对文件的缓存，在<code>PageCache上的顺序写操作速度接近于内存读写速度</code></li></ul><p><strong>核心设计 - 2：（读优化）commitlog的随机读优化</strong></p><ul><li>【PageCache的预读取】：从物理磁盘访问目标页时，会顺序对其相邻块的数据进行预读取。然后，在PageCache中的读取速度又接近于内存速度</li><li>【直接内存MMap】：减少了内核态和用户态的内存拷贝次数</li><li>【SSD硬盘】</li></ul><p><strong>核心设计 - 3：异步刷盘【默认】</strong></p><ul><li>【同步刷盘】真正到磁盘才回复ACK给producer。例如严格的金融业务使用。</li><li>【异步刷盘】消息刷到PageCache就回复ACK。提高性能和吞吐量</li></ul><p><br></p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RocketMQ的RPC通信采用Netty作为底层通信库，同样也遵循Reactor多线程模型。</p><p><br></p><h2 id="oneway模式（极限高吞吐）"><a href="#oneway模式（极限高吞吐）" class="headerlink" title="oneway模式（极限高吞吐）"></a>oneway模式（极限高吞吐）</h2><p>此模式下，MQ Producer只发送请求不等待应答，耗时通常在微秒级完成。例如一般的日志收集场景。</p><p><br></p><h2 id="怎么提升消息消费能力"><a href="#怎么提升消息消费能力" class="headerlink" title="怎么提升消息消费能力"></a>怎么提升消息消费能力</h2><p>1、创建topic时放大queue大小，进而能提升consumer个数上限。（适用MQ队列水位高的情况）</p><p>2、增加新topic，目的也是增加queue，然后增加consumer。（适用消息量大，MQ队列水位较低的情况）</p><p><br></p><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><blockquote><p>见我另外一篇文章《分布式系统 之 分布式事务问题》</p></blockquote><p><br></p><h2 id="RocketMQ的问题"><a href="#RocketMQ的问题" class="headerlink" title="RocketMQ的问题"></a>RocketMQ的问题</h2><p>1、消息过滤是consumer pull时，根据tag构造SubscriptionData发给broker，让broker去过滤的。而broker只会根据hashcode做过滤判断，做不到非常精确。故，在consumer端拉到消息后，还是要对消息的tag字符串进行一次比对，做到精确。</p><p>2、msgId一定是全局唯一标识符，但是实际使用中，可能会存在相同的消息有两个不同msgId的情况（消费者主动重发、因客户端重投机制导致的重复等），这种情况就需要使业务字段进行重复消费。</p><p><br></p><hr><h2 id="其他有关RocketMQ的细节备忘"><a href="#其他有关RocketMQ的细节备忘" class="headerlink" title="其他有关RocketMQ的细节备忘"></a>其他有关RocketMQ的细节备忘</h2><p><img src="/2021/01/09/RocketMQ小笔记/image-20210109213300003.png" alt="image-20210109213300003"></p><p><img src="/2021/01/09/RocketMQ小笔记/image-20210109213339658.png" alt="image-20210109213339658"></p><ul><li>NameServer可以部署多个，相互之间独立，其他角色同时向多个NameServer机器上报状态信息，从而达到热备份的目的。 NameServer本身是无状态的，也就是说NameServer中的Broker、Topic等状态信息不会持久存储，都是由各个角色定时上报并存储到内存中的(NameServer支持配置参数的持久化，一般用不到)。</li><li>为何不用ZooKeeper？ZooKeeper的功能很强大，包括自动Master选举等，RocketMQ的架构设计决定了它不需要进行Master选举， 用不到这些复杂的功能，只需要一个轻量级的元数据服务器就足够了。值得注意的是，NameServer并没有提供类似Zookeeper的watcher机制， 而是采用了每30s心跳机制。</li><li>心跳机制<ul><li>单个Broker跟所有Namesrv保持心跳请求，心跳间隔为30秒，心跳请求中包括当前Broker所有的Topic信息。Namesrv会反查Broer的心跳信息， 如果某个Broker在2分钟之内都没有心跳，则认为该Broker下线，调整Topic跟Broker的对应关系。但此时Namesrv不会主动通知Producer、Consumer有Broker宕机。</li><li>Consumer跟Broker是长连接，会每隔30秒发心跳信息到Broker。Broker端每10秒检查一次当前存活的Consumer，若发现某个Consumer 2分钟内没有心跳， 就断开与该Consumer的连接，并且向该消费组的其他实例发送通知，触发该消费者集群的负载均衡(rebalance)。</li><li>生产者每30秒从Namesrv获取Topic跟Broker的映射关系，更新到本地内存中。再跟Topic涉及的所有Broker建立长连接，每隔30秒发一次心跳。 在Broker端也会每10秒扫描一次当前注册的Producer，如果发现某个Producer超过2分钟都没有发心跳，则断开连接。</li></ul></li><li>Namesrv压力不会太大，平时主要开销是在维持心跳和提供Topic-Broker的关系数据。但有一点需要注意，Broker向Namesrv发心跳时， 会带上当前自己所负责的所有Topic信息，如果Topic个数太多（万级别），会导致一次心跳中，就Topic的数据就几十M，网络情况差的话， 网络传输失败，心跳失败，导致Namesrv误认为Broker心跳失败。</li><li>每个Topic可设置队列个数，自动创建主题时默认4个，需要顺序消费的消息发往同一队列，比如同一订单号相关的几条需要顺序消费的消息发往同一队列， 顺序消费的特点的是，不会有两个消费者共同消费任一队列，且当消费者数量小于队列数时，消费者会消费多个队列。至于消息重复，在消 费端处理。RocketMQ 4.3+支持事务消息，可用于分布式事务场景(最终一致性)。</li><li>关于queueNums:<ul><li>客户端自动创建，Math.min算法决定最多只会创建8个(BrokerConfig)队列，若要超过8个，可通过控制台创建/修改，Topic配置保存在store/config/topics.json</li><li>消费负载均衡的最小粒度是队列，Consumer的数量应不大于队列数</li><li>读写队列数(writeQueueNums/readQueueNums)是RocketMQ特有的概念，可通过console修改。当readQueueNums不等于writeQueueNums时，会有什么影响呢？</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">topicRouteData = this.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(), 1000 * 3);</span><br><span class="line">    if (topicRouteData != null) &#123;</span><br><span class="line">        for (QueueData data : topicRouteData.getQueueDatas()) &#123;</span><br><span class="line">            int queueNums = Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());</span><br><span class="line">            data.setReadQueueNums(queueNums);</span><br><span class="line">            data.setWriteQueueNums(queueNums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Broker上存Topic信息，Topic由多个队列组成，队列会平均分散在多个Broker上。Producer的发送机制保证消息尽量平均分布到 所有队列中，最终效果就是所有消息都平均落在每个Broker上。</li><li>RocketMQ的消息的存储是由ConsumeQueue和CommitLog配合来完成的，ConsumeQueue中只存储很少的数据，消息主体都是通过CommitLog来进行读写。 如果某个消息只在CommitLog中有数据，而ConsumeQueue中没有，则消费者无法消费，RocketMQ的事务消息实现就利用了这一点。<ul><li>CommitLog：是消息主体以及元数据的存储主体，对CommitLog建立一个ConsumeQueue，每个ConsumeQueue对应一个（概念模型中的）MessageQueue，所以只要有 CommitLog在，ConsumeQueue即使数据丢失，仍然可以恢复出来。</li><li>ConsumeQueue：是一个消息的逻辑队列，存储了这个Queue在CommitLog中的起始offset，log大小和MessageTag的hashCode。每个Topic下的每个Queue都有一个对应的 ConsumeQueue文件，例如Topic中有三个队列，每个队列中的消息索引都会有一个编号，编号从0开始，往上递增。并由此一个位点offset的概念，有了这个概念，就可以对 Consumer端的消费情况进行队列定义。</li></ul></li><li>RocketMQ的高性能在于顺序写盘(CommitLog)、零拷贝和跳跃读(尽量命中PageCache)，高可靠性在于刷盘和Master/Slave，另外NameServer 全部挂掉不影响已经运行的Broker,Producer,Consumer。</li><li>发送消息负载均衡，且发送消息线程安全(可满足多个实例死循环发消息)，集群消费模式下消费者端负载均衡，这些特性加上上述的高性能读写， 共同造就了RocketMQ的高并发读写能力。</li><li>刷盘和主从同步均为异步(默认)时，broker进程挂掉(例如重启)，消息依然不会丢失，因为broker shutdown时会执行persist。 当物理机器宕机时，才有消息丢失的风险。另外，master挂掉后，消费者从slave消费消息，但slave不能写消息。</li><li>RocketMQ具有很好动态伸缩能力(非顺序消息)，伸缩性体现在Topic和Broker两个维度。<ul><li>Topic维度：假如一个Topic的消息量特别大，但集群水位压力还是很低，就可以扩大该Topic的队列数，Topic的队列数跟发送、消费速度成正比。</li><li>Broker维度：如果集群水位很高了，需要扩容，直接加机器部署Broker就可以。Broker起来后向Namesrv注册，Producer、Consumer通过Namesrv 发现新Broker，立即跟该Broker直连，收发消息。</li></ul></li><li>Producer: 失败默认重试2次；sync/async；ProducerGroup，在事务消息机制中，如果发送消息的producer在还未commit/rollback前挂掉了，broker会在一段时间后回查ProducerGroup里的其他实例，确认消息应该commit/rollback</li><li>Consumer: DefaultPushConsumer/DefaultPullConsumer，push也是用pull实现的，采用的是长轮询方式；CLUSTERING模式下，一条消息只会被ConsumerGroup里的一个实例消费，但可以被多个不同的ConsumerGroup消费，BROADCASTING模式下，一条消息会被ConsumerGroup里的所有实例消费。</li><li>DefaultPushConsumer: Broker收到新消息请求后，如果队列里没有新消息，并不急于返回，通过一个循环不断查看状态，每次waitForRunning一段时间(5s)，然后在check。当一直没有新消息，第三次check时，等待时间超过suspendMaxTimeMills(15s)，就返回空结果。在等待的过程中，Broker收到了新的消息后会直接调用notifyMessageArriving返回请求结果。“长轮询”的核心是，Broker端Hold住(挂起)客户端客户端过来的请求一小段时间，在这个时间内有新消息到达，就利用现有的连接立刻返回消息给Consumer。“长轮询”的主动权还是掌握在Consumer手中，Broker即使有大量消息积压，也不会主动推送给Consumer。长轮询方式的局限性，是在Hold住Consumer请求的时候需要占用资源，它适合用在消息队列这种客户端连接数可控的场景中。</li><li>DefaultPullConsumer: 需要用户自己处理遍历MessageQueue、保存Offset，所以PullConsumer有更多的自主性和灵活性。</li><li>对于集群模式的非顺序消息，消费失败默认重试16次，延迟等级为3~18。(messageDelayLevel = “1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”)</li><li>MQClientInstance是客户端各种类型的Consumer和Producer的底层类，由它与NameServer和Broker打交道。如果创建Consumer或Producer 类型的时候不手动指定instanceName，进程中只会有一个MQClientInstance对象，即当一个Java程序需要连接多个MQ集群时，必须手动指定不同的instanceName。需要一提的是，当消费者(不同jvm实例)都在同一台物理机上时，若指定instanceName，消费负载均衡将失效(每个实例都将消费所有消息)。另外，在一个jvm里模拟集群消费时，必须指定不同的instanceName，否则启动时会提示ConsumerGroup已存在。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RocketMQ小笔记&quot;&gt;&lt;a href=&quot;#RocketMQ小笔记&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ小笔记&quot;&gt;&lt;/a&gt;RocketMQ小笔记&lt;/h2&gt;&lt;h2 id=&quot;6种消息类型&quot;&gt;&lt;a href=&quot;#6种消息类型&quot; class=&quot;headerlink&quot; title=&quot;6种消息类型&quot;&gt;&lt;/a&gt;6种消息类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;普通消息&lt;/li&gt;
&lt;li&gt;顺序消息&lt;/li&gt;
&lt;li&gt;广播消息&lt;/li&gt;
&lt;li&gt;延时消息&lt;/li&gt;
&lt;li&gt;批量消息&lt;/li&gt;
&lt;li&gt;事务消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;2种消费模式&quot;&gt;&lt;a href=&quot;#2种消费模式&quot; class=&quot;headerlink&quot; title=&quot;2种消费模式&quot;&gt;&lt;/a&gt;2种消费模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;集群消费：一个Group ID内只消费一次&lt;/li&gt;
&lt;li&gt;广播消费：一个Group ID内所有Consumer都消费&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="RocketMQ" scheme="https://veryjj.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal内存泄露知识点详解</title>
    <link href="https://veryjj.github.io/2021/01/09/ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/"/>
    <id>https://veryjj.github.io/2021/01/09/ThreadLocal内存泄露知识点详解/</id>
    <published>2021-01-09T08:48:18.000Z</published>
    <updated>2021-01-10T09:15:06.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal内存泄露知识点详解"><a href="#ThreadLocal内存泄露知识点详解" class="headerlink" title="ThreadLocal内存泄露知识点详解"></a>ThreadLocal内存泄露知识点详解</h2><h3 id="1、ThreadLocal常规用法"><a href="#1、ThreadLocal常规用法" class="headerlink" title="1、ThreadLocal常规用法"></a>1、ThreadLocal常规用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java.lang.ThreadLocal中只有4个public方法，非常清晰。</p><ul><li>withInitial：是更灵活的set能力，支持传入一个方法，以方法的返回值作为ThreadLocal的初始值。</li><li>set：设置Value到当前线程的ThreadLocal中去。</li><li>get：获取当前线程存储在ThreadLocal中的Value。</li><li>remove：移除当前线程ThreadLocal存储的Value。</li></ul><p>注：ThreadLocal是一个变量对象，一个ThreadLocal是一个存储位置。如果线程需要多个存储位置，则创建多个ThreadLocal。</p><a id="more"></a><p><br></p><p><strong>常见用法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2个ThreadLocal</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; countLocal1 = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; countLocal2 = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3个线程，共用2个ThreadLocal。互相不影响。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++)&#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">int</span> count1 = countLocal1.get();</span><br><span class="line">                countLocal1.set(count1 + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> count2 = countLocal2.get();</span><br><span class="line">                countLocal2.set(count2 + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">":"</span>+countLocal1.get()+<span class="string">"-&gt;"</span>+countLocal2.get());</span><br><span class="line">            &#125;,<span class="string">"thread-"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Thread thread : threads)&#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">thread-0:5-&gt;10</span><br><span class="line">thread-2:5-&gt;10</span><br><span class="line">thread-1:5-&gt;10</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2、ThreadLocal源码分析"><a href="#2、ThreadLocal源码分析" class="headerlink" title="2、ThreadLocal源码分析"></a>2、ThreadLocal源码分析</h3><h4 id="2-1、每个线程的ThreadLocal的Value存在哪？"><a href="#2-1、每个线程的ThreadLocal的Value存在哪？" class="headerlink" title="2.1、每个线程的ThreadLocal的Value存在哪？"></a>2.1、每个线程的ThreadLocal的Value存在哪？</h4><p>答：</p><ul><li>具体是存储在当前线程Thread下的一个HashMap结构中。</li><li>此线程的所有ThreadLocal共享此HashMap。每个ThreadLocal是Map的Key，set的值就是Value。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;   《《《 存储位置</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/01/09/ThreadLocal内存泄露知识点详解/ThreadLocal内存泄露详解/image-20210106173510088.png" alt="image-20210106173510088"></p><center>ThreadLocal存储示意图</center><p><br></p><p>注：ThreadLocal本身不存储Value，而是以自身为标记索引，把Value存储到对应Thread的Map中去。</p><p><br></p><h4 id="2-2、ThreadLocalMap"><a href="#2-2、ThreadLocalMap" class="headerlink" title="2.2、ThreadLocalMap"></a>2.2、ThreadLocalMap</h4><p>ThreadLocalMap是实现线程隔离机制的关键。</p><p>每个Thread内部都有 一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;   &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  这里</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>ThreadLocalMap提供了一种用K-V健值对方式存储每个线程的变量副本的方法，key为ThreadLocal对象，value则是对应线程的变量副本。</p><p><img src="/2021/01/09/ThreadLocal内存泄露知识点详解/ThreadLocal内存泄露详解/image-20210109153733367.png" alt="image-20210109153733367"></p><ul><li>可以看到ThreadLocalMap有个Entry内部静态类，并继承了WeakReference。由Entry记录两个信息：一个是ThreadLocal类型，一个是Object类型的值。</li><li>getEntry方法则是以ThreadLocal为Key，在线程的ThreadLocalMap中取对应的value值。set方法就是同理，更新或赋值相应ThreadLocal对应的值。</li><li><code>Entry继承自WeakReference（弱引用，在无强引用时，生命周期只能存活到下次GC前）</code>，但只有Key是弱引用类型的，Value并非弱引用。</li></ul><p><br></p><p><code>特别说明：</code></p><ul><li>一般网上资料介绍WeakReference特点时，表示弱引用对象的生命周期只能存活到下次GC前。这个描述不准确。</li><li><p>关于<strong>弱引用的GC回收</strong>，我推荐的准确描述：当一个对象<strong>仅仅被WeakReference指向，而没有任何其他StrongReference指向的时候</strong>，如果GC运行，那么这个对象就会被回收。（<a href="https://www.xz577.com/j/23022.html" target="_blank" rel="noopener">不错的举例</a>）</p></li><li><p>所以，大家在代码上下文用ThreadLocal时，不用焦虑是否某个时刻被GC回收了而造成代码异常。因为当还在你代码调用上下文时，虚拟机栈上的栈帧里仍记录着对ThreadLocal的StrongReference，此时即使发生GC，ThreadLocal也是不会被回收的。</p></li></ul><p><br></p><h4 id="2-3、set方法"><a href="#2-3、set方法" class="headerlink" title="2.3、set方法"></a>2.3、set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取当前线程的ThreadLocalMap</li><li>map非空，则将ThreadLocal和新的value副本放入到map中。</li><li>map空，则创建ThreadLocalMap，赋值到线程Thread中，并将ThreadLocal和value副本放入map中。</li></ul><p><br></p><h4 id="2-4、get方法"><a href="#2-4、get方法" class="headerlink" title="2.4、get方法"></a>2.4、get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取当前线程的 ThreadLocalMap</li><li>以ThreadLocal为Key，从此线程的 map 中获取存储的K-V Entry节点。</li><li>从Entry节点获取存储的Value副本值返回。</li></ul><p><br></p><h4 id="2-5、remove方法"><a href="#2-5、remove方法" class="headerlink" title="2.5、remove方法"></a>2.5、remove方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移除当前线程的ThreadLocalMap中，ThreadLocal对应觉得Entry节点。</li></ul><p><br></p><h3 id="3、ThreadLocal什么时候会内存泄露"><a href="#3、ThreadLocal什么时候会内存泄露" class="headerlink" title="3、ThreadLocal什么时候会内存泄露"></a>3、ThreadLocal什么时候会内存泄露</h3><p><img src="/2021/01/09/ThreadLocal内存泄露知识点详解/ThreadLocal内存泄露详解/image-20210109161251815.png" alt="image-20210109161251815"></p><p>1、【因素1：WeakReference】线程的ThreadLocalMap中的K-V的K（ThreadLocal）是以一个弱引用身份存在的，因此当没有外部强引用来引用ThreadLocal时，在下次GC时此ThreadLocal会被回收。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，Value讲永远不会被读取到。</p><p>2、【因素2：线程一直未退出】如果当前线程的生命周期很长，一直存在，那么其内部的ThreadLocalMap对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：<strong>Thread –&gt; ThreadLocalMap–&gt;Entry–&gt;Value</strong>，这条<code>强引用链会导致Entry不会回收</code>，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。</p><p><br></p><h3 id="4、如何避免ThreadLocal内存泄露"><a href="#4、如何避免ThreadLocal内存泄露" class="headerlink" title="4、如何避免ThreadLocal内存泄露"></a>4、如何避免ThreadLocal内存泄露</h3><h4 id="4-1【知识点】JDK做了释放的优化"><a href="#4-1【知识点】JDK做了释放的优化" class="headerlink" title="4.1【知识点】JDK做了释放的优化"></a>4.1【知识点】JDK做了释放的优化</h4><p>JDK代码做了改进，会在set/get/remove操作中，主动释放属于当前线程的K为null的Entry。</p><p><img src="/2021/01/09/ThreadLocal内存泄露知识点详解/ThreadLocal内存泄露详解/image-20210109163850021.png" alt="image-20210109163850021"></p><p><img src="/2021/01/09/ThreadLocal内存泄露知识点详解/ThreadLocal内存泄露详解/image-20210109163945760.png" alt="image-20210109163945760"></p><p><br></p><h4 id="4-2、【重点】良好的remove习惯"><a href="#4-2、【重点】良好的remove习惯" class="headerlink" title="4.2、【重点】良好的remove习惯"></a>4.2、【重点】良好的remove习惯</h4><p>既然Key是弱引用，那么我们要做的事就是在调用ThreadLocal的get()、set()方法时完成后再调用remove方法，将Entry节点和Map的<strong>引用关系移除</strong>，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。</p><p><strong>良好的remove习惯可以加速ThreadLocal Value内存的释放</strong>。</p><p>如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露/内存溢出（因为会延迟到下一次调用ThreadLocal方法，有些时候可能没有下一次了）。</p><p><br></p><h3 id="5、为什么ThreadLocalMap的Key是弱引用类型呢？"><a href="#5、为什么ThreadLocalMap的Key是弱引用类型呢？" class="headerlink" title="5、为什么ThreadLocalMap的Key是弱引用类型呢？"></a>5、为什么ThreadLocalMap的Key是弱引用类型呢？</h3><p><strong>如果 key 使用强引用</strong>：引用的ThreadLocal的对象Value被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p><p><br></p><p><strong>如果 key 使用弱引用</strong>：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</p><p><br></p><h3 id="6、最后，再特别强调"><a href="#6、最后，再特别强调" class="headerlink" title="6、最后，再特别强调"></a>6、最后，再特别强调</h3><p>关于弱引用类型：</p><ul><li>一般网上资料介绍WeakReference特点时，表示弱引用对象的生命周期只能存活到下次GC前。这个描述是不准确的。</li><li><p>关于<strong>弱引用的GC回收</strong>，我推荐的准确描述：当一个对象<strong>仅仅被WeakReference指向，而没有任何其他StrongReference指向的时候</strong>，如果GC运行，那么这个对象就会被回收。（<a href="https://www.xz577.com/j/23022.html" target="_blank" rel="noopener">不错的举例</a>）</p></li><li><p>所以，大家在代码上下文用ThreadLocal时，不用焦虑是否某个时刻被GC回收了而造成代码异常。因为当还在你代码调用上下文时，虚拟机栈上的栈帧里仍记录着对ThreadLocal的StrongReference，此时即使发生GC，ThreadLocal也是不会被回收的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ThreadLocal内存泄露知识点详解&quot;&gt;&lt;a href=&quot;#ThreadLocal内存泄露知识点详解&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal内存泄露知识点详解&quot;&gt;&lt;/a&gt;ThreadLocal内存泄露知识点详解&lt;/h2&gt;&lt;h3 id=&quot;1、ThreadLocal常规用法&quot;&gt;&lt;a href=&quot;#1、ThreadLocal常规用法&quot; class=&quot;headerlink&quot; title=&quot;1、ThreadLocal常规用法&quot;&gt;&lt;/a&gt;1、ThreadLocal常规用法&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadLocal&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;S&amp;gt; &lt;span class=&quot;function&quot;&gt;ThreadLocal&amp;lt;S&amp;gt; &lt;span class=&quot;title&quot;&gt;withInitial&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Supplier&amp;lt;? extends S&amp;gt; supplier)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T value)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;java.lang.ThreadLocal中只有4个public方法，非常清晰。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;withInitial：是更灵活的set能力，支持传入一个方法，以方法的返回值作为ThreadLocal的初始值。&lt;/li&gt;
&lt;li&gt;set：设置Value到当前线程的ThreadLocal中去。&lt;/li&gt;
&lt;li&gt;get：获取当前线程存储在ThreadLocal中的Value。&lt;/li&gt;
&lt;li&gt;remove：移除当前线程ThreadLocal存储的Value。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：ThreadLocal是一个变量对象，一个ThreadLocal是一个存储位置。如果线程需要多个存储位置，则创建多个ThreadLocal。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="https://veryjj.github.io/tags/ThreadLocal/"/>
    
      <category term="内存泄露" scheme="https://veryjj.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你Java字节码Demo</title>
    <link href="https://veryjj.github.io/2021/01/01/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0Java%E5%AD%97%E8%8A%82%E7%A0%81Demo/"/>
    <id>https://veryjj.github.io/2021/01/01/手把手教你Java字节码Demo/</id>
    <published>2021-01-01T09:26:59.000Z</published>
    <updated>2021-01-10T09:19:46.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手把手教你Java字节码Demo"><a href="#手把手教你Java字节码Demo" class="headerlink" title="手把手教你Java字节码Demo"></a>手把手教你Java字节码Demo</h2><p>接触中间件的开发来说，了解像Pinpoint（<a href="https://github.com/naver/pinpoint）、BTrace（https://github.com/btraceio/btrace）、阿里的JVM-SANDBOX（https://github.com/alibaba/jvm-sandbox）、Java在线问题诊断工具**Greys**（https://github.com/oldmanpushcart/greys-anatomy）等，都是通过字节码技术，无侵入的干预到Java应用程序。很清爽又很实用。" target="_blank" rel="noopener">https://github.com/naver/pinpoint）、BTrace（https://github.com/btraceio/btrace）、阿里的JVM-SANDBOX（https://github.com/alibaba/jvm-sandbox）、Java在线问题诊断工具**Greys**（https://github.com/oldmanpushcart/greys-anatomy）等，都是通过字节码技术，无侵入的干预到Java应用程序。很清爽又很实用。</a></p><p><br></p><p>今天就记录字节码的两种实现demo，作为入门了解。</p><p><br></p><p>Java Agent的最常用方式:</p><ul><li>一种是premain方式：它属于静态注入。即在Java应用程序启动时，在类加载器对类的字节码进行加载之前对类字节码进行“再改造”来做功能增强（例如实现AOP）</li><li>一种是：HotSpot独有的attach方式（JDK1.6才出现），它能实现动态注入，对已经运行的Java应用的类进行字节码增强。</li></ul><a id="more"></a><p><br></p><h2 id="方式一：premain静态方式"><a href="#方式一：premain静态方式" class="headerlink" title="方式一：premain静态方式"></a>方式一：premain静态方式</h2><p>（大多中间件/工具的方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:/root/application-premain.jar MyApp</span><br></pre></td></tr></table></figure><p>如上面这句java启动命令，假定/root目录下已经有一个符合Java Agent规范的Jar了（这里指application-premain.jar），而MyApp是指我们Java应用的启动类（main方法的类），如此我们就能成功的对这个Java应用进行了静态注入。</p><p>接下来，分解一下具体实现步骤。</p><p><br></p><p><strong>1、建个独立Maven工程</strong></p><p>pom的必要依赖和设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.21.0-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--      注意：如果需要进行attach，那么需要引入tools.jar--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/../lib/tools.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>application-premain<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--避免MANIFEST.MF被覆盖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifestFile</span>&gt;</span>src/main/resources/META-INF/MANIFEST.MF<span class="tag">&lt;/<span class="name">manifestFile</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--打包时加入依赖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>2、准备MyApp</strong></p><p>Java应用相当简单，里面就一个打印语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            printSth();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Hello World!"</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此例中，我们目标对<code>printSth()</code>方法进行字节码级改造，植入额外逻辑。（最终会打包成例子中的application-premain.jar）</p><p><br></p><p>Maven工程结构大致如下：</p><p><img src="/2021/01/01/手把手教你Java字节码Demo/image-20210101161800811.png" alt="image-20210101161800811"></p><p><br></p><p><strong>3、编写MyTransformer</strong></p><p>MyTransformer类是具体实现字节码植入的实现类。</p><p>此例中，字节码植入的逻辑是两个打印语句。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.asm.premain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader,</span><br><span class="line">                            String className,</span><br><span class="line">                            Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                            ProtectionDomain protectionDomain,</span><br><span class="line">                            <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳过java自带方法</span></span><br><span class="line">        <span class="keyword">if</span> (className.startsWith(<span class="string">"java"</span>) || className.startsWith(<span class="string">"sun"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//好像使用premain这个className是没问题的，但使用attach时className的.变成了/，所以如果是attach，那么这里需要替换</span></span><br><span class="line">        className = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只处理MyApp类</span></span><br><span class="line">        <span class="keyword">if</span> (!className.endsWith(<span class="string">"MyApp"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">            CtClass ctClass = classPool.get(className);</span><br><span class="line">            CtMethod[] declaredMethods = ctClass.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (CtMethod declaredMethod : declaredMethods)&#123;</span><br><span class="line">                <span class="comment">//只处理printSth方法</span></span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(<span class="string">"printSth"</span>, declaredMethod.getName()))&#123;</span><br><span class="line">                    <span class="comment">//在方法执行前插入打印语句</span></span><br><span class="line">                    declaredMethod.insertBefore(<span class="string">"System.out.println(\"=====start=====\");"</span>);</span><br><span class="line">                    <span class="comment">//在方法执行后插入打印语句</span></span><br><span class="line">                    declaredMethod.insertAfter(<span class="string">"System.out.println(\"=====end=====\");"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到MyTransformer实现了ClassFileTransformer接口，ClassFileTransformer是专门为Java Agent提供类转换功能的接口。</p><p>在transform方法中，我们可以大显身手了，从上面代码片段可以看出，我们只是对MyApp#printSth方法的之前和末尾各加入了一条打印语句，你可能会奇怪，不是字节码吗？为啥可以直接像表达式引擎一样直接输入Java表达式？是因为这里使用了<strong>javassist</strong>这一轻量级的字节码工具，它帮我们屏蔽了字节码的细节，使我们可以只关注Java代码。</p><p><br></p><p><strong>4、编写Premain类</strong></p><p>有了MyTransformer，在哪用？答案就在PremainMain类中，PremainMain要做的事情很简单，就是把我们自定义的类转换器MyTransformer加到前面提到的Instrumentation实例中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.asm.premain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PremainMain</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意，这个premain方法签名是Java Agent约定的，不要随意修改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> agentArgs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instrumentation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">new</span> MyTransformer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意</code>：PremainMain#premain的方法签名是Java Agent内部约定的，不能随意修改。</p><p><br></p><p><strong>5、编写MANIFEST.MF</strong></p><p>Java Agent是怎么知道premain方法在哪个类中呢？答案就application-premain.jar的resources/META-INF/MANIFEST.MF文件中<strong>，</strong>MANIFEST.MF文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Created-By: veryJJ</span><br><span class="line">Premain-Class: org.example.asm.premain.PremainMain</span><br></pre></td></tr></table></figure><p>注意：最后一行需要留一个空行</p><p><br></p><p><strong>6、打包&amp;运行</strong></p><p>几步操作下来，必要的文件已就绪，我们把它打成一个jar包（需要包含javassist），需用到maven-assembly-plugin插件（再check下pom），项目的pom.xml文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>asm-premain<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--避免MANIFEST.MF被覆盖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifestFile</span>&gt;</span>src/main/resources/META-INF/MANIFEST.MF<span class="tag">&lt;/<span class="name">manifestFile</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--打包时加入依赖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们直接执行Maven的打包命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><p>打包完成后，我们会在target目录下得到：application-premain.jar 和 application-premain-jar-with-dependences.jar。注，用<code>application-premain-jar-with-dependences.jar</code>哦。为了方便，可以在cp命令拷贝到/root目录时顺便重命名的短一些。（拷贝其他任何目录都可以的哦）</p><p><br></p><p>一切就绪了，idea上运行</p><p><img src="/2021/01/01/手把手教你Java字节码Demo/image-20210101164109866.png" alt="image-20210101164109866"></p><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">=====start=====</span><br><span class="line">Hello World!</span><br><span class="line">=====end=====</span><br><span class="line">=====start=====</span><br><span class="line">Hello World!</span><br><span class="line">=====end=====</span><br><span class="line">=====start=====</span><br><span class="line">Hello World!</span><br><span class="line">=====end=====</span><br><span class="line">=====start=====</span><br><span class="line">Hello World!</span><br><span class="line">=====end=====</span><br><span class="line">=====start=====</span><br><span class="line">Hello World!</span><br><span class="line">=====end=====</span><br><span class="line">=====start=====</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>可以看到，原本只有一个打印”Hello World”语句的MyApp类，在前后加了两条打印语句，目标达成！！！！！</p><p><br></p><h2 id="方式二、AttachAgent动态方式"><a href="#方式二、AttachAgent动态方式" class="headerlink" title="方式二、AttachAgent动态方式"></a>方式二、AttachAgent动态方式</h2><p>（混动工程的实现方式）</p><p>如何动态注入字节码呢？为了更清晰的展示，我们创建两个独立的maven工程，一个模拟业务应用：循环执行printSth方法。一个模拟动态attach植入。</p><p><img src="/2021/01/01/手把手教你Java字节码Demo/image-20210101171325334.png" alt="image-20210101171325334"></p><p>OrderApp代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            printSth();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Hello World!"</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>准备动态植入的代码</p></blockquote><p><strong>1、编写Transformer类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.attach;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAttachTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader,</span><br><span class="line">                            String className,</span><br><span class="line">                            Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                            ProtectionDomain protectionDomain,</span><br><span class="line">                            <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳过java自带方法</span></span><br><span class="line">        <span class="keyword">if</span> (className.startsWith(<span class="string">"java"</span>) || className.startsWith(<span class="string">"sun"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//好像使用premain这个className是没问题的，但使用attach时className的.变成了/，所以如果是attach，那么这里需要替换</span></span><br><span class="line">        className = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只处理MyApp类</span></span><br><span class="line">        <span class="keyword">if</span> (!className.endsWith(<span class="string">"OrderApp"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">            CtClass ctClass = classPool.get(className);</span><br><span class="line">            CtMethod[] declaredMethods = ctClass.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (CtMethod declaredMethod : declaredMethods)&#123;</span><br><span class="line">                <span class="comment">//只处理printSth方法</span></span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(<span class="string">"printSth"</span>, declaredMethod.getName()))&#123;</span><br><span class="line">                    <span class="comment">//在方法执行前插入打印语句</span></span><br><span class="line">                    declaredMethod.insertBefore(<span class="string">"System.out.println(\"=====start=====\");"</span>);</span><br><span class="line">                    <span class="comment">//在方法执行后插入打印语句</span></span><br><span class="line">                    declaredMethod.insertAfter(<span class="string">"System.out.println(\"=====end=====\");"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>2、新增AttachAgent类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.asm.attach;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.example.asm.premain.MyTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.UnmodifiableClassException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachAgent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意：agentmain的方法签名也是约定好的，不能随意修改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 其实如果要支持premain和attach两种方式的话，可以把premain和agentmain两个方法写在一个类里，这里为了方便演示，写成了两个</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> agentArgs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instrumentation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        String targetClassPath = <span class="string">"org.example.MyApp"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"come in agentmain"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : instrumentation.getAllLoadedClasses()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 过滤掉不能修改的类</span></span><br><span class="line">            <span class="keyword">if</span>(!instrumentation.isModifiableClass(clazz)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"clazz = "</span> + clazz.getName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只修改我们关心的类</span></span><br><span class="line">            <span class="keyword">if</span> (clazz.getName().equals(targetClassPath)) &#123;</span><br><span class="line">                <span class="comment">// 最根本的目的还是把MyTransformer添加到instrumentation中</span></span><br><span class="line">                instrumentation.addTransformer(<span class="keyword">new</span> MyTransformer(), <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    instrumentation.retransformClasses(clazz);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnmodifiableClassException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里约定好的方法是agentmain，但agentmain方法的本质也是把MyTransformer添加到instrumentation中，进而动态刷新目标class的transformer。</p><p><br></p><p><strong>3、配置MANIFEST.MF</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Created-By: veryJJ</span><br><span class="line">Agent-Class: org.attach.AttachAgent</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br></pre></td></tr></table></figure><p><br></p><p><strong>4、test-asm-attach工程打包</strong></p><p>得到attach-premain-jar-with-dependencies.jar和attach-premain.jar</p><p>记得使用：attach-premain-jar-with-dependencies.jar（对应下面attchMain中的jar，按需重命名）</p><p><br></p><p><strong>5、此时，先运行OrderApp</strong></p><p>会看到，此时OrderApp循环打印“Hello World！”</p><p><img src="/2021/01/01/手把手教你Java字节码Demo/image-20210101171956793.png" alt="image-20210101171956793"></p><p><br></p><p><strong>6、编写并运行动态AttachMain代码</strong></p><p>编写attachMain，并attach到OrderApp上去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.attach;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//OrderApp的jvm进程ID</span></span><br><span class="line">        String jvmPID = <span class="string">"6279"</span>;</span><br><span class="line"></span><br><span class="line">        File agentFile = <span class="keyword">new</span> File(<span class="string">"/你的目录路径/attach-premain-all.jar"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!agentFile.isFile())&#123;</span><br><span class="line">            System.out.println(<span class="string">"jar 不存在"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            VirtualMachine jvm = VirtualMachine.attach(jvmPID);</span><br><span class="line">            jvm.loadAgent(agentFile.getAbsolutePath());</span><br><span class="line">            jvm.detach();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"attach 成功"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//attach植入后就可以退出了哦。因为代码已经进入目标JVM的内存空间了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述AttachMain，此时查看OrderApp的控制台界面，会得到：</p><p><img src="/2021/01/01/手把手教你Java字节码Demo/image-20210101172225086.png" alt="image-20210101172225086"></p><p>至此，就完成了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;手把手教你Java字节码Demo&quot;&gt;&lt;a href=&quot;#手把手教你Java字节码Demo&quot; class=&quot;headerlink&quot; title=&quot;手把手教你Java字节码Demo&quot;&gt;&lt;/a&gt;手把手教你Java字节码Demo&lt;/h2&gt;&lt;p&gt;接触中间件的开发来说，了解像Pinpoint（&lt;a href=&quot;https://github.com/naver/pinpoint）、BTrace（https://github.com/btraceio/btrace）、阿里的JVM-SANDBOX（https://github.com/alibaba/jvm-sandbox）、Java在线问题诊断工具**Greys**（https://github.com/oldmanpushcart/greys-anatomy）等，都是通过字节码技术，无侵入的干预到Java应用程序。很清爽又很实用。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/naver/pinpoint）、BTrace（https://github.com/btraceio/btrace）、阿里的JVM-SANDBOX（https://github.com/alibaba/jvm-sandbox）、Java在线问题诊断工具**Greys**（https://github.com/oldmanpushcart/greys-anatomy）等，都是通过字节码技术，无侵入的干预到Java应用程序。很清爽又很实用。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;今天就记录字节码的两种实现demo，作为入门了解。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Java Agent的最常用方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种是premain方式：它属于静态注入。即在Java应用程序启动时，在类加载器对类的字节码进行加载之前对类字节码进行“再改造”来做功能增强（例如实现AOP）&lt;/li&gt;
&lt;li&gt;一种是：HotSpot独有的attach方式（JDK1.6才出现），它能实现动态注入，对已经运行的Java应用的类进行字节码增强。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="字节码" scheme="https://veryjj.github.io/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>CGLIB中常用API</title>
    <link href="https://veryjj.github.io/2020/12/31/CGLIB%E4%B8%AD%E5%B8%B8%E7%94%A8API/"/>
    <id>https://veryjj.github.io/2020/12/31/CGLIB中常用API/</id>
    <published>2020-12-31T06:30:10.000Z</published>
    <updated>2021-01-10T09:18:15.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h2><p>CGLIB，即Code Generation Library，是一个开源项目。Github地址：<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener"><strong>https://github.com/cglib/cglib</strong></a>。</p><p>CGLIB的github简介：CGLIB - 字节码生成库，是用于生成和转换Java字节码的高级API。它被AOP、测试、数据访问框架用于生成动态代理对象和拦截字段访问。</p><p>CGLIB提供两种类型的JAR包：</p><ul><li>cglib-nodep-x.x.x.jar：使用nodep包不需要关联ASM的jar包，jar包内部包含ASM的类库。</li><li>cglib-x.x.x.jar：使用此jar包需要另外提供ASM的jar包，否则运行时报错，建议选用不包含ASM类库的jar包，可以方便控制ASM的。</li></ul><p>本文中使用的CGLIB依赖为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;cglib&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">&lt;artifactId&gt;cglib-nodep&lt;/</span>artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">3.2</span><span class="number">.10</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.projectlombok&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">&lt;artifactId&gt;lombok&lt;/</span>artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">1.16</span><span class="number">.22</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><h2 id="CGLIB基本原理"><a href="#CGLIB基本原理" class="headerlink" title="CGLIB基本原理"></a>CGLIB基本原理</h2><ul><li>基本原理：动态生成一个要代理类的子类(<strong>被代理的类作为继承的父类</strong>)，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用Java反射的JDK动态代理要快，因为它采用了整形变量建立了方法索引。</li><li>底层实现：使用字节码处理框架ASM，用于转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求必须对JVM内部结构包括class文件的格式和JVM指令集都很熟悉，<strong>否则一旦出现错误将会是JVM崩溃级别的异常</strong>。</li></ul><p><br></p><h2 id="CGLIB的包结构"><a href="#CGLIB的包结构" class="headerlink" title="CGLIB的包结构"></a>CGLIB的包结构</h2><ul><li>net.sf.cglib.core：底层字节码处理类，大部分与ASM有关。</li><li>net.sf.cglib.transform：编译期或运行期类和类文件的转换。</li><li>net.sf.cglib.proxy：实现创建代理和方法拦截器的类。</li><li>net.sf.cglib.reflect：反射相关工具类。</li><li>net.sf.cglib.util：集合排序等工具类。</li><li>net.sf.cglib.beans：JavaBean相关的工具类。</li></ul><p><br></p><h2 id="CGLIB常用API"><a href="#CGLIB常用API" class="headerlink" title="CGLIB常用API"></a>CGLIB常用API</h2><p>下面介绍一下CGLIB中常用的几个API，先建立一个模特接口类和普通模特类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> String.format(<span class="string">"%s say hello!"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="Enhancer"><a href="#Enhancer" class="headerlink" title="Enhancer"></a>Enhancer</h2><p>Enhancer，即(字节码)增强器。它是CGLIB库中最常用的一个类，功能与JDK动态代理中引入的Proxy类差不多，但是Enhancer既能够代理普通的Java类，也能够代理接口。</p><p>Enhancer创建一个被代理对象的子类并且<code>拦截所有的方法调用</code>（包括从Object中继承的toString和hashCode方法）。</p><p>Enhancer不能够拦截final方法，例如Object.getClass()方法，这是由于final关键字的语义决定的。基于同样的道理，Enhancer也不能对fianl类进行代理操作。这也是Hibernate为什么不能持久化final关键字修饰的类的原因。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">EnhancerClassDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    <span class="comment">//使用FixedValue，拦截返回值，每次返回固定值"Doge say hello!"</span></span><br><span class="line">enhancer.setCallback((FixedValue) () -&gt; <span class="string">"Doge say hello!"</span>);</span><br><span class="line">    </span><br><span class="line">SampleClass sampleClass = (SampleClass) enhancer.create();</span><br><span class="line">System.out.println(sampleClass.sayHello(<span class="string">"throwable-10086"</span>));</span><br><span class="line">System.out.println(sampleClass.sayHello(<span class="string">"throwable-doge"</span>));</span><br><span class="line">System.out.println(sampleClass.toString());</span><br><span class="line">System.out.println(sampleClass.getClass());</span><br><span class="line">System.out.println(sampleClass.hashCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Doge say hello!</span><br><span class="line">Doge say hello!</span><br><span class="line">Doge say hello!</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">club</span>.<span class="title">throwable</span>.<span class="title">cglib</span>.<span class="title">SampleClass</span>$$<span class="title">EnhancerByCGLIB</span>$$6<span class="title">f6e7a68</span></span></span><br><span class="line">Exception in thread "main" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Number</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>上述代码中，FixedValue用来对所有拦截的方法返回相同的值，从输出我们可以看出来，Enhancer对非final方法test()、toString()、hashCode()进行了拦截，没有对getClass进行拦截。由于hashCode()方法需要返回一个Number，但是我们返回的是一个String，这解释了上面的程序中为什么会抛出异常。</p><p><br></p><p><code>Enhancer#setSuperclass()</code>用来设置父类型，从<code>toString()</code>方法可以看出，使用CGLIB生成的类为被代理类的一个子类，类简写名称为<code>SampleClass$$EnhancerByCGLIB$$e3ea9b7</code>。</p><p><br></p><p><code>Enhancer#create(Class[] argumentTypes, Object[] arguments)</code>方法是用来创建增强对象的，其提供了很多不同参数的方法用来匹配被增强类的不同构造方法。我们也可以先使用<code>Enhancer#createClass()</code>来创建字节码(.class)，然后用字节码加载完成后的类动态生成增强后的对象。<br>Enhancer中还有其他几个方法名为create的方法，提供不同的参数选择，具体可以自行查阅。</p><p><br></p><p>下面再举个例子说明一下使用Enhancer代理接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">EnhancerInterfaceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;SampleInterface.class&#125;);</span><br><span class="line">enhancer.setCallback((FixedValue) () -&gt; <span class="string">"Doge say hello!"</span>);</span><br><span class="line">SampleInterface sampleInterface = (SampleInterface) enhancer.create();</span><br><span class="line">System.out.println(sampleInterface.sayHello(<span class="string">"throwable-10086"</span>));</span><br><span class="line">System.out.println(sampleInterface.sayHello(<span class="string">"throwable-doge"</span>));</span><br><span class="line">System.out.println(sampleInterface.toString());</span><br><span class="line">System.out.println(sampleInterface.getClass());</span><br><span class="line">System.out.println(sampleInterface.hashCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果和上一个例子一致。</p><p><br></p><h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><p>Callback，即回调。值得注意的是，它是一个标识接口(空接口，没有任何方法)，它的回调时机是生成的代理类的方法被调用的时候。也就是说，生成的代理类的方法被调用的时候，Callback的实现逻辑就会被调用。Enhancer通过<code>setCallback()</code>和<code>setCallbacks()</code>设置<code>Callback</code>，<strong>设置了多个Callback实例将会按照设置的顺序进行回调</strong>。CGLIB中提供的Callback的子类有以下几种：</p><ul><li>NoOp</li><li>FixedValue</li><li>InvocationHandler</li><li>MethodInterceptor</li><li>Dispatcher</li><li>LazyLoader</li></ul><p><br></p><h3 id="NoOp"><a href="#NoOp" class="headerlink" title="NoOp"></a>NoOp</h3><p>NoOp，No Operation，也就是不做任何操作。这个回调实现只是简单地把方法调用委托给了被代理类的原方法(也就是<code>调用原始类的原始方法</code>)，不做任何其它的操作，所以不能使用在接口代理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NoOpDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception&#123;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">enhancer.setCallback(NoOp.INSTANCE);</span><br><span class="line">SampleClass sampleClass = (SampleClass) enhancer.create();</span><br><span class="line">System.out.println(sampleClass.sayHello(<span class="string">"throwable"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throwable say hello!</span><br></pre></td></tr></table></figure><p><br></p><h3 id="FixedValue"><a href="#FixedValue" class="headerlink" title="FixedValue"></a>FixedValue</h3><p>FixedValue，Fixed Value，即固定值。</p><p>它提供了一个<code>loadObject()</code>方法，不过这个方法返回的不是代理对象，而是原方法调用想要的结果。也就是说，在这个Callback里面，看不到任何原方法的信息，也就没有调用原方法的逻辑，不管原方法是什么都只会调用<code>loadObject()</code>并返回一个固定结果。</p><p>需要注意的是，如果loadObject()方法的返回值并不能转换成原方法的返回值类型，那么会抛出类型转换异常(ClassCastException)。</p><p>最前面的Enhancer两个例子就是用FixedValue做分析的，这里不再举例。</p><p><br></p><h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h3><p>InvocationHandler全类名为<code>net.sf.cglib.proxy.InvocationHandler</code>，它的功能和JDK动态代理中的<code>java.lang.reflect.InvocationHandler</code>类似，提供了一个<code>Object invoke(Object proxy, Method method, Object[] objects)</code>方法。</p><p>需要注意的是：所有对invoke方法的参数proxy对象的方法调用都会被委托给同一个InvocationHandler，所以可能会<code>导致无限循环</code>(因为invoke中调用的任何原代理类方法，均会重新代理到invoke方法中)。举个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerDeadLoopDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception&#123;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">@Override</span><br><span class="line">public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> o, Method method, <span class="built_in">Object</span>[] objects) throws Throwable &#123;</span><br><span class="line"><span class="keyword">return</span> method.invoke(o, objects);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">SampleClass sampleClass = (SampleClass) enhancer.create();</span><br><span class="line">System.out.println(sampleClass.sayHello(<span class="string">"throwable"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的main方法执行后会直接爆栈，因为<code>method#invoke()</code>方法会重新调用InvocationHandler的invoke方法，形成死循环。</p><p>正确的使用例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">@Override</span><br><span class="line">public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> o, Method method, <span class="built_in">Object</span>[] objects) throws Throwable &#123;</span><br><span class="line"><span class="keyword">if</span> (!Objects.equals(method.getDeclaringClass(), <span class="built_in">Object</span>.class) &amp;&amp; Objects.equals(<span class="built_in">String</span>.class, method.getReturnType())) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">String</span>.format(<span class="string">"%s say hello!"</span>, objects);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"No one say hello!"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">SampleClass sampleClass = (SampleClass) enhancer.create();</span><br><span class="line">System.out.println(sampleClass.sayHello(<span class="string">"throwable"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throwable say hello!</span><br></pre></td></tr></table></figure><p><br></p><h3 id="MethodInterceptor"><a href="#MethodInterceptor" class="headerlink" title="MethodInterceptor"></a>MethodInterceptor</h3><p>MethodInterceptor，即方法拦截器，这是一个功能很强大的接口，它可以实现类似于AOP编程中的环绕增强（Around Advice）。</p><p>它只有一个方法<code>public Object intercept(Object obj,java.lang.reflect.Method method,Object[] args,MethodProxy methodProxy) throws Throwable</code>。设置了MethodInterceptor后，代理类的所有方法调用都会转而执行这个接口中的intercept方法而不是原方法。如果需要在intercept方法中执行原方法可以使用参数method基于代理实例obj进行反射调用，但是使用方法代理methodProxy效率会更高（反射调用比正常的方法调用的速度慢很多）。</p><p><code>MethodInterceptor的生成效率不高，它的优势在于调用效率</code>，它需要产生不同类型的字节码，并且需要生成一些运行时对象(InvocationHandler就不需要)。</p><p><strong>注意</strong>，在使用MethodProxy调用invokeSuper方法相当于通过方法代理直接调用原类的对应方法，如果调用MethodProxy的invoke会进入死循环导致爆栈，原因跟InvocationHandler差不多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MethodInterceptorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">@Override</span><br><span class="line">public <span class="built_in">Object</span> intercept(<span class="built_in">Object</span> obj, Method method, <span class="built_in">Object</span>[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">System.out.println(<span class="string">"Before invoking sayHello..."</span>);</span><br><span class="line"><span class="built_in">Object</span> result = methodProxy.invokeSuper(obj, objects);</span><br><span class="line">System.out.println(<span class="string">"After invoking sayHello..."</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">SampleClass sampleClass = (SampleClass) enhancer.create();</span><br><span class="line">System.out.println(sampleClass.sayHello(<span class="string">"throwable"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before invoking sayHello...</span><br><span class="line">After invoking sayHello...</span><br><span class="line">throwable say hello!</span><br></pre></td></tr></table></figure><p>这个例子就是Spring的AOP中的环绕增强(Around Advice)的简化版，这里没有改变原来的方法的行为，只是在方法调用前和调用后织入额外的逻辑。</p><p><br></p><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>Dispatcher，即分发器，提供一个方法<code>Object loadObject() throws Exception;</code>，同样地返回一个代理对象，这个对象同样可以代理原方法的调用。Dispatcher的<code>loadObject()</code>方法在每次发生对原方法的调用时都会被调用并返回一个代理对象来调用原方法。Dispatcher可以类比为Spring中的Prototype类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DispatcherDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> final AtomicInteger COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">SampleInterfaceImpl impl = <span class="keyword">new</span> SampleInterfaceImpl();</span><br><span class="line">enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;SampleInterface.class&#125;);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> Dispatcher() &#123;</span><br><span class="line">@Override</span><br><span class="line">public <span class="built_in">Object</span> loadObject() throws Exception &#123;</span><br><span class="line">COUNTER.incrementAndGet();</span><br><span class="line"><span class="keyword">return</span> impl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">SampleInterface sampleInterface = (SampleInterface) enhancer.create();</span><br><span class="line">System.out.println(sampleInterface.sayHello(<span class="string">"throwable-1"</span>));</span><br><span class="line">System.out.println(sampleInterface.sayHello(<span class="string">"throwable-2"</span>));</span><br><span class="line">System.out.println(COUNTER.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleInterfaceImpl</span> <span class="title">implements</span> <span class="title">SampleInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">public SampleInterfaceImpl()&#123;</span><br><span class="line">System.out.println(<span class="string">"SampleInterfaceImpl init..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="built_in">String</span> sayHello(<span class="built_in">String</span> name) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello i am SampleInterfaceImpl!"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SampleInterfaceImpl init...</span><br><span class="line">Hello i am SampleInterfaceImpl!</span><br><span class="line">Hello i am SampleInterfaceImpl!</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>计数器输出为2，印证了每次调用方法都会回调Dispatcher中的实例进行调用。</p><p><br></p><h3 id="LazyLoader"><a href="#LazyLoader" class="headerlink" title="LazyLoader"></a>LazyLoader</h3><p>LazyLoader，即懒加载器，它只提供了一个方法<code>Object loadObject() throws Exception;</code>，loadObject()方法会在第一次被代理类的方法调用时触发，它返回一个代理类的对象，这个对象会被存储起来然后负责所有被代理类方法的调用，就像它的名字说的那样，一种lazy加载模式。如果被代理类或者代理类的对象的创建比较麻烦，而且不确定它是否会被使用，那么可以选择使用这种lazy模式来延迟生成代理。</p><p>LazyLoader可以类比为Spring中的Lazy模式的Singleton。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LazyLoaderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> final AtomicInteger COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">SampleInterfaceImpl impl = <span class="keyword">new</span> SampleInterfaceImpl();</span><br><span class="line">enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;SampleInterface.class&#125;);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> LazyLoader() &#123;</span><br><span class="line">@Override</span><br><span class="line">public <span class="built_in">Object</span> loadObject() throws Exception &#123;</span><br><span class="line">COUNTER.incrementAndGet();</span><br><span class="line"><span class="keyword">return</span> impl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">SampleInterface sampleInterface = (SampleInterface) enhancer.create();</span><br><span class="line">System.out.println(sampleInterface.sayHello(<span class="string">"throwable-1"</span>));</span><br><span class="line">System.out.println(sampleInterface.sayHello(<span class="string">"throwable-2"</span>));</span><br><span class="line">System.out.println(COUNTER.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleInterfaceImpl</span> <span class="title">implements</span> <span class="title">SampleInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">public SampleInterfaceImpl()&#123;</span><br><span class="line">System.out.println(<span class="string">"SampleInterfaceImpl init..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="built_in">String</span> sayHello(<span class="built_in">String</span> name) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello i am SampleInterfaceImpl!"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SampleInterfaceImpl init...</span><br><span class="line">Hello i am SampleInterfaceImpl!</span><br><span class="line">Hello i am SampleInterfaceImpl!</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>计数器输出为1，印证了LazyLoader中的实例只回调了1次，这就是懒加载。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CGLIB&quot;&gt;&lt;a href=&quot;#CGLIB&quot; class=&quot;headerlink&quot; title=&quot;CGLIB&quot;&gt;&lt;/a&gt;CGLIB&lt;/h2&gt;&lt;p&gt;CGLIB，即Code Generation Library，是一个开源项目。Github地址：&lt;a href=&quot;https://github.com/cglib/cglib&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;https://github.com/cglib/cglib&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;CGLIB的github简介：CGLIB - 字节码生成库，是用于生成和转换Java字节码的高级API。它被AOP、测试、数据访问框架用于生成动态代理对象和拦截字段访问。&lt;/p&gt;
&lt;p&gt;CGLIB提供两种类型的JAR包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cglib-nodep-x.x.x.jar：使用nodep包不需要关联ASM的jar包，jar包内部包含ASM的类库。&lt;/li&gt;
&lt;li&gt;cglib-x.x.x.jar：使用此jar包需要另外提供ASM的jar包，否则运行时报错，建议选用不包含ASM类库的jar包，可以方便控制ASM的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文中使用的CGLIB依赖为：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;groupId&amp;gt;cglib&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;	&amp;lt;artifactId&amp;gt;cglib-nodep&amp;lt;/&lt;/span&gt;artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;version&amp;gt;&lt;span class=&quot;number&quot;&gt;3.2&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.10&lt;/span&gt;&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;&amp;lt;/&lt;/span&gt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;	&amp;lt;artifactId&amp;gt;lombok&amp;lt;/&lt;/span&gt;artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;version&amp;gt;&lt;span class=&quot;number&quot;&gt;1.16&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.22&lt;/span&gt;&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;&amp;lt;/&lt;/span&gt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="cglib" scheme="https://veryjj.github.io/tags/cglib/"/>
    
      <category term="字节码" scheme="https://veryjj.github.io/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>解决homebrew长时间停在Updating Homebrew 这个步骤</title>
    <link href="https://veryjj.github.io/2020/12/19/%E8%A7%A3%E5%86%B3homebrew%E9%95%BF%E6%97%B6%E9%97%B4%E5%81%9C%E5%9C%A8Updating%20Homebrew%20%E8%BF%99%E4%B8%AA%E6%AD%A5%E9%AA%A4/"/>
    <id>https://veryjj.github.io/2020/12/19/解决homebrew长时间停在Updating Homebrew 这个步骤/</id>
    <published>2020-12-19T14:33:11.000Z</published>
    <updated>2021-01-10T09:11:11.103Z</updated>
    
    <content type="html"><![CDATA[<p>在国内的网络环境下使用 Homebrew 安装软件的过程中可能会长时间卡在 Updating Homebrew 这个步骤。</p><p>例：执行 brew install composer 命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ brew install composer</span><br><span class="line">Updating Homebrew... # 如果碰到长时间卡在这里，参考以下 2 种处理方法</span><br></pre></td></tr></table></figure></p><a id="more"></a><p> <br></p><h2 id="方法-1：按住-control-c-取消本次更新操作"><a href="#方法-1：按住-control-c-取消本次更新操作" class="headerlink" title="方法 1：按住 control + c 取消本次更新操作"></a>方法 1：按住 control + c 取消本次更新操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ brew install composer</span><br><span class="line">Updating Homebrew...</span><br><span class="line">^C</span><br><span class="line">按住 control + c 之后命令行会显示 ^C，就代表已经取消了 Updating Homebrew 操作</span><br><span class="line"></span><br><span class="line">大概不到 1 秒钟之后就会去执行我们真正需要的安装操作了</span><br><span class="line"></span><br><span class="line">➜  ~ brew install composer</span><br><span class="line">Updating Homebrew...</span><br><span class="line">^C==&gt; Satisfying dependencies</span><br><span class="line">==&gt; Downloading https://getcomposer.org/download/1.7.2/composer.phar</span><br><span class="line">...</span><br><span class="line">这个方法是临时的、一次性的</span><br></pre></td></tr></table></figure><p> <br></p><h2 id="【推荐】方法-2：使用-Alibaba-的-Homebrew-镜像源进行加速"><a href="#【推荐】方法-2：使用-Alibaba-的-Homebrew-镜像源进行加速" class="headerlink" title="【推荐】方法 2：使用 Alibaba 的 Homebrew 镜像源进行加速"></a>【推荐】方法 2：使用 Alibaba 的 Homebrew 镜像源进行加速</h2><p>平时我们执行 brew 命令安装软件的时候，跟以下 3 个仓库地址有关：</p><ul><li><p>brew.git</p></li><li><p>homebrew-core.git</p></li><li><p>homebrew-bottles</p></li></ul><p>通过以下操作将这 3 个仓库地址全部替换为 Alibaba 提供的地址<br><br></p><h3 id="1-替换-还原-brew-git-仓库地址"><a href="#1-替换-还原-brew-git-仓库地址" class="headerlink" title="1. 替换 / 还原 brew.git 仓库地址"></a>1. 替换 / 还原 brew.git 仓库地址</h3><ul><li>替换成阿里巴巴的 brew.git 仓库地址:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd "$(brew --repo)"</span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>还原为官方提供的 brew.git 仓库地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd "$(brew --repo)"</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/brew.git</span><br></pre></td></tr></table></figure><p> <br></p><h3 id="2-替换-还原-homebrew-core-git-仓库地址"><a href="#2-替换-还原-homebrew-core-git-仓库地址" class="headerlink" title="2. 替换 / 还原 homebrew-core.git 仓库地址"></a>2. 替换 / 还原 homebrew-core.git 仓库地址</h3><ul><li>替换成阿里巴巴的 homebrew-core.git 仓库地址:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"</span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure><p><br></p><ul><li>还原为官方提供的 homebrew-core.git 仓库地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-替换-还原-homebrew-bottles-访问地址"><a href="#3-替换-还原-homebrew-bottles-访问地址" class="headerlink" title="3. 替换 / 还原 homebrew-bottles 访问地址"></a>3. 替换 / 还原 homebrew-bottles 访问地址</h3><p>这个步骤跟你的 macOS 系统使用的 shell 版本有关系</p><p>所以，先来查看当前使用的 shell 版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure></p><ul><li>如果你的输出结果是 /bin/zsh，参考3.1的 zsh 终端操作方式</li><li>如果你的输出结果是 /bin/bash，参考3.2的 bash 终端操作方式</li></ul><h4 id="3-1-zsh-终端操作方式"><a href="#3-1-zsh-终端操作方式" class="headerlink" title="3.1 zsh 终端操作方式"></a>3.1 zsh 终端操作方式</h4><ul><li>替换成阿里巴巴的 homebrew-bottles 访问地址:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p><br></p><ul><li>还原为官方提供的 homebrew-bottles 访问地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br><span class="line">然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-2-bash-终端操作方式"><a href="#3-2-bash-终端操作方式" class="headerlink" title="3.2 bash 终端操作方式"></a>3.2 bash 终端操作方式</h4><ul><li>替换 homebrew-bottles 访问 URL:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p><br></p><ul><li>还原为官方提供的 homebrew-bottles 访问地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line">然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在国内的网络环境下使用 Homebrew 安装软件的过程中可能会长时间卡在 Updating Homebrew 这个步骤。&lt;/p&gt;
&lt;p&gt;例：执行 brew install composer 命令&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;➜  ~ brew install composer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Updating Homebrew... # 如果碰到长时间卡在这里，参考以下 2 种处理方法&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://veryjj.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="homebrew" scheme="https://veryjj.github.io/tags/homebrew/"/>
    
  </entry>
  
  <entry>
    <title>slf4j MDC是个好东西</title>
    <link href="https://veryjj.github.io/2020/12/19/slf4j%20MDC%E6%98%AF%E4%B8%AA%E5%A5%BD%E4%B8%9C%E8%A5%BF/"/>
    <id>https://veryjj.github.io/2020/12/19/slf4j MDC是个好东西/</id>
    <published>2020-12-19T12:26:57.000Z</published>
    <updated>2021-01-10T09:22:03.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="slf4j-MDC是个好东西"><a href="#slf4j-MDC是个好东西" class="headerlink" title="slf4j MDC是个好东西"></a>slf4j MDC是个好东西</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MDC 全拼 Mapped Diagnostic Contexts，是SLF4J类<strong>日志系统</strong>中实现分布式多线程日志数据<strong>传递</strong>的重要工具。</p><p>同时，用户也可利用MDC将一些运行时的上下文数据打印出来。</p><p><br></p><p><strong>什么意思呢？</strong></p><p>常规情况下，写打日志的代码时，一般都是log.info、log.warn、log.error将想要打的日志进行拼装和格式化，打到日志输出中。MDC能干什么呢？能在不改动log.xxx打日志代码的情况下，在最终的日志输出的指定位置打印额外的信息。而这，就是靠MDC进行传递实现的。</p><a id="more"></a><p><br></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>在日志中自动打印框架/组件方面的信息</p><p>例如：</p><ul><li>全链路日志traceId</li><li>用户请求的IP地址、user-agent</li></ul><p><br></p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><blockquote><p>一般配合AOP / Filter / Interceptor使用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(value = <span class="string">"execution(* com.xx.xx.facade.impl.*.*(..))"</span>, argNames=<span class="string">"pjp"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">validator</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String traceId = TraceUtils.begin();</span><br><span class="line">    MDC.put(<span class="string">"mdc_trace_id"</span>, traceId);    </span><br><span class="line">    Object obj = pjp.proceed(args);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(Throwable e) &#123;</span><br><span class="line">    <span class="comment">//TODO 处理错误</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    TraceUtils.endTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码通过AOP记录了每次请求的traceId，并使用变量”mdc_trace_id”记录到MDC内。</p><p>在日志配置文件里需要设置变量才能将”mdc_trace_id”输出到日志文件中。以logback配置文件为例，看日志第10行%X{mdc_trace_id}：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;appender name="ALL" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;</span><br><span class="line">      &lt;file&gt;$&#123;CATALINA_BASE&#125;/logs/all.log&lt;/file&gt;</span><br><span class="line">      &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;</span><br><span class="line">          &lt;!-- daily rollover --&gt;</span><br><span class="line">          &lt;fileNamePattern&gt;$&#123;CATALINA_BASE&#125;/logs/all.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">          &lt;!-- keep 30 days' worth of history --&gt;</span><br><span class="line">          &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">      &lt;/rollingPolicy&gt;</span><br><span class="line">      &lt;encoder charset="UTF-8"&gt;</span><br><span class="line">          &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - traceId:[%X&#123;mdc_trace_id&#125;] - %msg%n&lt;/pattern&gt;</span><br><span class="line">      &lt;/encoder&gt;</span><br><span class="line">  &lt;/appender&gt;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="可见的优势"><a href="#可见的优势" class="headerlink" title="可见的优势"></a>可见的优势</h1><p>1、如果你的系统早已上线，突然有一天老板说我们增加一些用户数据到日志里分析一下。如果没有MDC，你不得不在N个工程里翻天覆地的“传参数+改打日志的代码”，你肯定很崩溃，不懂技术的老板也很无奈（就多加几点信息，这么大动静吗？）。而MDC能让你很从容的完成此事。</p><ul><li>笔者团队就有这样的情况，但提出在日志里加内容的是我们自已的优化想法：将pinpoint的链路标识打到应用日志里去。</li></ul><p>2、使代码简洁、日志风格统一、变更灵活。</p><p><br></p><h1 id="对MDC源码的窥探"><a href="#对MDC源码的窥探" class="headerlink" title="对MDC源码的窥探"></a>对MDC源码的窥探</h1><h2 id="MDC所在的jar包"><a href="#MDC所在的jar包" class="headerlink" title="MDC所在的jar包"></a>MDC所在的jar包</h2><p><img src="/2020/12/19/slf4j MDC是个好东西/image-20201219195535690.png" alt="image-20201219195535690"></p><p>此处以 Logback中的实现为例。为了方便讲解，我们只分析MDC的put()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MDC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String val)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"key parameter cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mdcAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"MDCAdapter cannot be null. See also "</span></span><br><span class="line">          + NULL_MDCA_URL);</span><br><span class="line">    &#125;</span><br><span class="line">    mdcAdapter.put(key, val);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>MDC的put()方法利用MDCAdapter实现。</p><p><br></p><h2 id="Logback中的具体实现"><a href="#Logback中的具体实现" class="headerlink" title="Logback中的具体实现"></a>Logback中的具体实现</h2><blockquote><p>既然一般都是结合AOP使用MDC，那么还是要考虑内部方法实现时的支撑情况，例如：多线程</p></blockquote><p><br></p><p>下面看一下Logback中MDCAdapter的实现<strong>LogbackMDCAdapter</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogbackMDCAdapter</span> <span class="keyword">implements</span> <span class="title">MDCAdapter</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> InheritableThreadLocal&lt;Map&lt;String, String&gt;&gt; copyOnInheritThreadLocal = <span class="keyword">new</span> InheritableThreadLocal();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String val)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"key cannot be null"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Map&lt;String, String&gt; oldMap = (Map)<span class="keyword">this</span>.copyOnInheritThreadLocal.get();</span><br><span class="line">            Integer lastOp = <span class="keyword">this</span>.getAndSetLastOperation(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.wasLastOpReadOrNull(lastOp) &amp;&amp; oldMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldMap.put(key, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Map&lt;String, String&gt; newMap = <span class="keyword">this</span>.duplicateAndInsertNewMap(oldMap);</span><br><span class="line">                newMap.put(key, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MDC只有一种用法：<code>MDC.put(X,Y)</code>。那么，在MDC的具体实现包中，肯定会有个Map作为存储容器。如上，LogbackMDCAdapter中也有Map&lt;String, String&gt;。</li><li>MDC内的key-value要能在调用链路中都能打印，那么Map肯定是存储在ThreadLocal中传递。</li><li>Map&lt;String, String&gt;存储在InheritableThreadLocal中，即AOP内真正的业务方法内部若进行了子线程的创建，MDC内的key-value也能正常的打印到日志中。但，内部若是线程池的方式执行细分业务，则线程池任务内打印的日志则不会有此内容（线程池的ThreadLocal传递需要用TransmittableThreadLocal）。比较遗憾，logback没有预留这一点的SPI。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;slf4j-MDC是个好东西&quot;&gt;&lt;a href=&quot;#slf4j-MDC是个好东西&quot; class=&quot;headerlink&quot; title=&quot;slf4j MDC是个好东西&quot;&gt;&lt;/a&gt;slf4j MDC是个好东西&lt;/h1&gt;&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;MDC 全拼 Mapped Diagnostic Contexts，是SLF4J类&lt;strong&gt;日志系统&lt;/strong&gt;中实现分布式多线程日志数据&lt;strong&gt;传递&lt;/strong&gt;的重要工具。&lt;/p&gt;
&lt;p&gt;同时，用户也可利用MDC将一些运行时的上下文数据打印出来。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么意思呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常规情况下，写打日志的代码时，一般都是log.info、log.warn、log.error将想要打的日志进行拼装和格式化，打到日志输出中。MDC能干什么呢？能在不改动log.xxx打日志代码的情况下，在最终的日志输出的指定位置打印额外的信息。而这，就是靠MDC进行传递实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="日志框架" scheme="https://veryjj.github.io/tags/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/"/>
    
      <category term="slf4j" scheme="https://veryjj.github.io/tags/slf4j/"/>
    
  </entry>
  
  <entry>
    <title>Java 生成随机数的 5 种方式</title>
    <link href="https://veryjj.github.io/2020/12/16/Java%20%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%205%20%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://veryjj.github.io/2020/12/16/Java 生成随机数的 5 种方式/</id>
    <published>2020-12-16T07:11:39.000Z</published>
    <updated>2021-01-10T09:08:45.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h1><blockquote><p>试测数据：</p><ul><li>基于常见场景：在一个数据范围区间内生成随机数。</li><li>1000万的随机数范围，for循环生成50万个随机数。无其他额外操作。</li></ul></blockquote><table><thead><tr><th>SDK包</th><th>性能耗时</th><th style="text-align:left">评价</th></tr></thead><tbody><tr><td>java.util.Random</td><td>9毫秒</td><td style="text-align:left">1、编写简单，方法较多，也快速。很多SDK包都基于此扩展。<br>2、随机性重度依赖seed的情况，seed一样，分配的随机数和顺序一样。<br>3、线程不安全。</td></tr><tr><td>ThreadLocalRandom</td><td>8毫秒</td><td style="text-align:left">1、继承于java.util.Random<br>2、与线程绑定，一个线程一个，多线程下安全。<br>3、seed情况部分借助于线程的内存地址等随机信息，来提升随机性。</td></tr><tr><td>Math.Random</td><td>14毫秒</td><td style="text-align:left">1、用法上比较费劲，只能生成double。<br>2、内部有借用java.util.Random</td></tr><tr><td>SecureRandom</td><td>142毫秒</td><td style="text-align:left">线程安全，seed不可预测（借助于系统中的随机事件信息）</td></tr><tr><td>Apache#RandomDataGenerator</td><td>54毫秒</td><td style="text-align:left">API比较丰富，特殊场景下考虑。</td></tr><tr><td>it.unimi.dsi#XoRoShiRo128PlusRandom</td><td>17毫秒</td><td style="text-align:left">偏门的三方包。比较快。线程不安全。</td></tr></tbody></table><a id="more"></a><hr><h1 id="1-Math-random-静态方法"><a href="#1-Math-random-静态方法" class="headerlink" title="1. Math.random() 静态方法"></a>1. Math.random() 静态方法</h1><p>产生的随机数是 0 - 1 之间的一个 <code>double</code>，即 <code>0 &lt;= random &lt;= 1</code>。</p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  System.out.println(Math.random());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0.3598613895606426 </span><br><span class="line">0.2666778145365811 </span><br><span class="line">0.25090731064243355 </span><br><span class="line">0.011064998061666276 </span><br><span class="line">0.600686228175639 </span><br><span class="line">0.9084006027629496 </span><br><span class="line">0.12700524654847833 </span><br><span class="line">0.6084605849069343 </span><br><span class="line">0.7290804782514261 </span><br><span class="line">0.9923831908303121</span><br></pre></td></tr></table></figure></p><p>实现原理：</p><blockquote><p>When this method is first called, it creates a single new pseudorandom-number generator, exactly as if by the expression new java.util.Random() This new pseudorandom-number generator is used thereafter for all calls to this method and is used nowhere else.</p></blockquote><p>当第一次调用 Math.random() 方法时，自动创建了一个伪随机数生成器，<code>实际上用的是 new java.util.Random()</code>。当接下来继续调用 Math.random() 方法时，就会使用这个新的伪随机数生成器。</p><p>源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random rnd = randomNumberGenerator;</span><br><span class="line">    <span class="keyword">if</span> (rnd == <span class="keyword">null</span>) rnd = initRNG(); <span class="comment">// 第一次调用，创建一个伪随机数生成器</span></span><br><span class="line">    <span class="keyword">return</span> rnd.nextDouble();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Random <span class="title">initRNG</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random rnd = randomNumberGenerator;</span><br><span class="line">    <span class="keyword">return</span> (rnd == <span class="keyword">null</span>) ? (randomNumberGenerator = <span class="keyword">new</span> Random()) : rnd; <span class="comment">// 实际上用的是new java.util.Random()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>initRNG() 方法是 synchronized 的，因此在多线程情况下，只有一个线程会负责创建伪随机数生成器（使用当前时间作为种子），其他线程则利用该伪随机数生成器产生随机数。Java生成随机数的几种高级用法，这篇推荐看一下。</p><p>因此 <code>Math.random() 方法是线程安全的</code>。<br><br><br><strong>什么情况下随机数的生成线程不安全？</strong></p><ul><li>线程1在第一次调用 random() 时产生一个生成器 generator1，使用当前时间作为种子。</li><li>线程2在第一次调用 random() 时产生一个生成器 generator2，使用当前时间作为种子。</li><li>碰巧 generator1 和 generator2 使用相同的种子，导致 generator1 以后产生的随机数每次都和 generator2 以后产生的随机数相同。</li></ul><p><strong>什么情况下随机数的生成线程安全？</strong>： Math.random() 静态方法使用</p><ul><li>线程1在第一次调用 random() 时产生一个生成器 generator1，使用当前时间作为种子。</li><li>线程2在第一次调用 random() 时发现已经有一个生成器 generator1，则直接使用生成器 generator1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaRandom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + Math.random());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-1: 0.8043581595645333 </span><br><span class="line">Thread-0: 0.9338269554390357 </span><br><span class="line">Thread-1: 0.5571569413128877 </span><br><span class="line">Thread-0: 0.37484586843392464</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="2-java-util-Random-工具类"><a href="#2-java-util-Random-工具类" class="headerlink" title="2. java.util.Random 工具类"></a>2. java.util.Random 工具类</h1><blockquote><p>基本算法：linear congruential pseudorandom number generator (LGC) 线性同余法伪随机数生成器缺点：<code>可预测</code></p></blockquote><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(random.nextInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-24520987</span><br><span class="line">-96094681</span><br><span class="line">-952622427</span><br><span class="line">300260419</span><br><span class="line">1489256498</span><br></pre></td></tr></table></figure></p><p><strong>Random类默认使用<code>当前系统时钟作为种子</code></strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getClass() == Random.class)</span><br><span class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong(initialScramble(seed));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// subclass might have overriden setSeed</span></span><br><span class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">        setSeed(seed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Random类提供的方法：API</p><ul><li><code>nextBoolean()</code> - 返回均匀分布的 true 或者 false</li><li><code>nextBytes(byte[] bytes)</code></li><li><code>nextDouble()</code> - 返回 0.0 到 1.0 之间的均匀分布的 double</li><li><code>nextFloat()</code> - 返回 0.0 到 1.0 之间的均匀分布的 float</li><li><code>nextGaussian()</code> - 返回 0.0 到 1.0 之间的高斯分布（即正态分布）的 double</li><li><code>nextInt()</code> - 返回均匀分布的 int</li><li><code>nextInt(int n)</code> - 返回 0 到 n 之间的均匀分布的 int （包括 0，不包括 n）</li><li><code>nextLong()</code> - 返回均匀分布的 long</li><li><code>setSeed(long seed)</code> - 设置种子</li></ul><p><code>只要种子一样，产生的随机数也一样</code>： 因为种子确定，随机数算法也确定，因此输出是确定的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Random random1 = <span class="keyword">new</span> Random(<span class="number">10000</span>);</span><br><span class="line">Random random2 = <span class="keyword">new</span> Random(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(random1.nextInt() + <span class="string">" = "</span> + random2.nextInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-498702880 = -498702880</span><br><span class="line">-858606152 = -858606152</span><br><span class="line">1942818232 = 1942818232</span><br><span class="line">-1044940345 = -1044940345</span><br><span class="line">1588429001 = 1588429001</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="3-java-util-concurrent-ThreadLocalRandom-工具类"><a href="#3-java-util-concurrent-ThreadLocalRandom-工具类" class="headerlink" title="3. java.util.concurrent.ThreadLocalRandom 工具类"></a>3. java.util.concurrent.ThreadLocalRandom 工具类</h1><p><code>ThreadLocalRandom</code> 是 JDK 7 之后提供，也是继承至 java.util.Random。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalRandom&gt; localRandom =</span><br><span class="line">    <span class="keyword">new</span> ThreadLocal&lt;ThreadLocalRandom&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> ThreadLocalRandom <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalRandom();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>每一个线程有一个独立的随机数生成器</strong>，用于并发产生随机数，能够解决多个线程发生的竞争争夺。<strong>效率更高</strong>！</p><p>ThreadLocalRandom 不是直接用 new 实例化，而是第一次使用其静态方法 current() 得到 ThreadLocal<threadlocalrandom> 实例，然后调用 java.util.Random 类提供的方法获得各种随机数。</threadlocalrandom></p><p>使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaRandom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + ThreadLocalRandom.current().nextDouble());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-0: 0.13267085355389086</span><br><span class="line">Thread-1: 0.1138484950410098 </span><br><span class="line">Thread-0: 0.17187774671469858 </span><br><span class="line">Thread-1: 0.9305225910262372</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="4-java-Security-SecureRandom"><a href="#4-java-Security-SecureRandom" class="headerlink" title="4. java.Security.SecureRandom"></a>4. java.Security.SecureRandom</h1><p>也是继承至 java.util.Random。<br><br></p><blockquote><p>Instances of java.util.Random are not cryptographically secure. Consider instead using SecureRandom to get a cryptographically secure pseudo-random number generator for use by security-sensitive applications.SecureRandom takes Random Data from your os (they can be interval between keystrokes etc - most os collect these data store them in files - /dev/random and /dev/urandom in case of linux/solaris) and uses that as the seed. <code>操作系统收集了一些随机事件，比如鼠标点击，键盘点击等等，SecureRandom 使用这些随机事件作为种子。</code></p></blockquote><p>SecureRandom 提供加密的强随机数生成器 (RNG)，要求种子必须是不可预知的，产生非确定性输出。SecureRandom 也提供了与实现无关的算法，因此，调用方（应用程序代码）会请求特定的 RNG 算法并将它传回到该算法的 SecureRandom 对象中。</p><ul><li>如果仅指定算法名称，如下所示：SecureRandom random = SecureRandom.getInstance(“SHA1PRNG”);</li><li>如果既指定了算法名称又指定了包提供程序，如下所示：SecureRandom random = SecureRandom.getInstance(“SHA1PRNG”, “SUN”);</li></ul><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom random1 = SecureRandom.getInstance(<span class="string">"SHA1PRNG"</span>);</span><br><span class="line">SecureRandom random2 = SecureRandom.getInstance(<span class="string">"SHA1PRNG"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(random1.nextInt() + <span class="string">" != "</span> + random2.nextInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">704046703 != 2117229935 </span><br><span class="line">60819811 != 107252259 </span><br><span class="line">425075610 != -295395347 </span><br><span class="line">682299589 != -1637998900 </span><br><span class="line">-1147654329 != 1418666937</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="5-随机字符串"><a href="#5-随机字符串" class="headerlink" title="5. 随机字符串"></a>5. 随机字符串</h1><p>可以使用 Apache Commons-Lang 包中的 RandomStringUtils 类。Maven 依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>API 参考：<a href="https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/RandomStringUtils.html" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/RandomStringUtils.html</a></p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomStringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Creates a 64 chars length random string of number.</span></span><br><span class="line">        String result = RandomStringUtils.random(<span class="number">64</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">"random = "</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates a 64 chars length of random alphabetic string.</span></span><br><span class="line">        result = RandomStringUtils.randomAlphabetic(<span class="number">64</span>);</span><br><span class="line">        System.out.println(<span class="string">"random = "</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates a 32 chars length of random ascii string.</span></span><br><span class="line">        result = RandomStringUtils.randomAscii(<span class="number">32</span>);</span><br><span class="line">        System.out.println(<span class="string">"random = "</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates a 32 chars length of string from the defined array of</span></span><br><span class="line">        <span class="comment">// characters including numeric and alphabetic characters.</span></span><br><span class="line">        result = RandomStringUtils.random(<span class="number">32</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="string">"qw32rfHIJk9iQ8Ud7h0X"</span>.toCharArray());</span><br><span class="line">        System.out.println(<span class="string">"random = "</span> + result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RandomStringUtils 类的实现上也是依赖了 java.util.Random 工具类：<br><img src="https://img-blog.csdnimg.cn/20201216151043714.png" alt="在这里插入图片描述"></p><p>RandomStringUtils 类的定义</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;先说结论&quot;&gt;&lt;a href=&quot;#先说结论&quot; class=&quot;headerlink&quot; title=&quot;先说结论&quot;&gt;&lt;/a&gt;先说结论&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;试测数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于常见场景：在一个数据范围区间内生成随机数。&lt;/li&gt;
&lt;li&gt;1000万的随机数范围，for循环生成50万个随机数。无其他额外操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SDK包&lt;/th&gt;
&lt;th&gt;性能耗时&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;评价&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;java.util.Random&lt;/td&gt;
&lt;td&gt;9毫秒&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;1、编写简单，方法较多，也快速。很多SDK包都基于此扩展。&lt;br&gt;2、随机性重度依赖seed的情况，seed一样，分配的随机数和顺序一样。&lt;br&gt;3、线程不安全。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ThreadLocalRandom&lt;/td&gt;
&lt;td&gt;8毫秒&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;1、继承于java.util.Random&lt;br&gt;2、与线程绑定，一个线程一个，多线程下安全。&lt;br&gt;3、seed情况部分借助于线程的内存地址等随机信息，来提升随机性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.Random&lt;/td&gt;
&lt;td&gt;14毫秒&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;1、用法上比较费劲，只能生成double。&lt;br&gt;2、内部有借用java.util.Random&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SecureRandom&lt;/td&gt;
&lt;td&gt;142毫秒&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;线程安全，seed不可预测（借助于系统中的随机事件信息）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Apache#RandomDataGenerator&lt;/td&gt;
&lt;td&gt;54毫秒&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;API比较丰富，特殊场景下考虑。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;it.unimi.dsi#XoRoShiRo128PlusRandom&lt;/td&gt;
&lt;td&gt;17毫秒&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;偏门的三方包。比较快。线程不安全。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="随机数" scheme="https://veryjj.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>你不得不知的Spring事务失效 8 大原因</title>
    <link href="https://veryjj.github.io/2020/12/15/%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E7%9A%84Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%208%20%E5%A4%A7%E5%8E%9F%E5%9B%A0/"/>
    <id>https://veryjj.github.io/2020/12/15/你不得不知的Spring事务失效 8 大原因/</id>
    <published>2020-12-15T15:25:30.000Z</published>
    <updated>2021-01-10T09:11:53.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、数据库引擎不支持事务"><a href="#1、数据库引擎不支持事务" class="headerlink" title="1、数据库引擎不支持事务"></a>1、数据库引擎不支持事务</h4><p><br></p><p>这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB。<br><br><br>根据 MySQL 的官方文档：</p><blockquote><p><a href="https://dev.mysql.com/doc/refman/5.5/en/storage-engine-setting.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/storage-engine-setting.html</a></p></blockquote><p>从 MySQL 5.5.5 开始的默认存储引擎是：InnoDB，之前默认的都是：MyISAM，所以这点要值得注意，底层引擎不支持事务再怎么搞都是白搭。</p><a id="more"></a><p><br></p><h4 id="2、没有被-Spring-管理"><a href="#2、没有被-Spring-管理" class="headerlink" title="2、没有被 Spring 管理"></a>2、没有被 Spring 管理</h4><p><br></p><p>如下面例子所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update order</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果此时把 @Service 注解注释掉，这个类就不会被加载成一个 Bean，那这个类就不会被 Spring 管理了，事务自然就失效了。<br><br></p><h4 id="3、方法不是-public-的"><a href="#3、方法不是-public-的" class="headerlink" title="3、方法不是 public 的"></a>3、方法不是 public 的</h4><p><br></p><p>以下来自 Spring 官方文档：</p><blockquote><p>When using proxies, you should apply the @Transactional annotation only to methods with public visibility. If you do annotate protected, private or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. Consider the use of AspectJ (see below) if you need to annotate non-public methods.</p></blockquote><p>大概意思就是 @Transactional 只能用于 public 的方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启 AspectJ 代理模式。</p><p><br></p><h4 id="4、类内部自身调用问题"><a href="#4、类内部自身调用问题" class="headerlink" title="4、类内部自身调用问题"></a>4、类内部自身调用问题</h4><p><br></p><p>来看两个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        updateOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update order</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>update方法上面没有加 @Transactional 注解，调用有 @Transactional 注解的 updateOrder 方法，updateOrder 方法上的事务管用吗？<br><br><br>再来看下面这个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        updateOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update order</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这次在 update 方法上加了 @Transactional，updateOrder 加了 REQUIRES_NEW 新开启一个事务，那么新开的事务管用么？<br><br><br>这两个例子的答案是：不管用！<br><br><br>因为它们发生了自身调用，就调该类自己的方法，而没有经过 Spring 的代理类，默认只有在外部调用事务才会生效，这也是老生常谈的经典问题了。</p><p>这个的解决方案之一就是在的类中注入自己，用注入的对象再调用另外一个方法，这个不太优雅</p><p>另外一个可行的方案如下：<br>举个简单的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    向数据库中添加数据;</span><br><span class="line">    </span><br><span class="line">    调用其他系统;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就用伪代码来做示例了，当我们执行了“向数据库中添加数据”，我们去数据库中查询，发现并没有我们添加的数据，但是当我们的service这个方法执行完成之后，数据库中就有这条数据了，这是由于数据库的隔离性造成的。<br><br><br>我们将代码修改一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ServiceB serviceB;</span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    serviceB.insert();</span><br><span class="line">    </span><br><span class="line">    调用其他系统;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    向数据库中添加数据;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们将要事务分离出来的方法写在另一个service中，再次测试，发现执行完插入语句之后，数据库中就已经能查到数据了，说明事务分离了，完成了我们的需求。</p><p>当然 Spring 其实也考虑这个，在 Spring 的配置中，我们只需要添加标签：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">expose-proxy</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">expose-proxy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>并且在代码的调用中要求使用代理对象去调用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ServiceA ) AopContext.currentProxy()).insert();</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5、数据源没有配置事务管理器"><a href="#5、数据源没有配置事务管理器" class="headerlink" title="5、数据源没有配置事务管理器"></a>5、数据源没有配置事务管理器</h4><p><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面所示，当前数据源若没有配置事务管理器，那也是白搭！</p><p><br></p><h4 id="6、不支持事务"><a href="#6、不支持事务" class="headerlink" title="6、不支持事务"></a>6、不支持事务</h4><p><br></p><p>来看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        updateOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update order</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Propagation.NOT_SUPPORTED： 表示不以事务运行，当前若存在事务则挂起，详细的可以参考《事务隔离级别和传播机制》这篇文章。</p><p>都主动不支持以事务方式运行了，那事务生效也是白搭！</p><p><br></p><h4 id="7、异常被吃了"><a href="#7、异常被吃了" class="headerlink" title="7、异常被吃了"></a>7、异常被吃了</h4><p><br></p><p>这个也是出现比较多的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// update order</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把异常吃了，然后又不抛出来，事务怎么回滚吧！</p><p><br></p><h4 id="8、异常类型错误"><a href="#8、异常类型错误" class="headerlink" title="8、异常类型错误"></a>8、异常类型错误</h4><p><br></p><p>上面的例子再抛出一个异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// update order</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"更新错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样事务也是不生效的，因为默认回滚的是：RuntimeException和error<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rollbackOn</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ex <span class="keyword">instanceof</span> RuntimeException || ex <span class="keyword">instanceof</span> Error);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如果你想触发其他异常的回滚，需要在注解上配置一下，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br></pre></td></tr></table></figure><p>这个配置仅限于 Throwable 异常类及其子类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、数据库引擎不支持事务&quot;&gt;&lt;a href=&quot;#1、数据库引擎不支持事务&quot; class=&quot;headerlink&quot; title=&quot;1、数据库引擎不支持事务&quot;&gt;&lt;/a&gt;1、数据库引擎不支持事务&lt;/h4&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB。&lt;br&gt;&lt;br&gt;&lt;br&gt;根据 MySQL 的官方文档：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.5/en/storage-engine-setting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/refman/5.5/en/storage-engine-setting.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从 MySQL 5.5.5 开始的默认存储引擎是：InnoDB，之前默认的都是：MyISAM，所以这点要值得注意，底层引擎不支持事务再怎么搞都是白搭。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://veryjj.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://veryjj.github.io/tags/Spring/"/>
    
      <category term="事务" scheme="https://veryjj.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统 之 分布式事务问题</title>
    <link href="https://veryjj.github.io/2020/11/29/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%80%8E%E4%B9%88%E6%80%9D%E8%80%83%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/"/>
    <id>https://veryjj.github.io/2020/11/29/分布式系统怎么思考分布式事务问题/</id>
    <published>2020-11-29T10:29:42.000Z</published>
    <updated>2021-01-10T09:20:55.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式系统-之-分布式事务问题"><a href="#分布式系统-之-分布式事务问题" class="headerlink" title="分布式系统 之 分布式事务问题"></a>分布式系统 之 分布式事务问题</h1><p><br></p><h1 id="1、你怎么分享分布式事务？"><a href="#1、你怎么分享分布式事务？" class="headerlink" title="1、你怎么分享分布式事务？"></a>1、你怎么分享分布式事务？</h1><p><br></p><p>分布式事务问题是分布式系统绕不开的技术话题。</p><p>“谈谈你对分布式事务的理解”、“分享下你团队在分布式事务上的解决方案”、“你用过哪几种分布式事务的中间件”？在技术交流/面试中很容易讨论到这些个话题，得到的反馈大概率是这样的：</p><ul><li>“额~~ ~~ ~~ ~~”，一时语噻 《《《 平时没有梳理和认知分布式事物的问题，一时不知如何组织语言。</li><li>“我们没有使用分布式事务”《《《 分布式事务裸奔状态。</li><li>“我知道有CAP和BASE理论，分别是XXX意思” 《《《 “学院派”选手，不够接地气。</li><li>“我们没用分布式事务，但有做补偿方案，XXX” 《《《 有意识和思考，可以。</li><li>“我们在个别特殊业务上，用了XXX中间件方案” 《《《 有数据、有实践心得，可以。</li><li>etc……</li></ul><a id="more"></a><p><br></p><p><strong>的确，分布式事务问题比中间件技术问题难回答的多，因为：</strong></p><p><strong>1、它是一个解决方案。而不仅仅是某个功能的技术实现解答。</strong></p><p><strong>2、分布式事务是一项“有损解决方案”，是一项取舍决策，背后是业务适用性。</strong></p><p><strong>3、解决方案要基于业务场景，以及业务场景分析。不存在一招鲜吃遍天的最佳方案。</strong></p><p><strong>3、分布式事务是个综合的技术问题，涉及：业务代码、RPC、幂等性、DB、并发处理、局部高可用、网络分区、一致性视图等问题。</strong></p><p><br></p><p>据笔者交流反馈的经验，在多数团队中并未落地“像样”的分布式方案。分布式事务在线上系统的应用比例是很小的。相比分布式事务的学习复杂度和实际应用概率，真有点“面试造火箭，实际拧螺丝”的感觉。</p><p>但，不论线上应用比例怎样。作为对技术深度的好奇和掌握（尤其是一堆技术的协同的原理掌握），我们仍要扎实的掌握分布式事务。做到知一返三、游刃有余。</p><p><br></p><h1 id="2、分布式事务的本质"><a href="#2、分布式事务的本质" class="headerlink" title="2、分布式事务的本质"></a>2、分布式事务的本质</h1><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/分布式事务问题.png" alt=""></p><center>分布式事务问题</center><p>如上图：</p><ul><li>分布式事务的问题/需求是随着系统分布式化后必然产生的。</li></ul><p><br></p><ul><li><p>分布式事务的目的或<strong>本质是追求分布式的多个DB数据的一致性</strong>。</p><ul><li><p>和本地数据库事务的本质原理是一样的。只不过是放大到一套技术栈中去实现，更多考虑因素和复杂度。</p></li><li><p>（以Mysql为例）<strong>本地数据库事务原理</strong>：undo log（原子性） + redo log（持久性） + 数据库锁（原子性&amp;隔离性） + MVCC（隔离性）</p></li><li><p><strong>分布式事务原理</strong>：全局事务协调器（原子性） + 全局锁（隔离性） + DB本地事务（原子性、持久性）</p></li><li><blockquote><p>注，“一致性” 靠 “原子性 + 持久性 + 隔离性” 三者共同完成</p></blockquote></li></ul></li></ul><p><br></p><ul><li>分布式多个DB数据变更的一致性不是瞬间一致，而是会经历一个过程。<ul><li>需要考虑期间DB数据可见性和隔离性问题。</li></ul></li></ul><p><br></p><p>问题：</p><p>1、分布式系统中，日常研发线上发版，需要考虑分布式事务问题吗？如果要考虑，怎么应对？</p><p>2、分布式事务相关的技术问题：RPC、幂等性、DB、并发处理、局部高可用、网络分区、一致性视图等，胸有成竹吗？</p><p><br></p><h1 id="3、CAP原则和BASE理论"><a href="#3、CAP原则和BASE理论" class="headerlink" title="3、CAP原则和BASE理论"></a>3、CAP原则和BASE理论</h1><blockquote><p>下文并不会基于这两理论分解，毕竟是理论，不能解决实际的问题</p><p>但理论知识还是需要了解一些的。故，快速浏览下。</p></blockquote><p><br></p><h2 id="3-1、CAP原则"><a href="#3-1、CAP原则" class="headerlink" title="3.1、CAP原则"></a>3.1、CAP原则</h2><p><strong>CAP原则：</strong></p><p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）中的两项。</p><p><br></p><ul><li><p><strong>一致性（Consistency）</strong>：一致性指“all nodes see the same data at the same time”，即<strong>更新操作</strong>成功并返回客户端<strong>完成后</strong>，所有节点在同一时间的数据完全一致。</p></li><li><p><strong>可用性（Availability）</strong>：可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。</p></li><li><p><strong>分区容错性（Partition tolerance）</strong>：分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p></li></ul><p><br></p><p><strong>CAP的取舍策略：</strong></p><table><thead><tr><th style="text-align:center">策略</th><th>解释</th></tr></thead><tbody><tr><td style="text-align:center">CA</td><td>单点集群，满足一致性，可用性的系统，通常可扩展性较差。例如传统的单机数据库。<br>特点：故障时完全不可用。</td></tr><tr><td style="text-align:center">【常选】AP</td><td>满足可用性，分区容错的系统，对一致性要求低一些，是很多分布式系统设计时的选择。<br>       例如：Redis，HBase，Eureka。<br>       例如：各云厂商的SLA几个9，也是牺牲了强一致性。</td></tr><tr><td style="text-align:center">CP</td><td>满足一致性，分区容错的系统，通常性能不是特别高<br>        例如：Zookeeper（通过ZAB协议达到强一致性）</td></tr></tbody></table><p><br></p><h2 id="3-2、BASE理论"><a href="#3-2、BASE理论" class="headerlink" title="3.2、BASE理论"></a>3.2、BASE理论</h2><p>BASE理论是对CAP理论的延伸，<strong>对AP的细化</strong>。</p><p>核心思想是“即使无法做到强一致性，但应可以采用适合的方式达到最终一致性”。</p><p><strong>BASE</strong>是指：基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。</p><p> <br></p><ul><li><p><strong>基本可用（Basically Available）</strong></p><ul><li>基本可用是指分布式系统在出现故障时，为保证核心可用，允许损失部分可用性。</li><li>例如：电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。</li></ul></li><li><p><strong>软状态（ Soft State）</strong></p><ul><li>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。</li><li>例如：分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</li></ul></li><li><p><strong>最终一致性（ Eventual Consistency）</strong></p><ul><li>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</li><li>最终一致性是弱一致性的一种特殊情况。</li></ul></li></ul><p><br></p><h2 id="3-3、为什么分布式系统倾向BASE理论的架构"><a href="#3-3、为什么分布式系统倾向BASE理论的架构" class="headerlink" title="3.3、为什么分布式系统倾向BASE理论的架构"></a><strong>3.3、为什么分布式系统倾向BASE理论的架构</strong></h2><p>实际性问题：</p><ul><li>工程师可以做到逻辑严密的代码，但无法确保硬件长期100%可用。</li><li>在大型分布式系统中，通信异常、网络分区、节点故障、磁盘损坏、机房掉电等等硬件问题随时都可能发生。</li></ul><p><br></p><p>在商业中，越是大型的公司越是需要在线服务能力强的大型分布式系统，在线可用性和响应能力是大型公司的生命支柱（很多线上一次大故障毁掉一个公司的案例）【基本已排除CA和CP】。</p><p>且，数据最终一致的特点留给架构很多发挥的余地。即使是关键异常，也可以通过补偿的方式或人工的方式处理。</p><p><br></p><h1 id="4、技术方案汇总"><a href="#4、技术方案汇总" class="headerlink" title="4、技术方案汇总"></a>4、技术方案汇总</h1><h2 id="4-1、按方案本质分类"><a href="#4-1、按方案本质分类" class="headerlink" title="4.1、按方案本质分类"></a>4.1、按方案本质分类</h2><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/image-20201122212334563.png" alt="image-20201122212334563"></p><blockquote><ul><li>阿里Seata：<a href="http://seata.io/zh-cn/" target="_blank" rel="noopener">http://seata.io/zh-cn/</a></li><li>Hmily：<a href="https://github.com/dromara/hmily" target="_blank" rel="noopener">https://github.com/dromara/hmily</a></li></ul></blockquote><p><br></p><h2 id="4-2、怎么选"><a href="#4-2、怎么选" class="headerlink" title="4.2、怎么选"></a>4.2、怎么选</h2><blockquote><p>仅提供数据参考</p></blockquote><p><strong>一、一般业务都倾向选最终一致性</strong></p><ul><li><p>绝大部分使用“自研补偿/MQ方案 + 人工介入”。</p><ul><li><p>选型取向：</p><ul><li>方案最“轻”，可掌控性好。</li><li>方案简单易懂，团队易接受、易维护。</li><li>性能损失最少。</li></ul></li><li><blockquote><p>笔者也赞同一般团队选型此方式。毕竟分布式事务问题是小概率事件，留有补救余地就行，性能的损失可是实打实的反应在线上每一个请求上。</p></blockquote></li></ul></li></ul><p><br></p><p><strong>二、阿里Seata AT模式，平均性能会降低35%以上</strong></p><ul><li>笔者团队的业务实测</li><li>大家可以根据Seata AT模式下额外做的事情来感受</li></ul><p><br></p><p><strong>三、RocketMQ事务消息</strong></p><ul><li>听起来挺好挺简单的方案，但它比较挑业务场景，同步性强的处理链路不适合。</li><li>【重要】要求下游MQ消费方一定能成功消费消息。否则转人工介入处理。</li><li>【重要】千万记得实现幂等性。</li><li>RocketMQ 3.0.8版本前，或RocketMQ 4.3.0后 支持事务消息，中间版本事务消息被干掉过。</li></ul><p><br></p><h1 id="5、技术方案介绍"><a href="#5、技术方案介绍" class="headerlink" title="5、技术方案介绍"></a>5、技术方案介绍</h1><h2 id="5-1、【原理】2PC-（理论基石）"><a href="#5-1、【原理】2PC-（理论基石）" class="headerlink" title="5.1、【原理】2PC  （理论基石）"></a>5.1、【原理】2PC  （理论基石）</h2><p>两阶段提交（Two-phase Commit，2PC）</p><p><br></p><p><strong>5.1.1、运行原理</strong></p><p>2PC通过引入协调者（Coordinator）来协调分布式事务参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><p>2PC 把事务的执行分为两个阶段：</p><ul><li>第一阶段 prepare 阶段：这个阶段实际上就是参与者对事务的投票阶段，协调者向所有参与者确认是否可以共同提交？</li><li>第二阶段 commit阶段：只有第一阶段所有参与者都回答yes，协调者才会向所有参与者发起commit指令共同提交事务。否则向所有参与者发送abort指令共同中止事务。用以保证事务达到一致性。</li></ul><p><br><br>【特别强调】2PC是方案原理，不是落地型方案。2PC几乎是所有分布式事务方案的基础，各分布式事务方案几乎都由此改进而来。</p><p><br></p><p><strong>一阶段：准备阶段</strong></p><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/image-20201122222103051.png" alt="image-20201122222103051"></p><center>一阶段：准备阶段</center><ul><li>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</li></ul><p><br></p><p><strong>二阶段：提交阶段</strong></p><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/image-20201122222041382.png" alt="image-20201122222041382"></p><center>二阶段：提交阶段</center><ul><li><p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p></li><li><p><em>【注意】</em>需要注意的是，在准备阶段，参与者在DB层<strong>只执行了事务，未提交事务</strong>。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p></li></ul><p><br></p><p><strong>5.1.2、方案背后的隐性要求</strong></p><p>1、需要实现一个全局协调器。引发考虑全局协调器自身的可用性问题。</p><p>2、应用需配合协调者要求，实现多个接口。</p><p>3、需要将DB层面的事务commit分离（需要DB支持）。拖长的一致性过程，对并发情况采取的应对策略（一般往往是同步阻塞）。</p><p>4、假设阶段二的commit/rollback肯定执行成功，故二阶段的实现不能复杂。且，一旦出错就人工介入。</p><p><br></p><p><strong>5.1.3、存在的问题</strong></p><p>1、同步阻塞：所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，阻塞级别（应用级、表级、数据行级）视实现方案。</p><p>2、单点问题：协调者发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</p><p>3、<em>数据不一致</em>：在阶段二，如果协调者只发送了部分 Commit 消息，<strong>此时网络发生异常</strong>，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。抑或协调者发送的commit消息到达参会与者的速度不一样，抑或参与者处理commit消息的调度及时性不一样，都会出现全局数据不一致的一个时间窗口。</p><p>4、太过保守： 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p><p><br></p><h2 id="5-2、【原理】TCC-（补偿型）"><a href="#5-2、【原理】TCC-（补偿型）" class="headerlink" title="5.2、【原理】TCC  （补偿型）"></a>5.2、【原理】TCC  （补偿型）</h2><p>TCC 本质上也是一个2PC型原理，但其属于“补偿型” “柔性事务”方案。是最常用的分布式事务的思路。</p><p><br></p><p>理解TCC，重要的是去理解“补偿型”方案的思路。基于“补偿型”思路在实际业务场景中灵活应变。</p><p><br></p><p>故，要往补偿型方案上去理解，勿死记硬背！</p><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/image-20201129164558089.png" alt="image-20201129164558089"></p><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/image-20201129114815853.png" alt="image-20201129114815853"></p><p><br></p><p><strong>【敲黑板】TCC特点：</strong></p><ul><li>TCC是属于BASE理论的柔性事务。是最终一致性的做法。</li><li>（相较于资源层DB）TCC工作于业务逻辑层，属业务逻辑层的2PC。实现：Try、Confirm、Cancel三个方法（Cancel是取消Try）。</li><li>TCC每一个接口在返回时都是直接提交本地事务的。故，TCC是牺牲了一定的隔离性和全局一致性。</li><li>TCC也有事务管理器（Coordinator 事务协调者）。事务管理器要记录分布式事务活动日志，用于事务管理器重启后的恢复。</li><li>标准的TCC，数据设计上需要支持中间态（配合try + confirm）。变种的TCC，也可以一步到位。</li></ul><p><br></p><p><strong>TCC的状态推进逻辑：</strong></p><p>1、Try阶段：如果有1个Try失败。则发起全局Cancel。</p><p>2、Confirm阶段：假设必须成功。若有个别应用Confirm失败，则由事务管理器进行重试。若重试无效，则人工介入。</p><p>3、Cancel阶段：也是假设必须成功。Cancel失败的基本都转人工。</p><p><br></p><p><strong>TCC实现注意点：</strong></p><p>1、<strong>实现幂等</strong>：因为网络调用无法保证请求一定能到达，所以都会有重调机制，因此对于 Try、Confirm、Cancel 三个方法都需要幂等实现，避免重复执行产生错误。</p><p>2、<strong>空回滚问题</strong>：指由于网络问题，Try 方法没收到，超时了。此时事务管理器就会发出 Cancel 命令，那么需要支持 Cancel 在未执行 Try 的情况下能正常的 Cancel。</p><p>3、<strong>考虑单应用多实例架构</strong>：在单应用多实例的架构下，TCC的协调者需要保证一个事务的Try、Confirm、Cancel操作在同一个实例上。</p><ul><li><strong>应对方案一</strong>、单应用多实例间，针对业务数据做分布式锁。</li><li><strong>应对方案二</strong>、<strong>放任其并发</strong>。前提是单应用级多实例架构自身能保证业务的负载均衡后的并发原子性，例如：请求负载均衡到多台机器实例进行库存操作，常见方案有：分布式锁、DB乐观锁等。因为TCC的Try会检查并锁定资源，如果遇到冲突，那么检测到冲突，Try失败的分布式事务者进行Cancel回滚。</li></ul><p>4、<strong>防悬挂</strong>：（尤其是异步方式的TCC）是指 Try 方法由于网络阻塞，超时触发了事务管理器发出了 Cancel 命令， 但是执行了 Cancel 命令之后 Try 请求到了。</p><p><br></p><p><strong>TCC应用的难度不在于实现三个方法</strong>，<u>在于结合具体TCC工具选型和技术架构下的逻辑严密性</u>，常思考几个问题：</p><ul><li>这个请求失败了怎么办？</li><li>方案执行TimeOut了怎么办？</li><li>任何时候，网络抖动了怎么办？</li><li>网络异常分区了，会造成什么问题？</li><li>TCC的事务管理器异常了怎么办？</li><li>执行TCC的应用程序异常了怎么办？</li><li>如何优雅的事务平滑的更新线上版本？</li><li>……等等</li></ul><p><br></p><blockquote><p>国内开源的<strong>ByteTCC、hmily、tcc-transaction</strong></p></blockquote><p><br></p><p><strong><em>TCC的缺点：</em></strong></p><ul><li>在业务层面，完全手写回滚逻辑或者是补偿逻辑，实在太恶心了。且，这块业务代码很难维护，很容易纰漏。</li></ul><p><br></p><p><strong>因地制宜，这些也是TCC思路：</strong></p><ul><li><strong>一、没有Try的TCC</strong></li></ul><p>例如，购买联程机票，换乘的又是不同的航空公司。比如从 A 飞到 B，再从 B 飞到 C，只有 A - B 和 B - C 都买到票了才有意义。</p><p>但有可能受限于各航空公司未必都实现TCC的接口，故为了方案的通用性，会做方案降级应对。这时候的选择就不 Try 了，直接调用航空公司的买票操作，当两个航空公司都买成功了那就直接成功了，如果某个公司买失败了，那就需要调用取消订票接口。</p><p>也就是在第一阶段直接就执行完整个业务操作了，所以要重点关注回滚操作，如果回滚失败得有提醒，需要人工介入等。</p><blockquote><p>类SAGA的方案哦</p></blockquote><p><br></p><ul><li><p><strong>二、异步方式的TCC</strong></p><p>TCC 异步其实也是一种折衷。</p></li></ul><p>比如某些服务很难改造，但又<strong>不会影响主业务决策</strong>，也就是它不那么需要即时执行。这时候可以引入可靠消息服务，通过消息服务来替代个别服务来进行 Try、Confirm、Cancel 。</p><p>Try 的时候只是写入消息，消息还不能被消费，Confirm 就是真正发消息的操作，Cancel 就是取消消息的发送。</p><p>是不是有点耳熟？对！就是RocketMQ。</p><blockquote><p>事务消息的方案哦</p></blockquote><p><br></p><h2 id="5-3、【原理】-XA-（取决于数据库）"><a href="#5-3、【原理】-XA-（取决于数据库）" class="headerlink" title="5.3、【原理】 XA （取决于数据库）"></a>5.3、【原理】 XA （取决于数据库）</h2><p>XA规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准。</p><p>XA 规范 描述了全局的事务管理器与局部的资源管理器之间的接口。 XA规范 的目的是允许的多个资源（如数据库，应用服务器，消息队列等）在同一事务中访问，这样可以使 ACID 属性跨越应用程序而保持有效。</p><p><br></p><p>XA中大致分为两部分：事务管理器和本地资源管理器。</p><ul><li>本地资源管理器：往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口。</li><li>事务管理器：作为全局的调度者，负责各个本地资源的提交和回滚。</li></ul><p>XA 规范 使用两阶段提交（2PC，Two-Phase Commit）来保证所有资源同时提交或回滚任何特定的事务</p><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/image-20201129164639724.png" alt="image-20201129164639724"></p><p><br></p><p>XA实现分布式事务的原理如下：</p><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/image-20201129135226697.png" alt="image-20201129135226697"></p><p><br></p><blockquote><p>看，背后还是2PC的原理。</p></blockquote><p><br></p><p>总的来说，XA协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。</p><p>但是，<em>XA也有致命的缺点，那就是性能不理想</em>，特别是在交易下单链路，并发量高，<em>XA无法满足高并发场景</em>。</p><p><br></p><p>XA目前在商业数据库支持的比较理想，在mysql数据库中支持的不太理想，mysql的XA实现，没有记录prepare阶段日志，主备切换回导致主库与备库数据不一致。</p><p><br></p><p>至于实战经验/代码demo，笔者也没使用过。此章节略带“键盘侠”的感觉。</p><p>带XA能力的框架：Seata。</p><p><br></p><h2 id="5-4、【框架】Seata-（多种模式可选）"><a href="#5-4、【框架】Seata-（多种模式可选）" class="headerlink" title="5.4、【框架】Seata  （多种模式可选）"></a>5.4、【框架】Seata  （多种模式可选）</h2><p><a href="http://seata.io/zh-cn/index.html" target="_blank" rel="noopener">http://seata.io/zh-cn/index.html</a></p><p><br></p><h3 id="5-4-1、XA模式-（阻塞大，性能低）"><a href="#5-4-1、XA模式-（阻塞大，性能低）" class="headerlink" title="5.4.1、XA模式   （阻塞大，性能低）"></a>5.4.1、XA模式   （阻塞大，性能低）</h3><p><strong>前提：</strong></p><ul><li><u>支持XA 事务的数据库</u>。（Mysql就不行罗）</li><li>Java 应用，通过 JDBC 访问数据库。</li></ul><p><br></p><p><strong>整体机制：</strong></p><p>在 Seata 定义的分布式事务框架内，利用事务资源（数据库、消息服务等）对 XA 协议的支持，以 XA 协议的机制来管理分支事务的一种 事务模式。</p><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/TB1hSpccIVl614jSZKPXXaGjpXa-1330-924.png" alt="img"></p><ul><li>一、执行阶段：<ul><li>可回滚：业务 SQL 操作放在 XA 分支中进行，由数据库对 XA 协议的支持来保证 <em>可回滚</em></li><li>持久化：XA 分支完成后，执行 XA prepare，同样，由数据库对 XA 协议的支持来保证 <em>持久化</em>（即，之后任何意外都不会造成无法回滚的情况）</li></ul></li><li>二、完成阶段：<ul><li>分支提交：执行 XA 分支的 commit</li><li>分支回滚：执行 XA 分支的 rollback</li></ul></li></ul><p><br></p><p><strong>工作机制：</strong></p><ol><li>整体运行机制</li></ol><p>XA 模式 运行在 Seata 定义的事务框架内：</p><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/TB1uM2OaSslXu8jSZFuXXXg7FXa-1330-958.png" alt="xa-fw"></p><ul><li>执行阶段（E xecute）：XA start/XA end/XA prepare + SQL + 注册分支</li><li>完成阶段（F inish）：XA commit/XA rollback</li></ul><p><br></p><ol><li>数据源代理</li></ol><p>XA 模式需要 XA Connection。</p><p>获取 XA Connection 两种方式：</p><ul><li>方式一：要求开发者配置 XADataSource</li><li>方式二：根据开发者的普通 DataSource 来创建</li></ul><p>第一种方式，给开发者增加了认知负担，需要为 XA 模式专门去学习和使用 XA 数据源，与 透明化 XA 编程模型的设计目标相违背。</p><p>第二种方式，对开发者比较友好，和 AT 模式使用一样，开发者完全不必关心 XA 层面的任何问题，保持本地编程模型即可。</p><p><br></p><p>虽然第二种方式对使用者更友好，但仍优先推荐第一种自实现的方式：</p><p>为什么？</p><p>关于第二种方式，其实是Seata来开发XA Connection，这种方法是在做数据库驱动程序要做的事情。不同的厂商、不同版本的数据库驱动实现机制是厂商私有的，Seata只保证在充分测试过的驱动程序上是正确的（无法针对使用者各色各样的驱动版本给出通用版本），开发者使用的<strong>驱动程序版本差异</strong>很可能造成机制的失效。这点在 Oracle 上体现非常明显。参见 Druid issue：<a href="https://github.com/alibaba/druid/issues/3707" target="_blank" rel="noopener">https://github.com/alibaba/druid/issues/3707</a>  。</p><p><br></p><ol><li>分支注册</li></ol><p>XA start 需要 Xid 参数。</p><p>这个 Xid 需要和 Seata 全局事务的 XID 和 BranchId 关联起来，以便由 TC 驱动 XA 分支的提交或回滚。</p><p>目前 Seata 的 BranchId 是在分支注册过程，由 TC 统一生成的，所以 <strong>XA 模式分支注册的时机需要在 XA start 之前</strong>。</p><p><br></p><p><strong>XA 模式的使用</strong></p><p>可以参考 Seata 官网的样例：<a href="https://github.com/seata/seata-samples/tree/master/seata-xa" target="_blank" rel="noopener">https://github.com/seata/seata-samples/tree/master/seata-xa</a></p><p>样例场景是 Seata 经典的，涉及库存、订单、账户 3 个微服务的商品订购业务。</p><p><br></p><h3 id="5-4-2、AT模式-（折中的优选）"><a href="#5-4-2、AT模式-（折中的优选）" class="headerlink" title="5.4.2、AT模式 （折中的优选）"></a>5.4.2、AT模式 （折中的优选）</h3><p>复习下Seata XA模式下的不足：</p><ol><li>需要数据库支持XA协议。Mysql没戏。</li><li>阻塞大，性能低。</li></ol><p><br></p><p>然后，Seata AT模式就是Seata XA模式的演化版本，优化了Seata XA模式下的2个不足。更灵活、性能有所提升（不绝对，建议实测比较）。</p><p><br></p><p><strong>前提：</strong></p><ul><li>基于支持本地 ACID 事务的关系型数据库。</li><li>Java 应用，通过 JDBC 访问数据库。</li></ul><p><br></p><p><strong>整体改进原理：</strong></p><p>1、【自动代理，插入逻辑】【低入侵】自动代理应用层的数据源，拦截并插入Seata的操作和逻辑。</p><p>2、【应用层XA Prepare】【灵活】在应用层实现 XA Prepare部分，大大提升适用面和灵活性。实际实现上，通过对数据源做代理，以此拦截应用的事务SQL，进而反向解析出undo sql log（供于rollback）。</p><p>3、【行级-全局锁】【隔离性&amp;性能】在全局TC上实现行级全局锁。全局事务在执行期间，需要先拿到全局锁，才能处理临界区逻辑。以此达到全局的读写隔离。</p><blockquote><p>代码层面参照Seata-Sample，最大特点是在事务入口打上@GlobalTransactional的代理注解，让Seata能干预SQL的执行。</p></blockquote><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NzIxMjg3,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p><br></p><p>基本概念：</p><ul><li><strong>TC（Transaction Coordinator） -  事务协调者</strong>：维护全局事务和分支事务的状态，驱动全局事务提交或回滚。</li><li><strong>TM（Transaction Manager）      - 事务管理器</strong>：定义全局事务的范围</li><li><strong>RM（Resource Manager）         - 资源管理器</strong> ：管理分支事务处理的资源，与TC通信注册/报告分支事务状态，并驱动分支事务的提交或回滚。</li></ul><p>两阶段提交：</p><ul><li>一阶段：业务数据和<u>回滚日志记录</u>在同一个本地<strong>事务中提交</strong>，释放本地锁和连接资源。</li><li>二阶段：提交异步化，非常快速地完成   或   回滚通过一阶段的回滚日志进行反向补偿。</li></ul><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NzIxMjg3,size_16,color_FFFFFF,t_70-20201129162643039.png" alt="img"></p><p><br></p><p><strong>写隔离：</strong></p><ul><li>一阶段本地事务提交前，需要确保先拿到 <strong>全局锁（数据行级）</strong> 。而全局锁的实现，在TC端。带来的优点：全局解锁就在一瞬间。</li><li>拿不到 <strong>全局锁</strong> ，不能提交本地事务。</li><li>拿 <strong>全局锁</strong> 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。</li></ul><p><br></p><p>示例：</p><p>两个全局事务 tx1 和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。</p><ul><li><p>tx1 先开始，开启本地事务，拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，<u>先拿到该记录的 <strong>全局锁</strong></u> ，本地提交释放本地锁。 </p></li><li><p>tx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，<em>尝试拿该记录的 <strong>全局锁</strong></em> ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要<em>重试等待</em> <strong>全局锁</strong> 。</p></li></ul><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/seata_at-1.png" alt="Write-Isolation: Commit"></p><ul><li>tx1 二阶段全局提交，释放 <strong>全局锁</strong> 。tx2 拿到 <strong>全局锁</strong> 提交本地事务。</li></ul><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/seata_at-2.png" alt="Write-Isolation: Rollback"></p><p>如果回滚：</p><p>如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。</p><p>此时，如果 tx2 仍在等待该数据的 <strong>全局锁</strong>，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 <strong>全局锁</strong> 等锁超时，放弃 <strong>全局锁</strong> 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。</p><p><br></p><p>因为整个过程 <strong>全局锁</strong> 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 <strong>脏写</strong> 的问题。</p><p><br></p><p><strong>读隔离：</strong></p><p>在数据库本地事务隔离级别 <strong>读已提交（Read Committed）</strong> 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 <strong>读未提交（Read Uncommitted）</strong> 。</p><p>如果应用在特定场景下，必需要求全局的 <strong>读已提交</strong> ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。</p><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/seata_at-3.png" alt="Read Isolation: SELECT FOR UPDATE"></p><p><em>SELECT FOR UPDATE 语句的执行会申请 <strong>全局锁</strong>（并发阻塞的代价点）</em> ，如果 <strong>全局锁</strong> 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 <strong>全局锁</strong> 拿到，即读取的相关数据是 <strong>已提交</strong> 的，才返回。</p><p><br></p><p>出于总体性能上的考虑，Seata 目前的方案并<u>没有对所有 SELECT 语句都进行代理</u>，仅针对 FOR UPDATE 的 SELECT 语句。</p><p><br></p><p><strong>回滚日志表：</strong></p><p>AT模式的特点是通过代理数据源，从而能拦截SQL，并生成undo sql。这个特点在实际实战中要引起注意，要实测真实业务sql的undo sql生成正确性（担心Seata AT模式对于复杂更新sql 的解析能力）。</p><p><br></p><p>注，UNDO_LOG Table 一定要创建哦。</p><p> MySQL 为例：</p><table><thead><tr><th>Field</th><th>Type</th></tr></thead><tbody><tr><td>branch_id</td><td>bigint PK</td></tr><tr><td>xid</td><td>varchar(100)</td></tr><tr><td>context</td><td>varchar(128)</td></tr><tr><td>rollback_info</td><td>longblob</td></tr><tr><td>log_status</td><td>tinyint</td></tr><tr><td>log_created</td><td>datetime</td></tr><tr><td>log_modified</td><td>datetime</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 注意此处0.7.0+ 增加字段 context</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`undo_log`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`branch_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`xid`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`context`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`rollback_info`</span> longblob <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_status`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_created`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_modified`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>,<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>AT模式的缺点：</strong></p><p><strong>1、性能损耗：</strong></p><ul><li>还是业务上明显感知的。</li><li>一条Update SQL，需要获取全局事务XID（与TC通信）、before image（解析SQL，查询一次数据库）、after image（查询一次数据库）、insert undo log（写一次数据库）、before commit（与TC通信，判断锁冲突/获取锁），这些操作都需要一次次的远程通信RPC，而且是同步的。</li><li>另外，undo log写入时blob字段的插入信息也是不高的。</li><li>每条写SQL都会增加这么多开销，粗略估计会增加5倍的响应时间。</li><li>笔者平台线上业务实测，Seata AT模式后，所及业务功能点整体性能下降35%。</li></ul><p><strong>2、特别注意应对：补偿型方式的通病：</strong></p><ul><li><p>Seata已经支持的AT、TCC、SAGA都是补偿型的。</p></li><li><p>补偿型事务处理机制构建在事务资源之上，事务资源本身对分布式事务是无感知的。无法做到真正的全局一致性。</p><ul><li><blockquote><p>比如，一条库存记录处在补偿型事务处理过程中由100扣减为50。此时，仓库管理员链接数据库查询统计库存，查到了50。然后因事务回滚，库存由50补偿变回100。显然，仓库管理员查询统计到的50就是脏数据。</p></blockquote></li></ul></li><li><p>AT的锁能解决部分这类问题，故，实际应用时一定要仔细分析并发读写场景特点，做最小代价的应对方案。</p></li></ul><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/image-20201129164558089.png" alt="image-20201129164558089"></p><p><br></p><h3 id="5-4-3、TCC模式-（提供框架）"><a href="#5-4-3、TCC模式-（提供框架）" class="headerlink" title="5.4.3、TCC模式  （提供框架）"></a>5.4.3、TCC模式  （提供框架）</h3><p>关于原理，《5.2、TCC》章节后，此处不再详述。</p><p>但，在实际应用中务必记得考虑TCC模式下各种情况的应对。见《5.2、TCC》章节。</p><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/seata_tcc-1.png" alt="Overview of a global transaction"></p><center>Seata TCC模式的执行流程原理图</center><p>根据两阶段行为模式的不同，将分支事务划分为 <strong>Automatic (Branch) Transaction Mode</strong> 和 <strong>TCC (Branch) Transaction Mode</strong>.</p><ul><li><p>Automatic模式 基于支持本地 ACID 事务的关系型数据库（<u>即Seata AT模式</u>）：</p><ul><li>一阶段 prepare 行为：在本地事务中，一并提交业务数据更新和相应回滚日志记录。</li><li>二阶段 commit 行为：马上成功结束，自动异步批量清理回滚日志。</li><li>二阶段 rollback 行为：通过回滚日志，自动生成补偿操作，完成数据回滚。</li></ul></li><li><p><strong>TCC 模式，不依赖于底层数据资源的事务支持：</strong></p><ul><li>一阶段 prepare 行为：调用 <strong>自定义</strong> 的 prepare 逻辑。</li><li>二阶段 commit 行为：调用 <strong>自定义</strong> 的 commit 逻辑。</li><li>二阶段 rollback 行为：调用 <strong>自定义</strong> 的 rollback 逻辑。</li></ul></li></ul><p>所谓 TCC 模式，是指支持把 <strong>自定义</strong> 的分支事务纳入到全局事务的管理中。</p><p><br></p><h3 id="5-4-4、Saga模式-（多系统集成）"><a href="#5-4-4、Saga模式-（多系统集成）" class="headerlink" title="5.4.4、Saga模式  （多系统集成）"></a>5.4.4、Saga模式  （多系统集成）</h3><p><strong>概述：</strong></p><p>Saga模式是Seata提供的长事务解决方案。</p><p>事务长不长不知道，但Saga有它存在的意义和只有它能解决的场景。</p><p><br></p><p>在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现。</p><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/TB1Y2kuw7T2gK0jSZFkXXcIQFXa-445-444.png" alt="Saga模式示意图"></p><p><br></p><p><strong>适用场景：</strong></p><ul><li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</li><li>业务流程长、业务流程多</li></ul><p><strong>优势：</strong></p><ul><li>一阶段提交本地事务，无锁，高性能</li><li>事件驱动架构，参与者可异步执行，高吞吐</li><li>补偿服务易于实现</li></ul><p><strong>缺点：</strong></p><ul><li>不保证隔离性</li></ul><p><br></p><p><strong>需要注意的是：</strong></p><ul><li>虽然没体现，但Seata Saga模式的背后，仍旧是对Seata框架和Saga事务管理器的依赖。</li></ul><p>更多了解详见：</p><ul><li>Seata 官网：<a href="http://seata.io/zh-cn/docs/user/saga.html" target="_blank" rel="noopener">http://seata.io/zh-cn/docs/user/saga.html</a></li><li>Seata 样例：<a href="https://github.com/seata/seata-samples/" target="_blank" rel="noopener">https://github.com/seata/seata-samples/</a></li></ul><p><br></p><p><strong>缺乏隔离性的应对</strong>：</p><ul><li><p>由于 Saga 事务不保证隔离性, 在极端情况下可能由于脏写无法完成回滚操作。</p><ul><li><blockquote><p>比如举一个极端的例子, 分布式事务内先给用户A充值, 然后给用户B扣减余额, 如果在给A用户充值成功, 在事务提交以前, A用户把余额消费掉了, 如果事务发生回滚, 这时则没有办法进行补偿了。这就是缺乏隔离性造成的典型的问题, 实践中一般的应对方法是：</p></blockquote></li></ul></li><li><p>业务流程设计时遵循“<u>宁可长款, 不可短款</u>”的原则, 长款意思是客户少了钱机构多了钱, 以机构信誉可以给客户退款, 反之则是短款, 少的钱可能追不回来了。所以在<u>业务流程设计上一定是先扣款</u>。</p></li><li><p>有些业务场景可以允许让业务最终成功, 在回滚不了的情况下可以继续重试完成后面的流程, 所以状态机引擎除了提供“回滚”能力还需要提供“向前”恢复上下文继续执行的能力, 让业务最终执行成功, 达到最终一致性的目的。</p></li></ul><p><br></p><h2 id="5-5、【方案】事务消息-（补偿型）"><a href="#5-5、【方案】事务消息-（补偿型）" class="headerlink" title="5.5、【方案】事务消息 （补偿型）"></a>5.5、【方案】事务消息 （补偿型）</h2><p>属TCC的方案变种。</p><p><strong>适用于场景有限：</strong> 限于可异步处理的分布式事务场景（即分支事务不影响主业务的决策）。</p><p><br></p><p>市面上支持事务消息的仅：RocketMQ。见《4.2、怎么选》。</p><p><br></p><p>RocketMQ 中间件思路大致为：</p><ul><li>第一阶段 Prepared消息，会拿到消息的地址</li><li>第二阶段 执行本地事务</li><li>第三阶段 通过第一阶段拿到的地址去访问消息，并修改状态（投递/撤销）。</li></ul><p>也就是说在业务方法内要向消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/a411ccaf753bdd3c91ab94fe224109044f3.jpg" alt="img"></p><p>优点： 实现了最终一致性，不需要依赖本地数据库事务。一部分可用性保障转移给/借力MQ的能力。</p><p>缺点： 实现难度大，主流MQ不支持。</p><p><br></p><h2 id="5-6、【方案】本地消息表-（最大努力通知）"><a href="#5-6、【方案】本地消息表-（最大努力通知）" class="headerlink" title="5.6、【方案】本地消息表 （最大努力通知）"></a>5.6、【方案】本地消息表 （最大努力通知）</h2><p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。</p><ol><li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li><li>之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li></ol><p><img src="/2020/11/29/分布式系统怎么思考分布式事务问题/915a02484990dda820410c8cad2389c5386.jpg" alt="img"></p><p>优点： 一种非常经典/简单的实现，避免了分布式事务，实现了最终一致性。</p><p>缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，<em>（重点）会有很多杂活需要处理</em>。同样要考虑TCC方案下的多种技术因素，见《5.2、TCC》。在运行环境中，怀疑一切才能一切放心。</p><p><br></p><h1 id="3、再谈方案选型"><a href="#3、再谈方案选型" class="headerlink" title="3、再谈方案选型"></a>3、再谈方案选型</h1><p>看完上文后，大家应该有几个感觉：</p><ul><li>日常在聊的分布式事务的一些概念或名字中，部分是原理，部分是方案，彼此之间还存在演进关系。目前应能清晰的区分。</li><li>在实现方案上，选择的余地很少。实战场景下，大多仍是根据业务场景自研一套代码为主，但自研方案的背后仍然是TCC/XA/Saga的原理。</li><li>选择开源框架的很大目的是借力开源方案的事务管理器和其框架，本质原理都是一样的。</li><li>懂分布式事务原理的基础上，更要掌握各方案背后要应对的问题<ul><li>网络不可靠的问题</li><li>数据全局隔离性的问题</li><li>幂等的问题</li><li>空回滚的问题</li><li>事务管理器、应用节点不可靠的问题</li><li>监控的问题</li><li>……等等</li></ul></li></ul><p><br></p><p>关于分布式事务实现方案的选型/设计，笔者的心得和倾向：</p><p>1、【价值取向】分布式事务方案在“性能”和“数据一致性”两方面是相悖的，在价值取向上，我更倾向于保障“性能”。</p><blockquote><p>原因：从影响面和可恢复性角度，分布式事务问题是小概率事件，留有补救余地就行，性能的损失是实打实的反应在线上每一个请求上。</p></blockquote><p>2、【编码风格】落实“宁可长款, 不可短款”的原则。优先做扣除行为。</p><p>3、【做好监控】既然允许线上分布式事务问题的发生，那么就要有兜底应对的手段。笔者会要求团队在分布式事务的流程中认真打日志。并将此类日志作为线上业务监控范围，并与公司内部邮件系统、钉钉打通。做到一个有问题，秒级感知。</p><p>4、【双重兜底】开发统计对账服务，对线上分布式事务数据做周期性巡检。对线上数据不一致情况做通知：工单、钉钉、邮件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式系统-之-分布式事务问题&quot;&gt;&lt;a href=&quot;#分布式系统-之-分布式事务问题&quot; class=&quot;headerlink&quot; title=&quot;分布式系统 之 分布式事务问题&quot;&gt;&lt;/a&gt;分布式系统 之 分布式事务问题&lt;/h1&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;1、你怎么分享分布式事务？&quot;&gt;&lt;a href=&quot;#1、你怎么分享分布式事务？&quot; class=&quot;headerlink&quot; title=&quot;1、你怎么分享分布式事务？&quot;&gt;&lt;/a&gt;1、你怎么分享分布式事务？&lt;/h1&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;分布式事务问题是分布式系统绕不开的技术话题。&lt;/p&gt;
&lt;p&gt;“谈谈你对分布式事务的理解”、“分享下你团队在分布式事务上的解决方案”、“你用过哪几种分布式事务的中间件”？在技术交流/面试中很容易讨论到这些个话题，得到的反馈大概率是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“额~~ ~~ ~~ ~~”，一时语噻 《《《 平时没有梳理和认知分布式事物的问题，一时不知如何组织语言。&lt;/li&gt;
&lt;li&gt;“我们没有使用分布式事务”《《《 分布式事务裸奔状态。&lt;/li&gt;
&lt;li&gt;“我知道有CAP和BASE理论，分别是XXX意思” 《《《 “学院派”选手，不够接地气。&lt;/li&gt;
&lt;li&gt;“我们没用分布式事务，但有做补偿方案，XXX” 《《《 有意识和思考，可以。&lt;/li&gt;
&lt;li&gt;“我们在个别特殊业务上，用了XXX中间件方案” 《《《 有数据、有实践心得，可以。&lt;/li&gt;
&lt;li&gt;etc……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="事务" scheme="https://veryjj.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="分布式" scheme="https://veryjj.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>一文就明白Java并发编程</title>
    <link href="https://veryjj.github.io/2020/11/15/%E4%B8%80%E6%96%87%E5%B0%B1%E6%98%8E%E7%99%BD%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://veryjj.github.io/2020/11/15/一文就明白并发编程/</id>
    <published>2020-11-15T05:03:38.000Z</published>
    <updated>2021-01-10T09:23:23.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《一文就明白Java并发编程》"><a href="#《一文就明白Java并发编程》" class="headerlink" title="《一文就明白Java并发编程》"></a>《一文就明白Java并发编程》</h1><p>一文系列 之 并发编程。</p><p>行文3万余字，包含了多线程方方面面的知识点，相信对你会有所帮助！</p><p><br></p><p><br></p><p align="right">黄老师</p><p><br></p><p>[TOC]</p><p><br><br></p><h1 id="1、进程-amp-线程"><a href="#1、进程-amp-线程" class="headerlink" title="1、进程&amp;线程"></a>1、进程&amp;线程</h1><p>虽然大家肯定知道进程、线程的概念，但在介绍整篇文章前还是需要再陈述下，保证行文信息量的连贯性。</p><p><br></p><p><img src="/2020/11/15/一文就明白并发编程/image-20201011114411757.png" alt="image-20201011114411757"></p><center>Linux系统中线程的位置</center><a id="more"></a><p><strong>一些基础知识：</strong></p><ul><li>Linux操作系统分内核态和用户态。<ul><li>内核态是操作系统自己管理和控制的，是“基石”。内核态也可以开发，利用linux内核模块化技术进行模块形式加载。</li><li>用户态是开放使用的，以进程为开放使用单位。进程是在用户态资源分配的单位（以进程为单位分配内存空间），进程内的线程是用户态执行单位（进程有默认线程，以线程去执行具体的代码，作为执行单位的特点是每个线程一个调用栈）。</li></ul></li><li>其实，内核态是清楚并管理用户态的进程和线程的。用户态的每个进程在内核有对应的PCB作为管理对象。用户态的每个线程在内核有对应的TCB作为管理和调度对象。</li><li>在计算机中，CPU是稀缺资源，N多待调度的线程通过操作系统的Scheduler调度器去分配CPU时间片，让各个线程能“雨露均沾”。</li><li>用户态线程的调度功能有2种实现方式：<ul><li>第一种：交由操作系统去管理调度，特点：用户态线程和内核线程是一一映射的（如图）。也是JDK 1.2之后版本的实现方式。</li><li>第二种：JDK1.2之前，由开发者（对于JDK来说，是JVM自己）在进程空间实现一套进程内线程的调度算法。这种实现方式对开发者来说复杂，又难以完全控制时间片，可能部分线程会饿死，因为是否分配CPU时间片的真正权力握在操作系统内核上.</li></ul></li></ul><p><br></p><h1 id="2、JUC并发包"><a href="#2、JUC并发包" class="headerlink" title="2、JUC并发包"></a>2、JUC并发包</h1><h2 id="2-1、JUC包介绍"><a href="#2-1、JUC包介绍" class="headerlink" title="2.1、JUC包介绍"></a>2.1、JUC包介绍</h2><p>JUC是 java.util.concurrent的简称，是JDK包下原生的lib。是Java 5.0 提供的并发编程包，包含了并发编程中很常用的实用工具类。</p><blockquote><p>下文以JDK8为例</p></blockquote><p><img src="/2020/11/15/一文就明白并发编程/image-20201011161010836.png" alt="image-20201011161010836" style="zoom:100%;" align="center"></p><p><br></p><p>其实，JUC包中的内容经过归类后并不繁多、复杂。</p><p><br></p><p><strong>JUC提供的能力分类：</strong></p><p>1、Atomic原子类</p><p>2、Lock相关 几类基础锁机制</p><p>3、并发安全的Collection类、Map类</p><p>4、多种队列工具类</p><p>5、线程池机制</p><p>6、多线程协同工具类</p><p><br></p><h2 id="2-2、Atomic原子类"><a href="#2-2、Atomic原子类" class="headerlink" title="2.2、Atomic原子类"></a>2.2、Atomic原子类</h2><p>总所周知，Atomic原子类能保证在一个对象上多个操作步骤的原子性。这是Atomic机制在多线程并发环境中存在的意义。</p><p><br></p><h3 id="2-2-1、Atomic原子类的细分"><a href="#2-2-1、Atomic原子类的细分" class="headerlink" title="2.2.1、Atomic原子类的细分"></a>2.2.1、Atomic原子类的细分</h3><p><img src="/2020/11/15/一文就明白并发编程/image-20201011221441844.png" alt="image-20201011221441844"></p><ul><li><p><strong>基本类型的原子性操作：AtomicBoolean、AtomicInteger、AtomicLong</strong></p><ul><li>这些类能保证在并发环境中对基础整型数字的get、set、incr、decr、add、minus等方面操作的原子性。</li><li><em>JDK8开始有LongAdder类</em>，功能与AtomicLong类似。在高并发，写多读少的场景性能比AtomicLong好。</li></ul></li><li><p><strong>数组类型的原子性操作：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</strong></p><ul><li>数组级别的原子操作。提供的方法方面，只是对数组上的指定单个元素做原子操作。不具备范围型批量操作方法。</li></ul></li><li><p><strong>引用类型的原子性操作：AtomicReference</strong></p><ul><li>“AtomicReference<v>” 是AtomicReference的Class声明，即AtomicReference是存放Java对象引用的，任何对象都可以。而AtomicReference能保证多线程环境下对这个对象引用变更的一致性。</v></li><li>代码案例见下文</li></ul></li><li><p><strong>带版本标识的引用类型的原子性操作：AtomicStampedReference、AtomicMarkableReference</strong></p><ul><li><p><em>AtomicReference无法避免ABA问题</em>。</p></li><li><p>若业务场景对AtomicReference指向的对象的变化过程不关心，<strong>只关心当下时刻的值是多少，那么AtomicReference还是适合的</strong>。若业务场景关心对象值的变化过程，那么AtomicReference就不适合了。</p></li><li><p>AtomicStampedReference 在AtomicReference基础上，增加了一个<code>final int stamp</code>字段，大家可以理解为版本号+乐观锁的概念。每当对AtomicStampedReference的对象做更新时，需同时比对对象应用和stamp值，然后同时更新对象应用和stamp值</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">  Pair&lt;V&gt; current = pair;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">    expectedReference == current.reference &amp;&amp;</span><br><span class="line">    expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">    ((newReference == current.reference &amp;&amp;</span><br><span class="line">      newStamp == current.stamp) ||</span><br><span class="line">     casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AtomicMarkableReference与AtomicStampReference的区别：相较于，AtomicStampReference新增的int stamp字段，AtomicMarkableReference增加的是boolean类型的字段。其他操作上都一样，但不能解决ABA问题。</p></li></ul></li><li><p><strong>反射方式原子操作：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</strong></p><ul><li>以反射方式，对一个对象内的整型数字字段进行原子操作</li><li>要求：<ul><li>此字段必须是volatile的，保证变量变更线程间立即可见</li><li>此字段必须是变量，不能是final</li><li>只能是实例变量，不能是类变量，也就是说不能加static关键字</li><li>此字段只能是int、long基础类型（不能是包装类）</li><li>段的描述类型（修饰符public/protected/default/private）是与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作</li></ul></li><li>代码案例见下文</li></ul></li></ul><p><br><br></p><p><strong>代码案例说明 - AtomicReference</strong></p><p>以Person POJO类为背景，Person类里含有2个字段：name、age。</p><p> 构造Person对象的初始值为 <code>name=Tom, age = 18</code>。</p><p>计划</p><p> 在 线程1 中将 <code>name</code> 修改为 <code>Tom1</code>，<code>age + 1</code>。<br> 在 线程2 中将 <code>name</code> 修改为 <code>Tom2</code>，<code>age + 2</code>。</p><p><br></p><ul><li>普通引用版本  《《《 会引发更新不一致性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Person person;   《《《 全局Person对象</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Person is "</span> + person.toString());</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task1());  </span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task2());  </span><br><span class="line"></span><br><span class="line">    t1.start();   《《《 并发修改：name、age</span><br><span class="line">    t2.start();   《《《 并发修改：name、age</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Now Person is "</span> + person.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setAge(person.getAge() + <span class="number">1</span>);   《《《 并发场景下，对象多个字段的赋值非原子性</span><br><span class="line">        person.setName(<span class="string">"Tom1"</span>);               《《《</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread1 Values "</span></span><br><span class="line">                + person.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setAge(person.getAge() + <span class="number">2</span>);   《《《 并发场景下，对象多个字段的赋值非原子性</span><br><span class="line">        person.setName(<span class="string">"Tom2"</span>);               《《《</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread2 Values "</span></span><br><span class="line">                + person.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person is [name: Tom, age: 18]</span><br><span class="line">  Thread2 Values [name: Tom1, age: 21]</span><br><span class="line">  Thread1 Values [name: Tom1, age: 21]</span><br><span class="line">Now Person is [name: Tom1, age: 21]</span><br></pre></td></tr></table></figure><p><br></p><ul><li>原子引用版本 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Person person;</span><br><span class="line"><span class="comment">// 原子性引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Person&gt; aRperson;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">18</span>);</span><br><span class="line">    aRperson = <span class="keyword">new</span> AtomicReference&lt;Person&gt;(person); 《《《 对象的原子引用</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Atomic Person is "</span> + aRperson.get().toString());</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task1());   </span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task2());   </span><br><span class="line"></span><br><span class="line">    t1.start();   《《《 并发修改：name、age</span><br><span class="line">    t2.start();   《《《 并发修改：name、age</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Now Atomic Person is "</span> + aRperson.get().toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        aRperson.getAndSet(<span class="keyword">new</span> Person(<span class="string">"Tom1"</span>, aRperson.get().getAge() + <span class="number">1</span>));  《《《 对象多字段操作原子性</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread1 Atomic References "</span></span><br><span class="line">                + aRperson.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        aRperson.getAndSet(<span class="keyword">new</span> Person(<span class="string">"Tom2"</span>, aRperson.get().getAge() + <span class="number">2</span>));  《《《 对象多字段操作原子性</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread2 Atomic References "</span></span><br><span class="line">                + aRperson.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出之一：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Atomic Person is [name: Tom, age: 18]</span><br><span class="line">  Thread1 Atomic References [name: Tom1, age: 19]</span><br><span class="line">  Thread2 Atomic References [name: Tom2, age: 21]</span><br><span class="line">Now Atomic Person is [name: Tom2, age: 21]</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><p><strong>代码案例说明 - AtomicIntegerFieldUpdater</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> automic;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;Person&gt; cls;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * AtomicIntegerFieldUpdater class说明</span></span><br><span class="line"><span class="comment">      * 基于反射的实用工具，可以对指定类的指定 volatile int 字段进行原子更新。此类用于原子数据结构，</span></span><br><span class="line"><span class="comment">      * 该结构中同一节点的几个字段都独立受原子更新控制。</span></span><br><span class="line"><span class="comment">      * 注意，此类中 compareAndSet 方法的保证弱于其他原子类中该方法的保证。</span></span><br><span class="line"><span class="comment">      * 因为此类不能确保所有使用的字段都适合于原子访问目的，所以对于相同更新器上的 compareAndSet 和 set 的其他调用，</span></span><br><span class="line"><span class="comment">      * 它仅可以保证原子性和可变语义。</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建AtomicLongFieldUpdater对象，传递参数是“class对象”和“long类型在类中对应的名称”</span></span><br><span class="line">        AtomicIntegerFieldUpdater&lt;Person&gt; personFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Person.class, <span class="string">"id"</span>);</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">12345</span>);</span><br><span class="line">        personFieldUpdater.compareAndSet(person, <span class="number">12345</span>, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"id="</span> + person.getId());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-2-2、Atomic原子类的实现原理"><a href="#2-2-2、Atomic原子类的实现原理" class="headerlink" title="2.2.2、Atomic原子类的实现原理"></a>2.2.2、Atomic原子类的实现原理</h3><p>Atomic的核心操作是CAS（Compare And Set）。该操作在操作系统层面对应C语言汇编的CMPXCHG指令，该指令通过三个操作数（变量V，预期旧值O，目标新值N），能原子的完成“变量V当前值与预期旧值E的等值判断，并完成新值N的赋值”。</p><p>注，常规的Atomic存在ABA的问题。</p><p><br></p><p>所有Atomic类内部都会调用Unsafe类完成CAS的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p>Unsafe内部就是C语言实现与操作系统的交互了，最终会涉及到CPU级的操作。</p><p><br></p><p><strong>CMPXCHG指令介绍</strong></p><p>Unsafe的CompareAndSwap方法最终在 hotspot 源码实现中都会调用统一的 cmpxchg 函数。</p><p><strong>cmpxchg 函数源码</strong>：</p><p>源码地址：<code>hotspot/src/share/vm/runtime/Atomic.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">jbyte Atomic::cmpxchg(jbyte exchange_value, <span class="keyword">volatile</span> jbyte*dest, jbyte compare_value) &#123;</span><br><span class="line"> assert (<span class="keyword">sizeof</span>(jbyte) == <span class="number">1</span>,<span class="string">"assumption."</span>);</span><br><span class="line"> <span class="keyword">uintptr_t</span> dest_addr = (<span class="keyword">uintptr_t</span>) dest;</span><br><span class="line"> <span class="keyword">uintptr_t</span> offset = dest_addr % <span class="keyword">sizeof</span>(jint);</span><br><span class="line"> <span class="keyword">volatile</span> jint*dest_int = ( <span class="keyword">volatile</span> jint*)(dest_addr - offset);</span><br><span class="line"> <span class="comment">// 对象当前值</span></span><br><span class="line"> jint cur = *dest_int;</span><br><span class="line"> <span class="comment">// 当前值cur的地址</span></span><br><span class="line"> jbyte * cur_as_bytes = (jbyte *) ( &amp; cur);</span><br><span class="line"> <span class="comment">// new_val地址</span></span><br><span class="line"> jint new_val = cur;</span><br><span class="line"> jbyte * new_val_as_bytes = (jbyte *) ( &amp; new_val);</span><br><span class="line">  <span class="comment">// new_val存exchange_value，后面修改则直接从new_val中取值</span></span><br><span class="line"> new_val_as_bytes[offset] = exchange_value;</span><br><span class="line"> <span class="comment">// 比较当前值与期望值，如果相同则更新，不同则直接返回</span></span><br><span class="line"> <span class="keyword">while</span> (cur_as_bytes[offset] == compare_value) &#123;</span><br><span class="line">  <span class="comment">// 调用汇编指令cmpxchg执行CAS操作，期望值为cur，更新值为new_val</span></span><br><span class="line"> jint res = cmpxchg(new_val, dest_int, cur);</span><br><span class="line"> <span class="keyword">if</span> (res == cur) <span class="keyword">break</span>;</span><br><span class="line"> cur = res;</span><br><span class="line"> new_val = cur;</span><br><span class="line"> new_val_as_bytes[offset] = exchange_value;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 返回当前值</span></span><br><span class="line"> <span class="keyword">return</span> cur_as_bytes[offset];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>多CPU如何实现原子操作</strong></p><p><img src="/2020/11/15/一文就明白并发编程/image-20201109223114311.png" alt="image-20201109223114311"></p><p>在计算机硬件层面，CPU 处理器速度远远大于主内存，为了解决速度差异，在两者之间架设了CPU多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离CPU越近就越快，将频繁操作的数据缓存到这里，加快访问速度。</p><p>现在都是多核 CPU 处理器，每个 CPU 处理器内维护各自关于内存数据的缓存，当多线程并发读写时，就会出现CPU缓存数据不一致的情况。</p><p><strong>对于原子操作，CPU处理器提供2种方式：</strong></p><ul><li><strong>总线锁定</strong></li></ul><p>当一个处理器要操作共享变量时，在 BUS 总线上发出一个 Lock 信号，其他处理就无法操作这个共享变量了。</p><p>缺点很明显，总线锁定在阻塞其它处理器获取该共享变量的操作请求时，也可能会导致大量阻塞，从而增加系统的性能开销。</p><ul><li><strong>缓存锁定 </strong></li></ul><p>后来的处理器都提供了缓存锁定机制，当某个处理器对缓存中的共享变量进行了操作，其他处理器会有个嗅探机制，将其他处理器的该共享变量的缓存失效，待其他线程读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现的。</p><p>现代的处理器基本都支持和使用的缓存锁定机制。</p><p><br></p><h2 id="2-3、JUC包中的锁"><a href="#2-3、JUC包中的锁" class="headerlink" title="2.3、JUC包中的锁"></a>2.3、JUC包中的锁</h2><p>Java中有很多种类的锁，在JUC包中也有比较多的锁类型。但不用怕难，因为归结到底层和操作系统级别，其核心原理和机制都是类似的，所以学Java的锁也只需要掌握锁背后的核心机制和扩展方向就行了，剩下的就交给举一反三吧。</p><p><br></p><p><img src="/2020/11/15/一文就明白并发编程/image-20201011151355568.png" alt="image-20201011151355568"></p><center>JUC包中锁之间的关联</center><p>通过上图，对JUC包中的锁有个宏观认识，相信对理解和掌握JUC包中的锁会有事半功倍的效果。</p><h3 id="2-3-1、顶层抽象类：AbstractQueuedSynchronizer（AQS）"><a href="#2-3-1、顶层抽象类：AbstractQueuedSynchronizer（AQS）" class="headerlink" title="2.3.1、顶层抽象类：AbstractQueuedSynchronizer（AQS）"></a>2.3.1、顶层抽象类：AbstractQueuedSynchronizer（AQS）</h3><p><strong>2.3.1.1、AbstractQueuedSynchronizer</strong>，简称AQS。【核心抽象类】</p><p>我们对于锁的认知，一般会有如下几个常规的认知：</p><p>1、多个线程尝试拿锁</p><p>2、拿不到锁的线程阻塞等待</p><p>3、用完锁的线程释放锁，等待线程得到锁</p><p><br></p><p>其实在JUC包中锁实现的本质原理也是这么回事。</p><p><br></p><p><strong>有关于AQS：</strong></p><p>1、AQS中的等待队列FIFO</p><p><img src="/2020/11/15/一文就明白并发编程/image-20201018224037651.png" alt="image-20201018224037651"></p><ul><li>head：表示当前拿到锁的线程Node</li><li>node：表示未拿到锁被阻塞的线程Node</li></ul><p>2、AQS有“独占锁”和“共享锁”两种模式</p><ul><li>独占模式（Node.EXCLUSIVE） 应用：ReentrantLock</li><li>共享模式（Node.SHARE）        应用：Semaphore</li></ul><p>3、实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物</p><p><br></p><p><strong>2.3.1.1.1、独占模式：</strong></p><blockquote><p>为帮助阅读，已精简剔除大量代码。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/**重要变量*/</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 头结点，可理解为当前持有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">// 代表当前锁的状态，0代表没有被占用，大于0 代表有线程持有当前锁, 大于 1 代表锁重入的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;                     </span><br><span class="line">    <span class="comment">// 当前持有独占锁的线程。继承自AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**重要接口*/</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 加锁接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;...&#125;</span><br><span class="line">       <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;...&#125;    <span class="comment">// 尝试加锁</span></span><br><span class="line">       <span class="function">Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;...&#125;      <span class="comment">// 拿不到锁就创建新等待节点，并添加到队列尾部</span></span><br><span class="line">       <span class="function"><span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;...&#125;  <span class="comment">// 使线程阻塞在等待队列中，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false</span></span><br><span class="line">           <span class="function"><span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span>  <span class="comment">// 当前线程主动阻塞自己</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">//解锁接口</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;...&#125;</span><br><span class="line">       <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;...&#125;    <span class="comment">// 尝试解锁，一般都会成功。若跨线程解锁会抛异常</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span>      <span class="comment">// 唤醒等待队列里的下一个等待节点的线程</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>AbstractQueuedSynchronizer作为JUC包中锁的顶级抽象类，以模板方式和抽象方法方式，为JUC包中锁的实现定义了框架和提供了默认/基础实现。</p><p><strong>AQS类锁能力基础认知：</strong></p><p>1、如上代码注释所属。其实现原理借助于关键变量：head、tail、state、exclusiveOwnerThread，和关键方法：acquire和release，以及内部的子方法。</p><p>2、总体上实现：加锁、判断锁、阻塞等待队列、可重入锁、解锁等框架能力</p><p><br></p><p><strong>AQS关键代码解读：</strong></p><ul><li><strong>acquireQueued(Node, int)</strong> 拿不到锁时，线程阻塞挂起</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//标记等待过程中是否被中断过</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//“自旋”！</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//拿到前驱</span></span><br><span class="line">              </span><br><span class="line">              <span class="comment">//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。</span></span><br><span class="line">              <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                 setHead(node);<span class="comment">//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。</span></span><br><span class="line">                 p.next = <span class="keyword">null</span>; <span class="comment">// setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！</span></span><br><span class="line">                 failed = <span class="keyword">false</span>; <span class="comment">// 成功获取资源</span></span><br><span class="line">                 <span class="keyword">return</span> interrupted;<span class="comment">//返回等待过程中是否被中断过</span></span><br><span class="line">             &#125;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">//如果自己可以休息了，就通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待。</span></span><br><span class="line">             <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                 parkAndCheckInterrupt())</span><br><span class="line">                 interrupted = <span class="keyword">true</span>;<span class="comment">//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (failed) <span class="comment">// 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。</span></span><br><span class="line">             cancelAcquire(node);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>unparkSuccessor(Node node)</strong>  解锁时唤醒下一个等待节点线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//这里，node一般为当前线程所在的结点。</span></span><br><span class="line">     <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">     <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line">         compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">     Node s = node.next;<span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line">     <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//如果为空或已取消</span></span><br><span class="line">         s = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从后向前找。</span></span><br><span class="line">             <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line">                 s = t;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">         LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>2.3.1.1.2、共享模式：</strong></p><blockquote><p>查看带 xxxShared 字眼的方法</p></blockquote><p>相比独占模式，共享模式的差异如下：</p><p>1、state 初始值大于1，代表可被共享的次数</p><p>2、共享模式加锁时，对state做减法操作，只要剩余state够就能加锁成功。加锁成功时<strong>不再记录加锁的Thread信息</strong>。</p><p>3、加锁失败时，与共享模式一样，添加等待节点到等待队列尾部。</p><p>4、解锁时，做state做加法操作。然后<strong>循环唤醒</strong>等待队列中的阻塞线程。</p><p><br></p><p><strong>关键代码解读：</strong></p><ul><li><strong>tryAcquireShared</strong> </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//获取AQS中资源个数</span></span><br><span class="line">    <span class="keyword">int</span> available = getState();</span><br><span class="line">    <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">    <span class="comment">//如果remaining小于0，说明没有可用的资源了，如果大于0，执行CAS操作获取资源，最后返回剩余的资源数</span></span><br><span class="line">    <span class="comment">//如果返回的剩余资源数小于或者等于0，说明没有可用资源了，如果大于0，说明还有可用资源</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">        compareAndSetState(available, remaining))</span><br><span class="line">      <span class="keyword">return</span> remaining;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>releaseShared</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Semaphore中的实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> current = getState();</span><br><span class="line">    <span class="keyword">int</span> next = current + releases;</span><br><span class="line">    <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(current, next))   <span class="comment">// 释放资源占用</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>doReleaseShared</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//获取首节点</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">    <span class="comment">//获取首节点状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">    <span class="comment">//如果首节点状态是SIGNAL，说明首节点后面还有节点，唤醒他们</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">        <span class="comment">//先把首节点状态改成0，0可以看成首节点的中间状态，只有在唤醒第二个节点的时候才会存在，当第二个节点唤醒之后，首节点</span></span><br><span class="line">        <span class="comment">//就会被干掉</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">          <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个方法就是唤醒首节点之后第一个处于非取消状态的节点</span></span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//判断ws == 0，这个是中间状态，就是说有一个线程正在唤醒第二个节点，这个时候，又有一个线程释放了资源，也要来唤醒第二个节点，但是他发现</span></span><br><span class="line">      <span class="comment">//有别的线程在处理，他就把这个状态改成PROPAGATE = -3,而这个状态正是上一个方法需要判断的，上一个方法判断h.waitStatus &lt; 0，会成立就是这里设置的</span></span><br><span class="line">      <span class="comment">//当然，h.waitStatus &lt; 0会成立，还有别的原因，这个只是其中一个，下面会分析</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">        <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == head)               <span class="comment">// loop if head changed</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>至此，你已经掌握了AQS抽象类的主要原理，相信在看具体锁实现时会事半功倍（AbstractQueuedSynchronizer中还有很多的具体实现，但不打紧，掌握这几个核心原理就可以了）。</p><p><br></p><h3 id="2-3-2、顶层抽象类：AbstractOwnableSynchronizer"><a href="#2-3-2、顶层抽象类：AbstractOwnableSynchronizer" class="headerlink" title="2.3.2、顶层抽象类：AbstractOwnableSynchronizer"></a>2.3.2、顶层抽象类：AbstractOwnableSynchronizer</h3><p>此类特别简单，可直接看代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁独占模式下，当前独占锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set操作</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get操作</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title">getExclusiveOwnerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-3-3、顶层抽象类：AbstractQueuedLongSynchronizer"><a href="#2-3-3、顶层抽象类：AbstractQueuedLongSynchronizer" class="headerlink" title="2.3.3、顶层抽象类：AbstractQueuedLongSynchronizer"></a>2.3.3、顶层抽象类：AbstractQueuedLongSynchronizer</h3><p>一句话：64位版本的AQS</p><p><img src="/2020/11/15/一文就明白并发编程/image-20201018225626498.png" alt="image-20201018225626498"></p><p><br></p><h3 id="2-3-4、锁分类"><a href="#2-3-4、锁分类" class="headerlink" title="2.3.4、锁分类"></a>2.3.4、锁分类</h3><p>Java中有哪些常见的锁？</p><ul><li>见本文后面章节《Java中的锁》。进行了分类和详细的介绍。</li></ul><p><br></p><h3 id="2-3-5、ReentrantLock"><a href="#2-3-5、ReentrantLock" class="headerlink" title="2.3.5、ReentrantLock"></a>2.3.5、ReentrantLock</h3><blockquote><p>假设你已经先读了：</p><ul><li>AQS</li><li>本文的锁分类介绍</li></ul></blockquote><p>那么，在此基础上我们差异性的陈述一些要点：</p><p><br></p><ul><li>ReentrantLock是独享锁</li><li>ReentrantLock底层是基于AQS</li><li>ReentrantLock支持公平锁模式和非公平锁模式，默认是非公平锁（即尝试加锁时是抢占式的）</li></ul><p><br></p><p><strong>老生常谈 之 ReentrantLock  vs  synchronized</strong></p><p>既然与ReentrantLock相比，那么就从ReentrantLock特点的视角对比下：</p><table><thead><tr><th></th><th>锁类型</th><th>底层技术</th><th>是否公平锁</th><th>是否可重入</th></tr></thead><tbody><tr><td>ReentrantLock</td><td>独享锁</td><td>CAS + AQS</td><td>均支持。可指定</td><td>可重入</td></tr><tr><td>synchronized</td><td>独享锁</td><td>CAS + Monitor</td><td>非公平锁</td><td>可重入</td></tr></tbody></table><blockquote><p>关于ReentrantLock的可重入，还记得上文的AbstractOwnableSynchronizer不，每次加锁时拿出来判断下即可，发现是同一个线程，重入。</p></blockquote><p>另外，两者在性能层面没有明显区别。</p><p><br></p><p>所以，选择哪一种就要看具体代码场景了</p><ul><li>适合ReentrantLock的场景<ul><li>细粒度的锁范围控制</li><li>细粒度的阻塞线程唤醒。ReentrantLock提供了Condition类，用来实现分组唤醒需要唤醒的线程们。</li><li>ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</li></ul></li></ul><p>所以，一般情况下常规加锁需求用synchronized先，有更进一步的加锁要求时ReentrantLock更适合。</p><p><br></p><h3 id="2-3-6、ReentrantReadWriteLock"><a href="#2-3-6、ReentrantReadWriteLock" class="headerlink" title="2.3.6、ReentrantReadWriteLock"></a>2.3.6、ReentrantReadWriteLock</h3><p>上来先讲结论，然后再酌情看代码加深理解：</p><p>（参考下图）</p><ul><li>ReentrantReadWriteLock是读写锁</li><li>ReentrantReadWriteLock内部持有两把锁来实现读写锁：ReadLock、WriteLock</li><li>ReadLock&amp;WriteLock共用一个Sync（即共享同一个AQS），正因为是共用一个Sync，才能在读写锁的时候分别感知对方的状态。</li><li>ReentrantReadWriteLock的读写锁标记维护在同一个AQS的state上，为了记录ReadLock和WriteLock的次数， 通过EXCLUSIVE_MASK将32位的state拆成两段：高16位给ReadLock用，低16位给WriteLock用。</li><li>读锁状态：可多个线程同时拿锁，且均可各自重入。（见：Sync内部类HoldCounter和ThreadLocalHoldCounter）</li><li>写锁状态：独享锁状态。</li><li>ReentrantReadWriteLock支持锁降级：写锁状态进入，读锁状态退出</li></ul><p><img src="/2020/11/15/一文就明白并发编程/image-20201026211616304.png" alt="image-20201026211616304"></p><center>ReentrantReadWriteLock类依赖关系</center><p><br></p><p><strong>ReentrantReadWriteLock内部的两把锁：</strong></p><p><img src="/2020/11/15/一文就明白并发编程/image-20201026224252998.png" alt="image-20201026224252998"></p><p><br></p><p><strong>共用一个Sync（AQS）：</strong></p><p>Sync里有哪些重要信息呢？</p><ul><li><p>将AQS state字段复用为读锁、写锁计数位的SHARED_SHIFT</p></li><li><p>ThreadLocalHoldCounter控制读锁重入</p></li><li>其他均继承自AQS<ul><li>state 记录锁的状态</li><li>exclusiveOwnerThread 记录锁被哪个线程独占</li><li>等待队列</li><li>线程阻塞 &amp; 等待线程唤醒方法</li><li>共享模式（读锁的场景）</li></ul></li></ul><p><img src="/2020/11/15/一文就明白并发编程/image-20201026224607453.png" alt="image-20201026224607453"></p><p><img src="/2020/11/15/一文就明白并发编程/image-20201026224522538.png" alt="image-20201026224522538"></p><p><img src="/2020/11/15/一文就明白并发编程/image-20201026224540457.png" alt="image-20201026224540457"></p><p><br></p><p><strong>ReentrantReadWriteLock分段使用AQS的锁计数state：</strong></p><p><img src="/2020/11/15/一文就明白并发编程/image-20201026215920789.png" alt="image-20201026215920789"></p><p><br></p><p><strong>锁降级：</strong></p><blockquote><p>概念：</p></blockquote><p>以写锁进入临界区，但以读锁结束。（加锁顺序：写锁-加锁 ==&gt; 读锁加锁 ==&gt; 写锁-解锁 ==&gt; 读锁-解锁）</p><p><br></p><ul><li><strong>相关代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)   <span class="comment">//若tryAcquireShared返回&gt;=0。代表拿读锁成功</span></span><br><span class="line">            doAcquireShared(arg);        <span class="comment">//执行拿读锁的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">          <span class="comment">//注解说明：当前时刻存在写锁，而且如果自己这个获取读锁的线程和当前持有写锁的线程是同一个线程的话，就不会返回-1。也就是说可以继续获取读锁。</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">       &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-3-7、StampedLock"><a href="#2-3-7、StampedLock" class="headerlink" title="2.3.7、StampedLock"></a>2.3.7、StampedLock</h3><p>在 JDK 1.8 引入 StampedLock，可以理解为<strong>对 ReentrantReadWriteLock</strong> 在<strong>某些方面</strong>的<strong>增强</strong>，在原先读写锁的基础上新增了一种叫乐观读（Optimistic Reading）的模式。该模式并不会加锁，所以不会阻塞线程，允许多个度线程和1个写线程并发执行，故有更高的吞吐量和更高的性能。尤其<strong>适合读多写少的场景</strong>。</p><p><br></p><p><strong>2.3.7.1、特性</strong></p><p>它的设计初衷是作为一个内部工具类，用于开发其他线程安全的组件，提升系统性能，并且编程模型也比ReentrantReadWriteLock 复杂，所以用不好就很容易出现死锁或者线程安全等莫名其妙的问题。</p><p><strong>三种访问数据模式</strong>：</p><ul><li>Writing（独占写锁）：writeLock 方法会使线程阻塞等待独占访问，可类比ReentrantReadWriteLock 的写锁模式，同一时刻有且只有一个写线程获取锁资源；</li><li>Reading（悲观读锁）：readLock方法，允许多个线程同时获取悲观读锁，悲观读锁与独占写锁互斥，与乐观读共享。</li><li>Optimistic Reading（乐观读）：这里需要注意了，是乐观读，并没有加锁。也就是不会有 CAS 机制并且没有阻塞线程。仅当当前未处于 Writing 模式 tryOptimisticRead才会返回非 0 的邮戳（Stamp），如果在获取乐观读之后没有出现写模式线程获取锁，则在方法validate返回 true ，<strong>允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁</strong>。《《《《《【重点】【重点】【重点】</li></ul><p><br></p><p><strong>支持读写锁相互转换</strong></p><ul><li><p>ReentrantReadWriteLock： 当线程获取写锁后可以降级成读锁，但是反过来则不行。</p></li><li><p>StampedLock：提供了读锁和写锁相互转换的功能，使得该类支持更多的应用场景。</p></li></ul><p><br></p><p><strong>2.3.7.2、详解乐观读带来的性能提升</strong></p><p>StampedLock 性能比 ReentrantReadWriteLock 好，关键在于StampedLock 提供的<strong>乐观读</strong>。</p><p>我们知道ReentrantReadWriteLock 的读锁和写锁是互斥的，当有读锁的时候，写锁线程是阻塞等待的。</p><p>而，<strong>StampedLock 的乐观读允许一个写线程获取写锁</strong>，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。</p><p><br></p><p><strong>这里可能你就会有疑问，竟然同时允许多个乐观读和一个先线程同时进入临界资源操作，那读取的数据可能是错的怎么办？</strong></p><p>是的，乐观读不能保证读取到的数据是最新的，所以将数据读取到局部变量的时候需要通过 lock.validate(stamp) 校验是否被写线程修改过，若是修改过则需要上悲观读锁，再重新读取数据到局部变量。</p><p>同时由于乐观读并不是锁，所以没有线程唤醒与阻塞导致的上下文切换，性能更好。</p><p><br></p><p><strong>2.3.7.3、使用场景和注意事项</strong></p><p>对于读多写少的高并发场景 StampedLock的性能很好！</p><p>通过乐观读模式很好的解决了写线程“饥饿”的问题，我们可以使用StampedLock 来代替ReentrantReadWriteLock ，但是需要注意的是 <strong>StampedLock 的功能仅仅是 ReadWriteLock 的子集</strong>，在使用的时候，还是有几个地方需要注意一下。</p><ol><li>StampedLock是不可重入锁，如果当前线程已经获取了写锁，再次重复获取的话就会死锁。使用过程中一定要注意；</li><li>悲观读、写锁都不支持条件变量 Conditon ，当需要这个特性的时候需要注意；</li><li>如果线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升。所以，<strong>使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()</strong>。这个规则一定要记清楚。</li></ol><p>对比：</p><table><thead><tr><th></th><th>锁模式</th><th>是否可重入</th><th>CAS后的ABA问题</th><th>锁转换</th></tr></thead><tbody><tr><td>ReentrantReadWriteLock</td><td>悲观读</td><td>可重入</td><td>无法避免ABA问题</td><td>锁降级</td></tr><tr><td>StampedLock</td><td>悲观读/乐观读</td><td>不可重入</td><td>通过版本号解决ABA问题</td><td>锁降级/锁升级</td></tr></tbody></table><p><br></p><p><strong>2.3.7.4、代码例子</strong></p><p>官方例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排它锁-写锁（writeLock）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乐观读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取乐观读锁（1）</span></span><br><span class="line">        <span class="keyword">long</span> stamp = sl.tryOptimisticRead();</span><br><span class="line">        <span class="comment">// 将全部变量拷贝到方法体栈内（2）</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x, currentY = y;</span><br><span class="line">        <span class="comment">// 检查在（1）获取到读锁票据后，锁有没被其他写线程排它性抢占（3）</span></span><br><span class="line">        <span class="keyword">if</span> (!sl.validate(stamp)) &#123;</span><br><span class="line">            <span class="comment">// 如果被抢占则获取一个共享读锁（悲观获取）（4）</span></span><br><span class="line">            stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将全部变量拷贝到方法体栈内（5）</span></span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放共享读锁（6）</span></span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回计算结果（7）</span></span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用悲观锁获取读锁，并尝试转换为写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里可以使用乐观读锁替换（1）</span></span><br><span class="line">        <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前点在原点则移动（2）</span></span><br><span class="line">            <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line">                <span class="comment">// 尝试将获取的读锁升级为写锁（3）</span></span><br><span class="line">                <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp);</span><br><span class="line">                <span class="comment">// 升级成功，则更新票据，并设置坐标值，然后退出循环（4）</span></span><br><span class="line">                <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123;</span><br><span class="line">                    stamp = ws;</span><br><span class="line">                    x = newX;</span><br><span class="line">                    y = newY;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 读锁升级写锁失败则释放读锁，显示获取独占写锁，然后循环重试（5）</span></span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                    stamp = sl.writeLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁（6）</span></span><br><span class="line">            sl.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-3-8、Semaphore"><a href="#2-3-8、Semaphore" class="headerlink" title="2.3.8、Semaphore"></a>2.3.8、Semaphore</h3><p>Semaphore是一种计数信号量，用于管理一组资源，内部是基于AQS的共享模式。它相当于控制使用公共资源的活动线程的数量。</p><p>使用场景的比喻：停车场车位滚动使用；卫生间坑位的滚动使用。</p><p><br></p><p><strong>主要结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;   <span class="comment">// 基于AQS。那么天然可重入。</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;     <span class="comment">// 非公平锁。</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;        <span class="comment">// 公平锁。</span></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">availablePermits</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>主要方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Semaphore(<span class="keyword">int</span> permits):构造方法，创建具有给定许可数的计数信号量并设置为非公平信号量。</span><br><span class="line"></span><br><span class="line">Semaphore(<span class="keyword">int</span> permits,<span class="keyword">boolean</span> fair):构造方法，当fair等于<span class="keyword">true</span>时，创建具有给定许可数的计数信号量并设置为公平信号量。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span>:从此信号量获取一个许可前线程将一直阻塞。相当于一辆车占了一个车位。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> n)</span>:从此信号量获取给定数目许可，在提供这些许可前一直将线程阻塞。比如n</span>=<span class="number">2</span>，就相当于一辆车占了两个车位。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span>:释放一个许可，将其返回给信号量。就如同车开走返回一个车位。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> n)</span>:释放n个许可。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">availablePermits</span><span class="params">()</span>：当前可用的许可数。</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建一个信号量，并发度为3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore SEMAPHORE = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor THREAD_POOL = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//起多个线程竞争</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            THREAD_POOL.execute(<span class="keyword">new</span> Car(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Integer number;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Integer number)</span> </span>&#123; <span class="keyword">this</span>.number = number; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println((<span class="keyword">new</span> Date()).getSeconds() + <span class="string">"second Car"</span> + <span class="keyword">this</span>.number + <span class="string">" waiting ..."</span>);</span><br><span class="line">                <span class="comment">//拿到锁</span></span><br><span class="line">                SEMAPHORE.acquire();</span><br><span class="line">                <span class="comment">//让拿到锁的线程稍作等待，等全部线程启动并都尝试拿锁</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println((<span class="keyword">new</span> Date()).getSeconds() + <span class="string">"second Car"</span> + <span class="keyword">this</span>.number + <span class="string">" In . Remaining parking spaces="</span> + SEMAPHORE.availablePermits());</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                SEMAPHORE.release();</span><br><span class="line">                System.out.println((<span class="keyword">new</span> Date()).getSeconds() + <span class="string">"second Car"</span> + <span class="keyword">this</span>.number +  <span class="string">" Out. Remaining parking spaces="</span> + SEMAPHORE.availablePermits());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">12</span>second Car1 waiting ...</span><br><span class="line"><span class="number">12</span>second Car3 waiting ...</span><br><span class="line"><span class="number">12</span>second Car5 waiting ...</span><br><span class="line"><span class="number">12</span>second Car2 waiting ...</span><br><span class="line"><span class="number">12</span>second Car4 waiting ...</span><br><span class="line">  </span><br><span class="line"><span class="number">14</span>second Car5 In . Remaining parking spaces=<span class="number">0</span></span><br><span class="line"><span class="number">14</span>second Car3 In . Remaining parking spaces=<span class="number">0</span></span><br><span class="line"><span class="number">14</span>second Car1 In . Remaining parking spaces=<span class="number">0</span></span><br><span class="line"><span class="number">14</span>second Car3 Out. Remaining parking spaces=<span class="number">2</span></span><br><span class="line"><span class="number">14</span>second Car1 Out. Remaining parking spaces=<span class="number">3</span></span><br><span class="line"><span class="number">14</span>second Car5 Out. Remaining parking spaces=<span class="number">3</span></span><br><span class="line"><span class="number">16</span>second Car4 In . Remaining parking spaces=<span class="number">1</span></span><br><span class="line"><span class="number">16</span>second Car4 Out. Remaining parking spaces=<span class="number">2</span></span><br><span class="line"><span class="number">16</span>second Car2 In . Remaining parking spaces=<span class="number">1</span></span><br><span class="line"><span class="number">16</span>second Car2 Out. Remaining parking spaces=<span class="number">3</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="2-4、并发安全集合类"><a href="#2-4、并发安全集合类" class="headerlink" title="2.4、并发安全集合类"></a>2.4、并发安全集合类</h2><h3 id="2-4-1、AbstractMap"><a href="#2-4-1、AbstractMap" class="headerlink" title="2.4.1、AbstractMap"></a>2.4.1、AbstractMap</h3><p>AbstractMap 提供了 Map 的基本实现，使得我们以后要实现一个 Map 不用从头开始。</p><p>AbstractMap提供了哪些基础能力呢？</p><ul><li>【反过来讲】极端情况下，开发者只需要实现<code>entrySet()抽象方法</code>和重载<code>put()方法</code>，就能自定义一个Map类。</li></ul><p><img src="/2020/11/15/一文就明白并发编程/image-20201109172250459.png" alt="image-20201109172250459"></p><p><br></p><h3 id="2-4-2、ConcurrentHashMap"><a href="#2-4-2、ConcurrentHashMap" class="headerlink" title="2.4.2、ConcurrentHashMap"></a>2.4.2、ConcurrentHashMap</h3><p><img src="/2020/11/15/一文就明白并发编程/java8-concurrenthashmap.png" alt="img"></p><p>HashMap结构由两级构成</p><ul><li>一级：数组结构，俗称Segment</li><li>二级：链表/红黑树结构</li></ul><p><br></p><p><strong>2.4.2.1、知识点概要</strong></p><ul><li><p>读不涉及锁操作：get(Object key)不涉及锁操作。</p></li><li><p>写涉及锁操作：put、remove、clear方法使用锁。</p><ul><li>ConcurrentHashMap为了减少锁征用，将锁加在数组节点上，俗称Segment。</li></ul></li><li><p>ConcurrentHashMap允许一边更新、一边遍历。故Iterator对象使用时，获得的对象可能是更新前的对象。若希望遍历到当前全部数据的话，要么以ConcurrentHashMap变量为锁进行同步(synchronized该变量)，要么使用CopiedIterator包装iterator，使其拷贝当前集合的全部数据。</p></li><li><p>ConcurrentHashMap冲突域上有两种实现方法，最终是为了提高遍历查找的速度。</p><ul><li>默认链表结构。</li><li>当链表节点超过8个时，自动升级成红黑树</li><li>当红黑树节点减少，少于6个时，会自动退化成链表</li></ul></li><li><p>ConcurrentHashMap数组空间默认是16，resize是翻倍（左移一位）</p><ul><li>为什么是16？参考：泊松分布 Poisson distribution (<a href="http://en.wikipedia.org/wiki/Poisson_distribution" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Poisson_distribution</a>)</li></ul></li></ul><p><br></p><p><strong>ConcurrentHashMap实现同步的锁：synchronized</strong></p><p>样例代码截取：我们可以看到在ConcurrentHashMap里锁的都是设计好的代码段位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;   &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 在这</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        ....</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">                (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;   &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 在这</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                            addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>ConcurrentHashMap的空间为什么是2的幂次方？</strong></p><ul><li>2的幂次方：ConcurrentHashMap内部用于计算hash值的<code>spread</code>方法（扰动函数）就能用位移操作进行快速计算，远比取模、加减乘除效率高</li><li>2的幂次方：在resize时，需要挪动Map节点，而2的幂次方递增，保持了规律性。只需要对最高位不一致的几个节点进行挪动即可，且挪动的步长是固定的老空间大小<ul><li>例如：old size 16（占用尾部4个二进制位表达），new size 32（占用尾部5个二进制位表达）</li><li>此时resize时，遍历每个节点，判断节点的尾部5位的第5位是否为1，为1说明节点hash值是超出old size的，需要挪动。同理，第5位为0的，不需要挪动。</li><li>那么，挪到哪个位置呢？在原数组的位置基础上加上原数组的整体长度（16），这个值就是在新数组中的位置。</li></ul></li></ul><p><br></p><p><strong>Hashtable和ConcurrentHashMap的不同点？</strong></p><ol><li><p>HashTable的同步级别是对象对象级。ConcurrentHashMap的同步级别是代码块级。ConcurrentHashMap吞吐能力好。</p></li><li><p>HashTable在iterator遍历的时候，不支持其他线程进行put，remove等更新操作，否则会抛出ConcurrentModificationException异常。而ConcurrentHashMap是支持的。</p></li></ol><p><br></p><p><strong>2.4.2.2、Java8 的新方法：</strong></p><ul><li>compute方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key的value值，取自于remappingFunction的计算结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfPresent</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span></span></span><br></pre></td></tr></table></figure><p><br></p><ul><li>merge方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key的value值，取自于key下oldValue和newValue的计算结果，通过remappingFunction计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">merge</span><span class="params">(K key, V value, BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">- 当key为尚未存在，直接插入对应value，remappingFunction不会被调用；</span></span><br><span class="line"><span class="function">- 否则，对oldValue与value做remappingFunction函数，结果作为新的newValue插入到map中。</span></span><br><span class="line"><span class="function">- 同样<span class="keyword">null</span>结果会删除对应的k-v。</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li>reduce方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历map，对key或value值应用过滤函数和累加函数，最终得到一个累加值</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(<span class="keyword">long</span> parallelismThreshold,</span></span></span><br><span class="line"><span class="function"><span class="params">                        BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends U&gt; transformer,</span></span></span><br><span class="line"><span class="function"><span class="params">                        BiFunction&lt;? <span class="keyword">super</span> U, ? <span class="keyword">super</span> U, ? extends U&gt; reducer)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">reduceValues</span><span class="params">(<span class="keyword">long</span> parallelismThreshold,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; reducer)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">reduceKeys</span><span class="params">(<span class="keyword">long</span> parallelismThreshold,</span></span></span><br><span class="line"><span class="function"><span class="params">                        BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> K, ? extends K&gt; reducer)</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure><p><br></p><p>compute方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Integer&gt; count = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key = b, 值为4不变</span></span><br><span class="line">    count.put(<span class="string">"b"</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key = a, 用回调方法，不断累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        count.compute(<span class="string">"a"</span>, <span class="keyword">new</span> BiFunction&lt;String, Integer, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String k, Integer v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> v == <span class="keyword">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调里可做业务操作</span></span><br><span class="line">    System.out.println(count.compute(<span class="string">"b"</span>, (k, v) -&gt; &#123;</span><br><span class="line">        System.out.println(k + <span class="string">" --- "</span> + v);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">    </span><br><span class="line">    System.out.println(count.compute(<span class="string">"a"</span>, (k, v) -&gt; v == <span class="keyword">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此时count里只有a有value了</span></span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>reduce方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduceDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">"2"</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">"3"</span>, <span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">"4"</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="string">"5"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无过滤器场景</span></span><br><span class="line">        Integer value1 = map.reduceValues(<span class="number">1</span>, Integer::sum);</span><br><span class="line">        <span class="comment">//有过滤器场景</span></span><br><span class="line">        Integer value2 = map.reduceValues(<span class="number">1</span>, v-&gt;<span class="number">0</span> == v%<span class="number">2</span>?<span class="keyword">null</span>:v, Integer::sum);</span><br><span class="line">        System.out.println(value1);   &lt;&lt;&lt; print <span class="number">15</span></span><br><span class="line">        System.out.println(value2);   &lt;&lt;&lt; print <span class="number">9</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-4-3、ConcurrentSkipListMap"><a href="#2-4-3、ConcurrentSkipListMap" class="headerlink" title="2.4.3、ConcurrentSkipListMap"></a>2.4.3、ConcurrentSkipListMap</h3><blockquote><p>一句话：key保序的ConcurrentHashMap。</p><p>第二句话：非多线程情况下，用TreeMap。</p></blockquote><p>ConcurrentSkipListMap是线程安全的有序的哈希表，适用于高并发的场景。</p><p>ConcurrentSkipListMap是通过跳表实现的</p><p><br></p><p><strong>并发且保序的需求时</strong></p><ul><li><strong>低并发</strong>：使用Collections.synchronizedSortedMap</li><li><strong>高并发</strong>：使用ConcurrentSkipListMap</li></ul><p><br></p><p><strong>关于跳表</strong></p><p><img src="/2020/11/15/一文就明白并发编程/30221944-21a18064c0114e65bffa68c5dadd4f0b.jpg" alt="img"></p><center>ConcurrentSkipListMap的数据结构</center><p>以数据“7,14,21,32,37,71,85”序列为例，来对跳表进行简单说明。</p><p>跳表分为许多层(level)，每一层都可以看作是数据的索引，这些索引的意义就是加快跳表查找数据速度。每一层的数据都是有序的，上一层数据是下一层数据的子集，并且第一层(level 1)包含了全部的数据；层次越高，跳跃性越大，包含的数据越少。</p><p>跳表包含一个表头，它查找数据时，是从上往下，从左往右进行查找。现在“需要找出值为32的节点”为例，来对比说明跳表和普遍的链表。</p><p><br></p><p><strong>情况1：链表中查找“32”节点</strong><br>路径如下图所示：</p><p><img src="/2020/11/15/一文就明白并发编程/30222059-f01604b1b24d429e940f7a002947c143.jpg" alt="img"></p><p>需要4步(红色部分表示路径)。</p><p><br></p><p><strong>情况2：跳表中查找“32”节点</strong><br>路径如下图所示</p><p><img src="/2020/11/15/一文就明白并发编程/30222128-045c88b7e992443395a540ba2eb740f3.jpg" alt="img"></p><p>忽略索引垂直线路上路径的情况下，只需要2步(红色部分表示路径)。</p><p><br></p><h2 id="2-5、队列-Queue"><a href="#2-5、队列-Queue" class="headerlink" title="2.5、队列 Queue"></a>2.5、队列 Queue</h2><table><thead><tr><th></th><th>是否有界</th><th>数据结构</th><th>排序</th><th>入队出队并发</th><th>特点</th><th></th><th></th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>有界</td><td>数组</td><td>FIFO</td><td>否</td><td>无</td><td></td><td></td></tr><tr><td>LinkedBlockingQueue</td><td>可选</td><td>链表</td><td>FIFO</td><td>是</td><td>常用<br>若不指定容量，默认无界</td><td></td><td></td></tr><tr><td>LinkedTransferQueue</td><td>无界</td><td>链表</td><td>FIFO</td><td>可选</td><td>有4种模式选择队列的行为表现</td><td></td><td></td></tr><tr><td>DelayQueue</td><td>无界</td><td>优先级队列</td><td>按时间排序</td><td>否</td><td>延时</td><td></td><td></td></tr><tr><td>PriorityBlockingQueue</td><td>无界</td><td>优先级队列</td><td>比较结果</td><td>否</td><td>入队列的元素必须实现Comparable接口</td><td></td><td></td></tr><tr><td>SynchronousQueue</td><td>容量0</td><td>N/A</td><td>N/A</td><td>否</td><td>进一个出一个<br>出一个进一个</td><td></td><td></td></tr><tr><td>ConcurrentLinkedQueue</td><td>无界</td><td>链表</td><td>FIFO</td><td>否</td><td>非阻塞</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><p>注：</p><ul><li>关于公平性：ArrayBlockingQueue默认情况下不保证线程公平地访问队列，即阻塞的线程，不一定按阻塞的先后顺序访问队列，非公平性也是为了提高吞吐率</li></ul></blockquote><p><br></p><h3 id="2-5-1、AbstractQueue"><a href="#2-5-1、AbstractQueue" class="headerlink" title="2.5.1、AbstractQueue"></a>2.5.1、AbstractQueue</h3><p><img src="/2020/11/15/一文就明白并发编程/image-20201109200647895.png" alt="image-20201109200647895"></p><p>看到没，大部分的实现类都依赖：AbstractQueue 和 BlockingQueue。</p><ul><li>AbstractQueue定义队列的方法集，用extends</li><li>BlockingQueue定义了阻塞的个性功能，用implements</li></ul><p><br></p><h3 id="2-5-2、BlockingQueue"><a href="#2-5-2、BlockingQueue" class="headerlink" title="2.5.2、BlockingQueue"></a>2.5.2、BlockingQueue</h3><p>BlockingQueue即阻塞队列，它是基于ReentrantLock。最常用的是用于实现生产者与消费者模式，大致如下图所示：</p><p><img src="/2020/11/15/一文就明白并发编程/image-20201109211643968.png" alt="image-20201109211643968"></p><blockquote><p>在Java中，BlockingQueue是一个接口，它的实现类有ArrayBlockingQueue、DelayQueue、 LinkedBlockingDeque、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue等，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于take与put操作的原理，却是类似的</p></blockquote><ul><li>入队</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">offer(E e)：如果队列没满，立即返回true； 如果队列满了，立即返回false--&gt;不阻塞</span><br><span class="line"></span><br><span class="line">put(E e)：如果队列满了，一直阻塞，直到队列不满了或者线程被中断--&gt;阻塞</span><br><span class="line"></span><br><span class="line">offer(E e, long timeout, TimeUnit unit)：在队尾插入一个元素，如果队列已满，则进入等待，直到出现以下三种情况：--&gt;阻塞</span><br><span class="line">1、被唤醒</span><br><span class="line">2、等待时间超时</span><br><span class="line">3、当前线程被中断</span><br></pre></td></tr></table></figure><ul><li>出队</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">poll()：如果没有元素，直接返回null；如果有元素，出队</span><br><span class="line"></span><br><span class="line">take()：如果队列空了，一直阻塞，直到队列不为空或者线程被中断--&gt;阻塞</span><br><span class="line"></span><br><span class="line">poll(long timeout, TimeUnit unit)：如果队列不空，出队；如果队列已空且已经超时，返回null；如果队列已空且时间未超时，则进入等待，直到出现以下三种情况：</span><br><span class="line">1、被唤醒</span><br><span class="line">2、等待时间超时</span><br><span class="line">3、当前线程被中断</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-5-3、LinkedBlockingQueue"><a href="#2-5-3、LinkedBlockingQueue" class="headerlink" title="2.5.3、LinkedBlockingQueue"></a>2.5.3、LinkedBlockingQueue</h3><p>见总结表格</p><h3 id="2-5-4、DelayQueue"><a href="#2-5-4、DelayQueue" class="headerlink" title="2.5.4、DelayQueue"></a>2.5.4、DelayQueue</h3><p>见总结表格</p><h3 id="2-5-5、ArrayBlockingQueue"><a href="#2-5-5、ArrayBlockingQueue" class="headerlink" title="2.5.5、ArrayBlockingQueue"></a>2.5.5、ArrayBlockingQueue</h3><p>虽是数组，但在逻辑上要把它想象成环，持续重复使用。</p><p><img src="/2020/11/15/一文就明白并发编程/image-20201109205834065.png" alt="image-20201109205834065"></p><h3 id="2-5-6、LinkedTransferQueue"><a href="#2-5-6、LinkedTransferQueue" class="headerlink" title="2.5.6、LinkedTransferQueue"></a>2.5.6、LinkedTransferQueue</h3><p>见总结表格</p><h3 id="2-5-7、PriorityBlockingQueue"><a href="#2-5-7、PriorityBlockingQueue" class="headerlink" title="2.5.7、PriorityBlockingQueue"></a>2.5.7、PriorityBlockingQueue</h3><p>见总结表格</p><h3 id="2-5-8、SynchronousQueue"><a href="#2-5-8、SynchronousQueue" class="headerlink" title="2.5.8、SynchronousQueue"></a>2.5.8、SynchronousQueue</h3><p>见总结表格</p><h3 id="2-5-9、ConcurrentLinkedQueue"><a href="#2-5-9、ConcurrentLinkedQueue" class="headerlink" title="2.5.9、ConcurrentLinkedQueue"></a>2.5.9、ConcurrentLinkedQueue</h3><ul><li>基于链接节点可并发的无界双端队列。</li><li>并发插入，删除和访问操作安全执行。</li><li>因为这些deques的异步性质，例如确定当前的数量，元素需要遍历元素等操作是不可信的，因为在遍历期间可并发修改此集合。</li><li>也是使用cas来保证线程安全，这个类不仅可以操控头部，也可以操控尾部</li></ul><p><br></p><h2 id="2-6、线程池机制"><a href="#2-6、线程池机制" class="headerlink" title="2.6、线程池机制"></a>2.6、线程池机制</h2><p><img src="/2020/11/15/一文就明白并发编程/image-20201109224905870.png" alt="image-20201109224905870"></p><center>JUC包中有关线程池的类</center><h3 id="2-6-1、主要类介绍"><a href="#2-6-1、主要类介绍" class="headerlink" title="2.6.1、主要类介绍"></a>2.6.1、主要类介绍</h3><p><strong>2.6.1.1、【Interface】顶层Executor</strong></p><p>对，就是这么短。</p><p>定义了线程池最基本的动作：提交、执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>2.6.1.2、【Interface】ExecutorService</strong></p><p>ExecutorService继承于Executor。它是”执行者服务”接口，它是为”执行者接口Executor”服务而存在的；准确的话，ExecutorService提供了”将任务提交给执行者的接口(submit方法)”，”让执行者执行任务(invokeAll, invokeAny方法)”的接口等等。</p><p><strong>ExecutorService的函数列表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此执行程序已关闭，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 如果关闭后所有任务都已完成，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。</span></span></span><br><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。</span></span></span><br><span class="line"><span class="function">Future&lt;?&gt; <span class="title">submit</span><span class="params">(Runnable task)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>2.6.1.3、【Class】AbstractExecutorService</strong></p><p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。</p><p>AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。</p><p>AbstractExecutorService函数列表和ExecutorService一样。</p><p><br></p><p><strong>2.6.1.4、【Class】ThreadPoolExecutor</strong></p><p>ThreadPoolExecutor就是<strong>大名鼎鼎的”线程池”</strong>。它继承于AbstractExecutorService抽象类。</p><p><br></p><p><strong>2.6.1.5、【Interface】ScheduledExecutorService</strong></p><p>ScheduledExecutorService是一个接口，它继承于于ExecutorService。</p><p>它相当于<strong>提供了”延时”和”周期执行”功能</strong>的ExecutorService。</p><p>ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。</p><p><strong>ScheduledExecutorService函数列表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并执行在给定延迟后启用的 ScheduledFuture。</span></span><br><span class="line">&lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 创建并执行在给定延迟后启用的一次性操作。</span></span></span><br><span class="line"><span class="function">ScheduledFuture&lt;?&gt; <span class="title">schedule</span><span class="params">(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。</span></span></span><br><span class="line"><span class="function">ScheduledFuture&lt;?&gt; <span class="title">scheduleAtFixedRate</span><span class="params">(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。</span></span></span><br><span class="line"><span class="function">ScheduledFuture&lt;?&gt; <span class="title">scheduleWithFixedDelay</span><span class="params">(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>2.6.1.6、【Class】ScheduledThreadPoolExecutor</strong></p><p>是ScheduledExecutorService的实现类。记住特点：”延时”和”周期执行”。<br>ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。</p><p><br></p><p><strong>2.6.1.7、【Class】Executors</strong></p><p>Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象</p><p><br></p><h3 id="2-6-2、重点详解ThreadPoolExecutor"><a href="#2-6-2、重点详解ThreadPoolExecutor" class="headerlink" title="2.6.2、重点详解ThreadPoolExecutor"></a>2.6.2、重点详解ThreadPoolExecutor</h3><p><strong>【敲黑板】线程池的“池”，就是在ThreadPoolExecutor中。</strong></p><p><br></p><p>ThreadPoolExecutor特点：</p><ul><li>线程池和任务队列可定制</li><li>运行前后可扩展</li></ul><p><br></p><p><strong>从源码角度认识ThreadPoolExecutor</strong></p><ul><li>构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><u>（重要知识点）ThreadPoolExecutor构造方法参数解读：</u></p><ul><li><strong>corePoolSize</strong>：核心线程数。线程池在初始构造后，线程池里的线程是0个，待有任务进来时，开始创建线程，直到达到corePoolSize。当任务数多于corePoolSize时，不再创建线程，而是把任务放入workQueue排队。 </li><li><strong>maxPoolSize</strong>：corePoolSize说到，任务数多于corePoolSize时，任务是进workQueue等待的。那什么时候突破corePoolSize继续创建线程呢？<em>（重点）只有在workQueue满了时</em>，再有新任务进来就会额外的创建线程，直到总线程数到达maxPoolSize。故，maxPoolSize是线程池的线程个数上限。 </li><li><strong>keepAliveTime</strong>：如果线程池当前线程数多余corePoolSize，那么多余的线程的空闲时间超过keepAliveTime，它们就会被终止。 </li><li><strong>unit</strong>：与keepAliveTime搭配，表示时间的单位，JUC包下的TimeUnit类。</li><li><strong>threadFactory</strong>：线程工厂，用来创建线程。默认使用Executors.defaultThreadFactory()，Executors.defaultThreadFactory创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级（默认5）并且都不是守护线程。如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否为守护线程等。 </li><li><strong>workQueue</strong>：任务队列。必须是BlockingQueue的实现类，有三种常见的队列类型：     <ul><li>直接交接：SynchronousQueue     </li><li>无界队列：LinkedBlockingQueue     《《《 鉴于maxPoolSize的工作机制，要特别注意无界队列的情况</li><li>有界队列：ArrayBlockingQueue</li></ul></li><li><strong>handler</strong>：在maxPoolSize了解到，当workQueue满了后会创建新线程，直到maxPoolSize。那么此时线程个数最大且workQueue满了，此时还来新任务。对于线程池来说，就没地方存放这个任务了，就会做拒绝逻辑处理。<ul><li>JUC有提供四种拒绝策略:<ul><li>AbortPolicy（默认的）：就是直接抛出异常</li><li>CallerRunsPolicy：把任务留给调用方线程去执行</li><li>DiscardPolicy：啥都不敢，丢弃。</li><li>DiscardOldestPolicy：当任务被拒绝添加时，抛弃workQueue里最旧的任务（即最先进入队列的那个）</li><li>自定义：实现RejectedExecutionHandler Interface。</li></ul></li></ul></li></ul><p><br></p><ul><li>重要变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法里的一些参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示是否允许核心线程在空闲状态下自行销毁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line">    <span class="comment">// 线程池已完成的任务数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line">    <span class="comment">// 表示线程池从创建到现在，池中线程的最大数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要用于同步访问（或者说改变）线程池的状态以及线程池的各项参数，比如completedTaskCount和workers等</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>worker</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">// 任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">// 完成任务个数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>ThreadPoolExecutor扩展</li></ul><p>ThreadPoolExecutor扩展主要是围绕beforeExecute()、afterExecute()和terminated()三个接口实现的，</p><p>1、beforeExecute：线程池中任务运行前执行</p><p>2、afterExecute：线程池中任务运行完毕后执行</p><p>3、terminated：线程池退出后执行</p><h3 id="2-6-3、ExecutorService的三种线程池机制"><a href="#2-6-3、ExecutorService的三种线程池机制" class="headerlink" title="2.6.3、ExecutorService的三种线程池机制"></a>2.6.3、ExecutorService的三种线程池机制</h3><ul><li><strong>一、newFixedThreadPool</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span>  LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool 的核心线程数和最大线程数都是<strong>指定值且相同</strong>，也就是说当线程池中的线程数超过核心线程数后，任务都会被放到阻塞队列中。且，这里选用的阻塞队列是<strong>LinkedBlockingQueue</strong>，使用的是默认容量 Integer.MAX_VALUE，相当于<strong>没有上限</strong>。</p><p><br>那么此线程池的逻辑是：按固定线程数执行任务，超过的任务都放任务队列排队。</p><p><br><br>用途：FixedThreadPool 用于负载比较大的服务器，为了资源的合理利用，需要限制当前线程数量</p><p><br></p><ul><li>二、newCachedThreadPool</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CachedThreadPool 里线程池中的线程具有缓存的效果：创建后会keepalive 60秒。</p><p>它的执行流程如下：</p><ol><li>如果有空闲线程，就去取出任务执行；如果没有空闲线程，就新建一个。</li><li>执行完任务的线程有 60 秒生存时间，如果在这个时间内可以接到新任务，就可以继续活下去，否则就被回收</li></ol><p><br></p><ul><li>三、newSingleThreadExecutor</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p><p><br></p><h3 id="2-6-4、如何优雅的关闭线程池"><a href="#2-6-4、如何优雅的关闭线程池" class="headerlink" title="2.6.4、如何优雅的关闭线程池"></a>2.6.4、如何优雅的关闭线程池</h3><ul><li>见下文《多线程场景》编码举例&amp;详解</li></ul><p><br></p><h3 id="2-6-5、如何合理配置线程池的大小"><a href="#2-6-5、如何合理配置线程池的大小" class="headerlink" title="2.6.5、如何合理配置线程池的大小"></a>2.6.5、如何合理配置线程池的大小</h3><p>如何合理配置线程池大小，线程池大小不是靠猜，也不是说越多越好。</p><p>在遇到这类问题时，需要分析</p><ol><li>需要分析线程池执行的任务的特性： CPU 密集型还是 IO 密集型</li><li>每个任务执行的平均时长大概是多少，这个任务的执行时长可能还跟任务处理逻辑是否涉及到网络传输以及底层系统资源依赖有关系</li></ol><ul><li>如果是 CPU 密集型：<ul><li>主要是执行计算任务，这种任务 cpu的利用率很高，那么线程数的配置应该根据 CPU 核心数来决定。</li><li>CPU 核心数 = 最大同时执行线程数。过多的线程会导致上下文切换反而使得效率降低。那线程池的最大线程数可以配置为 cpu 核心数+1 </li></ul></li><li>如果是 IO 密集型：<ul><li>主要是进行 IO 操作，执行 IO 操作的时间较长，这时 cpu 经常会处于空闲等待状态，导致 cpu 的利用率不高，这种情况下可以增加线程池的大小。</li><li>这种情况下可以结合线程的等待时长来做判断，等待时间越高，那么线程数也相对越多。</li><li>一般可以配置 cpu 核心数的 2 倍。</li></ul></li></ul><p><br></p><p><strong>一个公式：</strong></p><blockquote><p>线程池设定最佳线程数目 = （（线程池设定的线程等待时间 + 线程CPU执行时间）/ 线程CPU执行时间 ）* CPU 数目</p></blockquote><p>这个公式的线程 cpu 执行时间是预估的程序单个线程在 cpu 上运行的时间（通常使用 压测工具测试大量运行次数求出平均值）</p><p><br></p><p>例如：</p><ul><li>高并发、<strong>任务执行时间短</strong>的任务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</li></ul><p><br></p><p>但，这对于真实的并发场景来说，这只是根据CPU核数的计算。实际情况中，专业全面一点，还要根据具体任务的内存占用情况、数据库并发情况、外部交互的服务的并发情况等来微调线程池大小。</p><p>对！高并发是个系统、全面、整体性的工作。</p><p>最终线程池设多大最合理，建议进行压测获取任务吞吐量，然后综合评定。</p><p><br></p><p>其他，一些关于连接池的系统资源数据参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Linux方面</span><br><span class="line">- 系统最大文件打开数：65535</span><br><span class="line">- 最大TCP连接：20000</span><br><span class="line">- TCP连接建议值：10240</span><br><span class="line"></span><br><span class="line">JVM方面</span><br><span class="line">- 最大连接个数：1024</span><br><span class="line"></span><br><span class="line">Tomcat方面</span><br><span class="line">- 最大连接个数：maxConnections 10000，  maxThreads 200</span><br><span class="line"></span><br><span class="line">Dubbo方面</span><br><span class="line">- 默认最大连接个数：200</span><br><span class="line"></span><br><span class="line">Mysql方面</span><br><span class="line">- 客户端：SpringBoot最大连接个数：100</span><br><span class="line">- 服务端：阿里云RDS 300~64000</span><br><span class="line"></span><br><span class="line">Redis方面</span><br><span class="line">- 客户端：</span><br><span class="line">  - SpringBoot2.0 - lettuce 没有池</span><br><span class="line">  - jedis客户端默认有池：8</span><br><span class="line">- 服务端：默认10000</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-6-6、线程池的监控（感知线程池的运行情况）"><a href="#2-6-6、线程池的监控（感知线程池的运行情况）" class="headerlink" title="2.6.6、线程池的监控（感知线程池的运行情况）"></a>2.6.6、线程池的监控（感知线程池的运行情况）</h3><p>如果在项目中大规模的使用了线程池，那么必须要有一套监控体系，来感知当前线程池的状态，当出现问题的时候可以快速定位到问题。</p><p>线程池提供了相应的扩展方法，我们通过重写线程池的 beforeExecute、afterExecute 和 shutdown 等方式就可以收集线程运行状态信息，实现对线程池的监控。</p><p>一个简单案例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存任务开始执行的时间,当任务结束时,用任务结束时间减去开始时间计算任务执行时间</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Date&gt; startTimes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Demo1(int corePoolSize, int maximumPoolSize, long</span><br><span class="line">            keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">        super(corePoolSize, maximumPoolSize, keepAliveTime, unit,</span><br><span class="line">                workQueue);</span><br><span class="line">        this.startTimes = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> void shutdown() &#123;</span><br><span class="line">        System.out.println(<span class="string">"已经执行的任务数："</span>+this.getCompletedTaskCount()+<span class="string">", "</span> +</span><br><span class="line">                           <span class="string">"当前活动线程数:"</span> + this.getActiveCount() + </span><br><span class="line">                           <span class="string">",当前排队线程数:"</span>+ this.getQueue().size());</span><br><span class="line">        System.out.println();</span><br><span class="line">        super.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务开始之前记录任务开始时间</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> void beforeExecute(Thread t, Runnable r) &#123;</span><br><span class="line">        startTimes.put(String.valueOf(r.hashCode()), <span class="keyword">new</span> Date());</span><br><span class="line">        super.beforeExecute(t, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> void afterExecute(Runnable r, Throwable t) &#123;</span><br><span class="line">        Date startDate = startTimes.remove(String.valueOf(r.hashCode()));</span><br><span class="line">        Date finishDate = <span class="keyword">new</span> Date();</span><br><span class="line">        long diff = finishDate.getTime() - startDate.getTime();</span><br><span class="line">        <span class="comment">// 统计任务耗时、初始线程数、核心线程数、正在执行的任务数量、</span></span><br><span class="line">        <span class="comment">// 已完成任务数量、任务总数、队列里缓存的任务数量、</span></span><br><span class="line">        <span class="comment">// 池中存在的最大线程数、最大允许的线程数、线程空闲时间、线程池是否关闭、线程池是否终止</span></span><br><span class="line">        System.out.<span class="keyword">print</span>(<span class="string">"任务耗时:"</span> + diff + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.<span class="keyword">print</span>(<span class="string">"初始线程数:"</span> + this.getPoolSize() + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.<span class="keyword">print</span>(<span class="string">"核心线程数:"</span> + this.getCorePoolSize() + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.<span class="keyword">print</span>(<span class="string">"正在执行的任务数量:"</span> + this.getActiveCount() + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.<span class="keyword">print</span>(<span class="string">"已经执行的任务数:"</span>+this.getCompletedTaskCount()+<span class="string">"\n "</span>);</span><br><span class="line">        System.out.<span class="keyword">print</span>(<span class="string">"任务总数:"</span> + this.getTaskCount() + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.<span class="keyword">print</span>(<span class="string">"最大允许的线程数:"</span> + this.getMaximumPoolSize() + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.<span class="keyword">print</span>(<span class="string">"线程空闲时间:"</span>+this.getKeepAliveTime(TimeUnit.MILLISECONDS)+<span class="string">"\n "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        super.afterExecute(r, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Demo1(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>L, TimeUnit.SECONDS, <span class="keyword">new</span></span><br><span class="line">                SynchronousQueue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="2-7、多线程协同工具类"><a href="#2-7、多线程协同工具类" class="headerlink" title="2.7、多线程协同工具类"></a>2.7、多线程协同工具类</h2><h3 id="2-7-1、Fork-Join-分治机制"><a href="#2-7-1、Fork-Join-分治机制" class="headerlink" title="2.7.1、Fork / Join 分治机制"></a>2.7.1、Fork / Join 分治机制</h3><p>JUC包中Fork / Join 机制的功能，简单来说：</p><ul><li>可并行处理的大任务</li><li>拆分成一个个的小任务</li><li>并发执行</li><li>然后逐步归集任务结果</li></ul><p><br></p><p>Fork / Join 用分治法解决问题。典型的应用比如快速排序算法。</p><p>要点在于，ForkJoinPool需要使用相对少的线程(默认系统自带cpu核数)来处理大量[有依赖关系]的任务。</p><p><img src="/2020/11/15/一文就明白并发编程/image-20201107155827482.png" alt="image-20201107155827482" style="zoom:50%;"></p><p><img src="/2020/11/15/一文就明白并发编程/image-20201107155847879.png" alt="image-20201107155847879" style="zoom:50%;"></p><p><br></p><p><strong>2.7.1.1、ForkJoinPool &amp; ForkJoinTask 类</strong></p><p>Fork / Join 主要由JUC包中的ForkJoinPool 和 ForkJoinTask类实现。</p><p><br></p><p><strong>ForkJoinTask</strong></p><ul><li>是任务执行的基本单位</li><li>开发者需实现两部分功能<ul><li>1、<strong>切分任务</strong>为更小的任务，并join子任务的结果。（见上图效果）</li><li>2、作为最小的任务，<strong>完成计算</strong>逻辑，并返回结果。</li></ul></li><li>ForkJoinTask是抽象类，需要被实现：exec、setRawResult、getRawResult。在JUC包中，有提供继承了ForkJoinTask的RecursiveTask（已有ForkJoinTask待继承方法的默认实现，开发者只需要实现compute方法就行），推荐开发者用<strong>RecursiveTask</strong>。</li></ul><p><br></p><p><strong>ForkJoinTask  vs  ForkJoinAction</strong></p><ul><li>ForkJoinTask有返回值，分解后可归并</li><li>ForkJoinAction无返回值，分解后纯执行</li></ul><p><br></p><p>RecursiveTask源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    V result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> V <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getRawResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        result = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        result = compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>ForkJoinPool</strong></p><ul><li>是任务的执行核心</li><li><p>几个要点：</p><ul><li><p>内含 ForkJoinTask数组（任务）</p></li><li><p>内含ForkJoinWorkerThread数组（执行线程）</p><ul><li>每个工作线程都有维护一份待执行的ForkJoinTask等待队列。用于存储在本线程中被拆分的若干子任务。</li><li>Thread个数可配。Thread工厂由默认DefaultForkJoinWorkerThreadFactory提供。</li></ul></li><li><p>JVM加载ForkJoinPool类时，会初始创建一个commonPool，<em>lambda表达式默认情况下共享这个commonPool</em>：只要是共享工作线程Workers，连带的就共享workder下的Task队列了。</p><ul><li><p>commonPool默认线程数是机器的CPU数 - 1（例如16核的CPU，线程数15个）</p><ul><li>故，大家共享的情况下，<em>使用Java 8 并行流（parallel stream），冷不丁就会对整体性能造成了严重影响，使用lambda parallelStream时需要尤其注意使用场景，CPU密集型是合适的</em>。</li><li>代码中<code>new ForkJoinPool()</code>的都是独立的pool。</li></ul></li><li><p>怎么办呢？特殊场景就自定义ForkJoinPool，不要用commonPool</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//代码很简单，设定想要的并发度就行了</span><br><span class="line">ForkJoinPool forkJoinPool = new ForkJoinPool(8);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><p><br></p><ul><li><p><strong>fork( ) 做些什么？</strong></p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Thread t;</span><br><span class="line">   <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">     ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当前线程不是个ForkJoinWorkerThread的时候，则加入到ForkJoinPool线程池(基于<code>ExecutorService</code>实现)，最终会归到某个workerThread的workQueue里去；</p></li><li><p>如果当前线程已经是个ForkJoinWorkerThread了，则把这个任务加入到当前线程的workQueue;</p></li><li><p><strong><em>这是和普通线程池不同的地方，task并不是交给线程池中的queue，而是放到线程本地的<code>workQueue</code></em></strong></p></li></ul></li><li><p>ForkJoinPool中的Task如何运行？</p><ul><li><p>a）线程以LIFO先进后出方式从本地队列获取任务，执行，直到自己的队列为空；</p></li><li><p>b）查看其他ForkJoinWorkerThread是否有未执行task，有的话通过<code>work−stealing</code>窃取,窃取方式为FIFO先进先出，减少竞争；优先看曾今从自己那里窃取任务的thread，如果有的话；</p></li><li><p>C）任务运行完成时，返回结果；</p></li></ul></li></ul><p><br></p><ul><li><p><strong>join( )做些什么？</strong></p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s;</span><br><span class="line">  <span class="comment">//调用doJoin方法阻塞等待的结果不是NORMAL,说明有异常或取消.报告异常</span></span><br><span class="line">  <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">      reportException(s);</span><br><span class="line">  <span class="comment">//等于NORMAL,正常执行完毕,返回原始结果</span></span><br><span class="line">  <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>它首先调用doJoin方法，由doJoin()完成复杂的逻辑处理</p><ul><li>1、检查调用join()的线程是否是ForkJoinThread线程。如果不是（例如main线程），则<strong>阻塞</strong>当前线程，等待任务完成。如果是，则不阻塞。</li><li>2、查看任务的完成状态，如果已经完成，直接返回结果。</li><li>3、如果任务尚未完成，但处于自己的工作队列内，则完成它。</li><li>4、如果任务已经被其他的工作线程偷走，则窃取这个小偷的工作队列内的任务（以FIFO方式），执行之，以期帮助它早日完成欲join的任务。</li><li>5、如果偷走任务的小偷也已经把自己的任务全部做完，正在等待需要join的任务时，则找到小偷的小偷，帮助它完成它的任务。</li><li>6、递归的执行第5步。</li></ul></li></ul></li></ul></li></ul><p><br></p><p><img src="/2020/11/15/一文就明白并发编程/forkjoinpool.png" alt="img"></p><center>ForkJoinPool框架单个任务运行流程</center><p><img src="/2020/11/15/一文就明白并发编程/image-20201107224619497.png" alt="image-20201107224619497"></p><center>从队列中获取任务图解</center><p><br></p><p><strong>ForkJoinPool的默认线程数</strong></p><p>ForkJoinPool同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果指明线程数量，那么默认取值于当前计算机可用的CPU数。</p><p><br></p><p><strong>注意点</strong></p><ul><li>ForkJoinPool在执行过程中，会创建大量的子任务，导致GC，这些是需要注意的。</li></ul><p><br></p><p><strong>代码示例</strong></p><p>示例一个分段加法计算的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span>[] data;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">long</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只需实现compute逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 切分任务。</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">            <span class="comment">//最小任务，就做计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++)&#123;</span><br><span class="line">                sum += data[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            SumTask left = <span class="keyword">new</span> SumTask(data, start, middle);</span><br><span class="line">            SumTask right = <span class="keyword">new</span> SumTask(data, middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            invokeAll(left, right);  <span class="comment">// 这个技巧很重要，是的当前线程fork后能接着compute。默认是不compute了</span></span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line"></span><br><span class="line">            sum = left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] data = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">1024</span>*<span class="number">100</span>];</span><br><span class="line">        Arrays.setAll(data, i-&gt;i);</span><br><span class="line"></span><br><span class="line">        Date startTime = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        SumTask sumTask = <span class="keyword">new</span> SumTask(data,<span class="number">0</span>, data.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="keyword">new</span> ForkJoinPool().invoke(sumTask);</span><br><span class="line"></span><br><span class="line">        Date finishTime = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        System.out.println(<span class="string">"开始时间："</span> + sf.format(startTime));</span><br><span class="line">        System.out.println(<span class="string">"结束时间："</span> + sf.format(finishTime));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"最终结果 sum = "</span> + sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...略</span><br><span class="line">Thread = ForkJoinPool-1-worker-5; start = 75200 end = 75999; sum = 60403601</span><br><span class="line">Thread = ForkJoinPool-1-worker-1; start = 0 end = 51199; sum = 1309030464</span><br><span class="line">Thread = ForkJoinPool-1-worker-2; start = 74400 end = 75199; sum = 59764401</span><br><span class="line">Thread = ForkJoinPool-1-worker-7; start = 76000 end = 76799; sum = 61042801</span><br><span class="line">Thread = ForkJoinPool-1-worker-4; start = 73600 end = 75199; sum = 118889602</span><br><span class="line">Thread = ForkJoinPool-1-worker-5; start = 75200 end = 76799; sum = 121446402</span><br><span class="line">Thread = ForkJoinPool-1-worker-4; start = 73600 end = 76799; sum = 240336004</span><br><span class="line">Thread = ForkJoinPool-1-worker-2; start = 70400 end = 76799; sum = 470444808</span><br><span class="line">Thread = ForkJoinPool-1-worker-6; start = 64000 end = 76799; sum = 899980816</span><br><span class="line">Thread = ForkJoinPool-1-worker-2; start = 51200 end = 76799; sum = 1636326432</span><br><span class="line">Thread = ForkJoinPool-1-worker-2; start = 51200 end = 102399; sum = 3927193664</span><br><span class="line">Thread = ForkJoinPool-1-worker-1; start = 0 end = 102399; sum = 5236224128</span><br><span class="line"> </span><br><span class="line">开始时间：2020-11-07 15:54:40</span><br><span class="line">结束时间：2020-11-07 15:54:58</span><br><span class="line"> </span><br><span class="line">最终结果 sum = 5236224128</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-7-2、CountDownLatch-vs-CyclicBarrier"><a href="#2-7-2、CountDownLatch-vs-CyclicBarrier" class="headerlink" title="2.7.2、CountDownLatch  vs  CyclicBarrier"></a>2.7.2、CountDownLatch  vs  CyclicBarrier</h3><p><img src="/2020/11/15/一文就明白并发编程/image-20201026234628772.png" alt="image-20201026234628772"></p><p><br></p><p><strong>2.7.2.1、CountDownLatch的用法</strong></p><p><strong>CountDownLatch典型用法1：某一线程A等待N个线程执行完毕后，再执行。</strong></p><ul><li>线程A将CountDownLatch的计数器初始化为n <code>new CountDownLatch(n)</code> ，做完该做的事情后，就<code>countDownLatch.await()</code></li><li>每当一个任务线程执行完毕，就将计数器减1 <code>countdownlatch.countDown()</code></li><li>当计数器的值变为0时，在CountDownLatch上 <code>await()</code> 的线程就会被唤醒。</li><li>一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" 运行"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"等待子线程运行结束"</span>);</span><br><span class="line">        latch.await(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(<span class="string">"子线程运行结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>CountDownLatch典型用法2：实现多个任务线程阻塞后同时执行</strong></p><ul><li>类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。</li><li>做法是主线程A初始化一个共享的CountDownLatch(1)，将其计数器初始化为1</li><li>多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code> 时，计数器变为0，多个线程同时被唤醒。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch await;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(CountDownLatch countDownLatch, CountDownLatch await)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        <span class="keyword">this</span>.await = await;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(<span class="string">"子线程"</span> +Thread.currentThread().getName()+ <span class="string">"处理自己事情"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            await.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        CountDownLatch await = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(countDownLatch, await)).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"主线程处理自己事情"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        System.out.println(<span class="string">"主线程处理结束"</span>);</span><br><span class="line">        await.await();</span><br><span class="line">        System.out.println(<span class="string">"子线程处理完毕啦"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>2.7.2.2、CyclicBarrier代码示例</strong></p><blockquote><p>以装箱打包为例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * CyclicBarrier 有两个构造方法 parties 总计数，runnable是 现在执行前先执行的方法</span></span><br><span class="line"><span class="comment">         * CyclicBarrier barrier = new CyclicBarrier(5);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"开始货物打包"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        ExecutorService executorPool = Executors.newCachedThreadPool();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * await提供了两个方法</span></span><br><span class="line"><span class="comment">         * 1、await()</span></span><br><span class="line"><span class="comment">         * 2、await(long timeout, TimeUnit unit) 超时写法，且需捕获异常 TimeOutException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            executorPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(num + <span class="string">"号货物，已准备好，等待打包"</span>);</span><br><span class="line">                    <span class="comment">//barrier2.await(2, TimeUnit.SECONDS);</span></span><br><span class="line">                    barrier.await();</span><br><span class="line">                    System.out.println(num + <span class="string">"号货物，打包完成"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorPool.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-7-3、CountedCompleter"><a href="#2-7-3、CountedCompleter" class="headerlink" title="2.7.3、CountedCompleter"></a>2.7.3、CountedCompleter</h3><p>第一次看CountedCompleter，并不好理解。建议大家先掌握Fork / Join机制的ForkJoinTask和ForkJoinPool的工作原理后，再增量的补充CountedCompleter的差异点。</p><p>简单来说，相比ForkJoinTask：</p><ul><li>ForkJoinTask需阻塞的等待子任务完成，CountedCompleter不需要。主子任务的执行无顺序依赖，遵守Count计数即可。</li><li>CountedCompleter对于所有子任务执行完毕的感知更为快速（比ForkJoinTask的join()方法要简单、高效），对于</li><li>对于子任务结果合并，提供机制支持：每个任务结束时调用tryComplete，内部调用onCompletion合并结果。（前提，子任务节点本身要记录计算结果）。合并逻辑onCompletion可自定义。<ul><li>即任务分解、计算、合并三者分离。</li></ul></li></ul><p><br></p><p>Java8的lambda并行流（findAny，mapReduce，foreach）就行基于Fork/Join框架实现的。CountedCompleter就是其中一个重要基类。</p><p><br></p><p><strong>CountedCompleter是怎么执行的</strong></p><p>ForkJoinPool会调用ForkJoinTask的doExec来执行任务，doExec方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ForkJoinPool.class</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">        <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//CountedCompleter重载了exec方法，内部就是调用CountedCompleter的compute方法</span></span><br><span class="line">                completed = exec();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (completed)</span><br><span class="line">                s = setCompletion(NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CountedCompleter.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样compute的逻辑就是任务的核心计算逻辑，会最终被pool调用</p><p><br></p><p><strong>CountedCompleter的运行过程</strong></p><p>我们把最开始new出来的任务称为根任务，根任务在执行过程中，又fork出2个子任务，子任务可能会fork出自己的子任务。一层层fork下去后，最终一定有一个任务是不会再fork的，这个任务称为叶子任务。整个任务体系就是一颗完全二叉树。</p><p>整个执行过程，最核心的属性是：</p><ul><li><p>pending：表示等待执行的任务</p></li><li><p>completer：表示任务的上级，即父任务</p></li></ul><p>核心方法是tryComplete：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  CountedCompleter&lt;?&gt; a = <span class="keyword">this</span>, s = a;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> c;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((c = a.pending) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//如果当前任务完成(pending==0),执行完当前任务的完成动作(onCompletion)，传递到父任务</span></span><br><span class="line">      a.onCompletion(s);</span><br><span class="line">      <span class="keyword">if</span> ((a = (s = a).completer) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        s.quietlyComplete();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前任务没有完成(pending!=0)，将pending-1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(a, PENDING, c, c - <span class="number">1</span>))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个执行过程如下图：</p><ul><li>每个子任务都尝试tryComplete()</li><li>叶子任务的pending = 0，所以Complete是成功的，调用onCompletion方法终结自己任务。并取它的父任务，对父任务的pending做减1操作。减1操作会有2种情况<ul><li>1、父任务减1后，父任务的pending仍大于0，那么就不做任何事，结束了</li><li>2、父任务建1后，父任务的pending等于0了，那么会继续取父任务的父任务进行减1操作，一直往上递归。</li></ul></li></ul><p><img src="/2020/11/15/一文就明白并发编程/image-20201108150856864.png" alt="image-20201108150856864"></p><p><br></p><p><strong>代码示例</strong></p><blockquote><p>另外可参看官方举例：<a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/CountedCompleter.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/CountedCompleter.html</a></p></blockquote><ul><li>foreach型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountedCompleterDemo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Applier</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(E e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEach</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">CountedCompleter</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(E[] array, Applier&lt;E&gt; op)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> ForEach&lt;&gt;(<span class="keyword">null</span>, array, op, <span class="number">0</span>, array.length).invoke();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> E[] array;</span><br><span class="line">        <span class="keyword">final</span> Applier&lt;E&gt; op;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lo, hi;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//p是父任务</span></span><br><span class="line">        ForEach(CountedCompleter&lt;?&gt; p, E[] array, Applier&lt;E&gt; op, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">            <span class="keyword">super</span>(p);</span><br><span class="line">            <span class="keyword">this</span>.array = array;</span><br><span class="line">            <span class="keyword">this</span>.op = op;</span><br><span class="line">            <span class="keyword">this</span>.lo = lo;</span><br><span class="line">            <span class="keyword">this</span>.hi = hi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (hi - lo &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                setPendingCount(<span class="number">2</span>); <span class="comment">// must set pending count before fork</span></span><br><span class="line">                <span class="keyword">new</span> ForEach(<span class="keyword">this</span>, array, op, mid, hi).fork(); <span class="comment">// right child</span></span><br><span class="line">                <span class="keyword">new</span> ForEach(<span class="keyword">this</span>, array, op, lo, mid).fork(); <span class="comment">// left child</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hi &gt; lo)&#123;</span><br><span class="line">                op.apply(array[lo]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//compute返回前，必然调tryComplete</span></span><br><span class="line">            tryComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AtomicInteger sum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="comment">//自定义狗子方法就是是(element)-&gt;&#123;&#125; 这个函数式方法</span></span><br><span class="line">        ForEach.forEach(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, (element) -&gt; &#123;</span><br><span class="line">            sum.addAndGet(element);</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">"相加之和："</span> + sum.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>find one 型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearcherDemoTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSearchDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Integer[] array = <span class="keyword">new</span> Integer[<span class="number">10000000</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            array[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        AtomicReference&lt;Integer&gt; result = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        Integer find = <span class="keyword">new</span> SearcherDemoTest.Searcher&lt;&gt;(<span class="keyword">null</span>, array, result, <span class="number">0</span>, array.length - <span class="number">1</span>, <span class="keyword">this</span>::match).invoke();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"查找结束，结果返回：%d, result:%d"</span>, find, result.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Searcher</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">CountedCompleter</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> E[] array;</span><br><span class="line">        <span class="keyword">final</span> AtomicReference&lt;E&gt; result;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lo, hi;</span><br><span class="line">        <span class="keyword">final</span> Function&lt;E, Boolean&gt; matcher;</span><br><span class="line"></span><br><span class="line">        Searcher(CountedCompleter&lt;?&gt; p, E[] array, AtomicReference&lt;E&gt; result, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Function&lt;E, Boolean&gt; matcher)&#123;</span><br><span class="line">            <span class="keyword">super</span>(p);</span><br><span class="line">            <span class="keyword">this</span>.array = array;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">            <span class="keyword">this</span>.lo = lo;</span><br><span class="line">            <span class="keyword">this</span>.hi = hi;</span><br><span class="line">            <span class="keyword">this</span>.matcher = matcher;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="keyword">this</span>.lo;</span><br><span class="line">            <span class="keyword">int</span> h = <span class="keyword">this</span>.hi;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (result.get() == <span class="keyword">null</span> &amp;&amp; h &gt;= l)&#123;</span><br><span class="line">                <span class="keyword">if</span> ((h - l) &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + h) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    addToPendingCount(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">new</span> SearcherDemoTest.Searcher&lt;E&gt;(<span class="keyword">this</span>, array, result, mid, h, matcher).fork();</span><br><span class="line">                    h = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    E x = array[l];</span><br><span class="line">                    <span class="keyword">if</span> (matcher.apply(x) &amp;&amp; result.compareAndSet(<span class="keyword">null</span>, x))&#123;</span><br><span class="line">                        <span class="keyword">super</span>.quietlyCompleteRoot();</span><br><span class="line">                    &#125;</span><br><span class="line">             </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == result.get())&#123;</span><br><span class="line">                tryComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Integer x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> matchResult = x &gt; <span class="number">2000000</span> &amp;&amp; x%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; x%<span class="number">3</span> == <span class="number">0</span> &amp;&amp; x%<span class="number">5</span> == <span class="number">0</span> &amp;&amp; x%<span class="number">7</span> == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> matchResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h1 id="3、CAS"><a href="#3、CAS" class="headerlink" title="3、CAS"></a>3、CAS</h1><p>学锁之前，必须先学CAS</p><p><br></p><h2 id="3-1-1、CAS原理"><a href="#3-1-1、CAS原理" class="headerlink" title="3.1.1、CAS原理"></a>3.1.1、CAS原理</h2><p>CAS操作在操作系统层面对应C语言汇编的CMPXCHG指令，该指令通过三个操作数（变量V，预期旧值O，目标新值N），能原子的完成“变量V当前值与预期旧值E的等值判断，并完成新值N的赋值”。</p><p><br></p><p>所有Atomic类内部都会调用Unsafe类完成CAS的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p>Unsafe内部就是C语言实现与操作系统的交互了，最终会涉及到CPU级的操作。</p><p><br></p><p><strong>CMPXCHG指令介绍</strong></p><p>Unsafe的CompareAndSwap方法最终在 <strong>hotspot</strong> 源码实现中都会调用统一的 cmpxchg 函数。</p><p><strong>cmpxchg 函数源码</strong>：</p><p>源码地址：<code>hotspot/src/share/vm/runtime/Atomic.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">jbyte Atomic::cmpxchg(jbyte exchange_value, <span class="keyword">volatile</span> jbyte*dest, jbyte compare_value) &#123;</span><br><span class="line"> assert (<span class="keyword">sizeof</span>(jbyte) == <span class="number">1</span>,<span class="string">"assumption."</span>);</span><br><span class="line"> <span class="keyword">uintptr_t</span> dest_addr = (<span class="keyword">uintptr_t</span>) dest;</span><br><span class="line"> <span class="keyword">uintptr_t</span> offset = dest_addr % <span class="keyword">sizeof</span>(jint);</span><br><span class="line"> <span class="keyword">volatile</span> jint*dest_int = ( <span class="keyword">volatile</span> jint*)(dest_addr - offset);</span><br><span class="line"> <span class="comment">// 对象当前值</span></span><br><span class="line"> jint cur = *dest_int;</span><br><span class="line"> <span class="comment">// 当前值cur的地址</span></span><br><span class="line"> jbyte * cur_as_bytes = (jbyte *) ( &amp; cur);</span><br><span class="line"> <span class="comment">// new_val地址</span></span><br><span class="line"> jint new_val = cur;</span><br><span class="line"> jbyte * new_val_as_bytes = (jbyte *) ( &amp; new_val);</span><br><span class="line">  <span class="comment">// new_val存exchange_value，后面修改则直接从new_val中取值</span></span><br><span class="line"> new_val_as_bytes[offset] = exchange_value;</span><br><span class="line"> <span class="comment">// 比较当前值与期望值，如果相同则更新，不同则直接返回</span></span><br><span class="line"> <span class="keyword">while</span> (cur_as_bytes[offset] == compare_value) &#123;</span><br><span class="line">  <span class="comment">// 调用汇编指令cmpxchg执行CAS操作，期望值为cur，更新值为new_val</span></span><br><span class="line"> jint res = cmpxchg(new_val, dest_int, cur);</span><br><span class="line"> <span class="keyword">if</span> (res == cur) <span class="keyword">break</span>;</span><br><span class="line"> cur = res;</span><br><span class="line"> new_val = cur;</span><br><span class="line"> new_val_as_bytes[offset] = exchange_value;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 返回当前值</span></span><br><span class="line"> <span class="keyword">return</span> cur_as_bytes[offset];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>多CPU如何实现原子操作</strong></p><p><img src="/2020/11/15/一文就明白并发编程/image-20201109223114311.png" alt="image-20201109223114311"></p><p>在计算机硬件层面，CPU 处理器速度远远大于主内存，为了解决速度差异，在两者之间架设了CPU多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离CPU越近就越快，将频繁操作的数据缓存到这里，加快访问速度。</p><p>现在都是多核 CPU 处理器，每个 CPU 处理器内维护各自关于内存数据的缓存，当多线程并发读写时，就会出现CPU缓存数据不一致的情况。</p><p><strong>对于原子操作，CPU处理器提供2种方式：</strong></p><ul><li><strong>总线锁定</strong></li></ul><p>当一个处理器要操作共享变量时，在 BUS 总线上发出一个 Lock 信号，其他处理就无法操作这个共享变量了。</p><p>缺点很明显，总线锁定在阻塞其它处理器获取该共享变量的操作请求时，也可能会导致大量阻塞，从而增加系统的性能开销。</p><ul><li><strong>缓存锁定 </strong></li></ul><p>后来的处理器都提供了缓存锁定机制，当某个处理器对缓存中的共享变量进行了操作，其他处理器会有个嗅探机制，将其他处理器的该共享变量的缓存失效，待其他线程读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现的。</p><p>现代的处理器基本都支持和使用的缓存锁定机制。</p><p><br></p><p><strong>那若遇到V的值不等于A，怎么办？</strong></p><p>答：自旋循环</p><p>一般CAS的代码逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  current_value = get();</span><br><span class="line">  new_value = <span class="keyword">do</span> something/nothing with current_value</span><br><span class="line">  <span class="keyword">if</span> (compareAndSet(current_value, new_value))&#123;</span><br><span class="line">      <span class="keyword">return</span> new_value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若长时间不成功，CPU开销很大哦。</p><p><br></p><h2 id="3-1-2、ABA问题"><a href="#3-1-2、ABA问题" class="headerlink" title="3.1.2、ABA问题"></a>3.1.2、ABA问题</h2><p><strong>ABA问题：</strong></p><p>CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。</p><p><strong>解决思路：</strong></p><ul><li><p>ABA问题的解决思路就是在value中添加版本号。例如：每次变量更新的时候都把版本号加1，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p></li><li><p>JDK从1.5开始提供了AtomicStampedReference（也是版本号思路）类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</p></li></ul><p><br></p><h2 id="3-1-3、原子性操作多个变量操作"><a href="#3-1-3、原子性操作多个变量操作" class="headerlink" title="3.1.3、原子性操作多个变量操作"></a>3.1.3、原子性操作多个变量操作</h2><p>虽然原理很简单，但值得单列一章节</p><p><br></p><p>常规的Atomic原子变量，只能保证单个变量的原子性操作。但对于多个变量原子性操作的场景怎么应对呢？</p><p>答案：</p><ul><li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li></ul><p><br></p><p><strong>举例：</strong></p><p><strong>如果使用普通的对象引用，在多线程情况下进行对象的更新可能会导致不一致性。例如：</strong><br> 一个对象的初始状态为 <code>name=Tom, age = 18</code>。<br> 在 线程1 中将 <code>name</code> 修改为 <code>Tom1</code>，<code>age + 1</code>。<br> 在 线程2 中将 <code>name</code> 修改为 <code>Tom2</code>，<code>age + 2</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//省去get/set方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[name: "</span> + <span class="keyword">this</span>.name + <span class="string">", age: "</span> + <span class="keyword">this</span>.age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>普通引用版本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Person is "</span> + person.toString());</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task1());</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task2());</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Now Person is "</span> + person.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setAge(person.getAge() + <span class="number">1</span>);</span><br><span class="line">        person.setName(<span class="string">"Tom1"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread1 Values "</span> + person.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setAge(person.getAge() + <span class="number">2</span>);</span><br><span class="line">        person.setName(<span class="string">"Tom2"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread2 Values "</span> + person.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能的结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person is [name: Tom, age: 18]</span><br><span class="line">Thread2 Values [name: Tom1, age: 21]</span><br><span class="line">Thread1 Values [name: Tom1, age: 21]</span><br><span class="line">Now Person is [name: Tom1, age: 21]</span><br></pre></td></tr></table></figure><p><br></p><ul><li>原子对象引用版本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Person person;</span><br><span class="line"><span class="comment">// 原子性引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Person&gt; aRperson;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">18</span>);</span><br><span class="line">    aRperson = <span class="keyword">new</span> AtomicReference&lt;Person&gt;(person);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Atomic Person is "</span> + aRperson.get().toString());</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task1());</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task2());</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Now Atomic Person is "</span> + aRperson.get().toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        aRperson.getAndSet(<span class="keyword">new</span> Person(<span class="string">"Tom1"</span>, aRperson.get().getAge() + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread1 Atomic References "</span> + aRperson.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        aRperson.getAndSet(<span class="keyword">new</span> Person(<span class="string">"Tom2"</span>, aRperson.get().getAge() + <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread2 Atomic References "</span> + aRperson.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="4、Java中的锁"><a href="#4、Java中的锁" class="headerlink" title="4、Java中的锁"></a>4、Java中的锁</h1><h2 id="4-1、那些“锁”的分类"><a href="#4-1、那些“锁”的分类" class="headerlink" title="4.1、那些“锁”的分类"></a>4.1、那些“锁”的分类</h2><p>如上文所述，Java中提供了种类丰富的锁，每种锁各有特性和适用的场景。</p><p>Java中的是根据其是否表现为某一特性来定义锁，下图是一张很棒的分类图：</p><p><img src="/2020/11/15/一文就明白并发编程/image-20201019195525424.png" alt="image-20201019195525424"></p><p>故，我们能得到Java中常见的锁分类名称：</p><ul><li>悲观锁 vs 乐观锁</li><li>自旋锁</li><li>偏向锁 vs 轻量级锁 vs 重量级锁</li><li>公平锁 vs 非公平锁</li><li>可重入锁</li><li>排他锁 vs 共享锁</li></ul><h2 id="4-2、乐观锁-vs-悲观锁"><a href="#4-2、乐观锁-vs-悲观锁" class="headerlink" title="4.2、乐观锁 vs 悲观锁"></a>4.2、乐观锁 vs 悲观锁</h2><p>乐观锁与悲观锁是一种线程并发竞争资源的态度和策略。</p><p>对于同一个临界数据的并发操作：</p><ul><li><strong>悲观锁</strong>  认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</li><li><strong>乐观锁</strong>  认为自己在使用数据时比较小概率会有其他线程并发修改数据，所以不添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。<ul><li>乐观锁在Java中是通过使用无锁编程来实现的，最常采用的是CAS算法。</li></ul></li></ul><p><img src="/2020/11/15/一文就明白并发编程/image-20201019201029599.png" alt="image-20201019201029599"></p><p>根据从上面两者的特点我们可以发现：</p><ul><li><strong>悲观锁适合写操作多</strong>的场景，先加锁可以保证写操作时数据正确。</li><li><strong>乐观锁适合读操作多</strong>的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><p><br></p><h2 id="4-3、自旋锁-vs-适应性自旋锁"><a href="#4-3、自旋锁-vs-适应性自旋锁" class="headerlink" title="4.3、自旋锁 vs 适应性自旋锁"></a>4.3、自旋锁 vs 适应性自旋锁</h2><p>在介绍自旋锁前，需要先铺垫一点前提知识：</p><ul><li><strong>阻塞或唤醒一个Java线程</strong>需要操作系统切换CPU状态来完成，这种状态转换需要<strong>耗费CPU时间</strong>。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</li><li><p>在许多场景中，<strong>同步资源的锁定时间很短</strong>，为了这一小段时间去切换线程，<strong>线程挂起和恢复现场的花费可能会让系统得不偿失</strong>。如果物理机有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p></li><li><p>而为了让当前线程“稍等一下”，我们需让当前线程进行<strong>自旋</strong>，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。</p></li><li>这就是自旋锁。</li></ul><p><img src="/2020/11/15/一文就明白并发编程/452a3363.png" alt="img"></p><p><strong>注意：</strong></p><p>自旋等待虽然避免了线程切换的开销，但它要占着CPU。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，那么自旋的线程只会白浪费处理器资源。</p><p>所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p><br></p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p><img src="/2020/11/15/一文就明白并发编程/83b3f85e.png" alt="img"></p><p><br></p><p><strong>自适应自旋锁</strong></p><p>自旋锁在JDK1.4中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><ul><li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。</li><li>如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</li></ul><p><br></p><h2 id="4-4、偏向锁-vs-轻量级锁-vs-重量级锁"><a href="#4-4、偏向锁-vs-轻量级锁-vs-重量级锁" class="headerlink" title="4.4、偏向锁 vs 轻量级锁 vs 重量级锁"></a>4.4、偏向锁 vs 轻量级锁 vs 重量级锁</h2><p>这四种锁是指<strong>锁的状态</strong>，专门针对synchronized的。</p><p><br></p><p>按照惯例，在介绍这四种锁状态之前需要介绍一些额外的知识铺垫。</p><p><br></p><h3 id="4-4-1、为什么Synchronized能实现线程同步"><a href="#4-4-1、为什么Synchronized能实现线程同步" class="headerlink" title="4.4.1、为什么Synchronized能实现线程同步"></a>4.4.1、为什么Synchronized能实现线程同步</h3><p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><p><br></p><p><strong>【Java对象头】</strong> —— 放锁的</p><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就存在Java对象头里的，那Java对象头又是什么呢？</p><p>以Hotspot为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><ul><li><p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以<strong>Mark Word</strong>被设计成一个非固定的数据结构以便在极小的空间内存<strong>存储</strong>尽量多的<strong>数据</strong>。它会根据对象的状态复用自己的存储空间，也就是说在<strong>运行期间</strong>Mark Word里存储的数据会随着锁标志位的变化而<strong>变化</strong>。</p></li><li><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p></li></ul><p><br></p><p><strong>【Monitor】</strong> —— 实现线程间同步</p><p> Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象，主要特点是：</p><ul><li>Monitor对象的所有方法都被“互斥”的执行。好比一个Monitor只有一个运行“许可”，任一个线程进入任何一个方法都需要获得这个“许可”，离开时把许可归还。</li><li><p>通常提供singal机制：允许正持有“许可”的线程暂时放弃“许可”，等待某个谓词成真（条件变量），而条件成立后，当前进程可以“通知”正在等待这个条件变量的线程，让他可以重新去获得运行许可。</p></li><li><p>Monitor对象可以被多线程安全地访问。</p></li></ul><p><br></p><p>重点：<strong>synchronized通过Monitor来实现线程同步</strong>。Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><blockquote><p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。</p><p>这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。</p><p>这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。</p><p>JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p></blockquote><p><br></p><p>所以目前synchronized一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p><p><br></p><p>四种锁状态对应的的Mark Word内容：</p><table><thead><tr><th style="text-align:left">锁状态</th><th style="text-align:left">存储内容</th><th style="text-align:left">存储内容</th></tr></thead><tbody><tr><td style="text-align:left">无锁</td><td style="text-align:left">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td style="text-align:left">01</td></tr><tr><td style="text-align:left">偏向锁</td><td style="text-align:left">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td style="text-align:left">01</td></tr><tr><td style="text-align:left">轻量级锁</td><td style="text-align:left">指向栈中锁记录的指针</td><td style="text-align:left">00</td></tr><tr><td style="text-align:left">重量级锁</td><td style="text-align:left">指向互斥量（重量级锁）的指针</td><td style="text-align:left">10</td></tr></tbody></table><p><br></p><p>通过上面对synchronized的加锁机制以及相关知识的铺垫，下面我们分别讲解四种锁状态的思路以及特点：</p><p><br></p><h3 id="4-4-2、JDK1-6对synchronized的优化"><a href="#4-4-2、JDK1-6对synchronized的优化" class="headerlink" title="4.4.2、JDK1.6对synchronized的优化"></a>4.4.2、JDK1.6对synchronized的优化</h3><p>JDK1.6中对synchronized的实现引入了大量的优化来减少锁操作的开销：</p><ul><li><p><strong>锁粗化（Lock Coarsening）</strong>：将多个连续的锁扩展成一个范围更大的锁，用以减少频繁互斥同步导致的性能损耗。</p></li><li><p><strong>锁消除（Lock Elimination）</strong>：JVM及时编译器在运行时，通过逃逸分析，如果判断一段代码中，堆上的所有数据不会逃逸出去从来被其他线程访问到，就可以去除这些锁。</p></li><li><p><strong>偏向锁（Biased Locking）</strong>：JDK1.6引入。目的是消除数据再无竞争情况下的同步原语。使用CAS记录获取它的线程。下一次同一个线程进入则偏向该线程，无需任何同步操作。</p></li><li><p><strong>轻量级锁（Lightweight Locking）</strong>：JDK1.6引入。在没有多线程竞争的情况下避免重量级互斥锁，只需要依靠一条CAS原子指令就可以完成锁的获取及释放。</p></li><li><p><strong>适应性自旋（Adaptive Spinning）</strong>：为了避免线程频繁挂起、恢复的状态切换消耗。产生了忙循环（循环时间固定），即自旋。JDK1.6引入了自适应自旋。自旋时间根据之前锁自旋时间和线程状态，动态变化，用以期望能减少阻塞的时间。</p><p><br></p></li></ul><p><strong>锁升级</strong>：偏向锁–》轻量级锁–》重量级锁</p><p><br></p><h3 id="4-4-3、无锁"><a href="#4-4-3、无锁" class="headerlink" title="4.4.3、无锁"></a>4.4.3、无锁</h3><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，<strong>但同时只有一个线程能修改成功</strong>。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。</p><p>如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</p><p>上面我们介绍的CAS原理及应用即是无锁的一种实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><p><br></p><h3 id="4-4-4、偏向锁"><a href="#4-4-4、偏向锁" class="headerlink" title="4.4.4、偏向锁"></a>4.4.4、偏向锁</h3><p>为了优化synchronized的性能，Hotspot的作者经过研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p><p><br></p><p>当一个线程访问同步块并获取锁时，会在对象头的Mark Word里<strong>记录锁偏向的线程ID</strong>，以后该线程在进入和退出同步块时<strong>不需要花费CAS操作来加锁和解锁</strong>，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><p><br></p><p><strong>偏向锁的撤销</strong>：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p><ul><li>偏向锁的撤销，<strong>需要等待全局安全点</strong>（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着<ul><li>如果线程不处于活动状态，则将对象头设置成无锁状态，</li><li>如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象<strong>不适合作为偏向锁，进而使用轻量级锁</strong>，最后唤醒暂停的线程。</li></ul></li></ul><p><br></p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><p><br></p><h3 id="4-4-5、轻量级锁"><a href="#4-4-5、轻量级锁" class="headerlink" title="4.4.5、轻量级锁"></a>4.4.5、轻量级锁</h3><blockquote><p>当锁是偏向锁的时，被另外的线程所访问，偏向锁就会升级为轻量级锁。其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而（不切换CPU）提高性能。</p></blockquote><p><br></p><p><strong>轻量级锁-加锁：</strong></p><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录（Lock Record）的空间，并将对象头中的Mark Word复制到锁记录中（官方称为Displaced Mark Word）。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。</p><ul><li>【加锁成功】如果成功，当前线程获得锁</li><li>【加锁失败】如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。<strong>而当自旋一定条件后还未获得锁，这个竞争线程就会把对象的锁状态改成“重量级锁”</strong>。</li></ul><p><br></p><p><strong>轻量级锁-解锁：</strong></p><p>轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，<strong>锁就会膨胀成重量级锁</strong>。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p><p><br></p><p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p><p><img src="/2020/11/15/一文就明白并发编程/584866-20170419191951321-2145960409.png" alt="img"></p><p>如上图所示，加锁和锁升级逻辑：</p><ul><li>第二步，如果Mark Word不是自己的ThreadId,锁升级，这时候，<strong>用CAS来执行切换</strong>，新的线程根据Mark Word里面现有的ThreadId，通知之前线程暂停，之前线程将Mark Word的内容置为空。</li><li>第三步，两个线程都把对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始<strong>通过CAS</strong>操作，把共享对象的Mark Word的内容修改为自己新建的记录空间的地址的方式<strong>竞争Mark Word</strong>.</li><li>第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋.</li><li>第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于轻量级锁的状态，如果<strong>自旋失败</strong>进入第六步</li><li>第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己.</li></ul><p><br></p><h3 id="4-4-6、重量级锁"><a href="#4-4-6、重量级锁" class="headerlink" title="4.4.6、重量级锁"></a>4.4.6、重量级锁</h3><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><p><br></p><p>重量级锁通过对象内部的Monitor实现（上文有铺垫），其中Monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p><p><br></p><h3 id="4-4-7、综上"><a href="#4-4-7、综上" class="headerlink" title="4.4.7、综上"></a>4.4.7、综上</h3><p>JVM对Synchronized的优化，简单来说解决三种场景：</p><p>1）只有一个线程进入临界区：偏向锁。</p><blockquote><p>通过test Mark Word解决加锁问题，无需执行CAS操作</p></blockquote><p>2）多个线程交替进入临界区：轻量级锁。</p><blockquote><p>通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能</p></blockquote><p>3）多线程同时进入临界区：重量级锁</p><p><br></p><h2 id="4-5、公平锁-vs-非公平锁"><a href="#4-5、公平锁-vs-非公平锁" class="headerlink" title="4.5、公平锁 vs 非公平锁"></a>4.5、公平锁 vs 非公平锁</h2><p><strong>公平锁</strong></p><p>公平锁是指多个线程按照申请锁的顺序逐序获取到锁</p><ul><li>原理：暂未获取到锁的线程直接进入队列（FIFO）中排队，然后按排队顺序逐个传递着获取到锁。</li><li>优点：等待锁的线程不会饿死。</li><li>缺点：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</li></ul><p><br></p><p><strong>非公平锁</strong></p><p>非公平锁是多个线程加锁时直接尝试竞争获取锁，若获取到锁，此线程可以无需阻塞直接执行同步代码，获取不到锁时会到等待队列（FIFO）的队尾等待。</p><ul><li><p>优点：因为部分节省CPU切换的损耗，相比公平锁吞吐量较好。</p></li><li><p>缺点：处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p></li></ul><p><br></p><blockquote><p>关于等待队列，回忆下前文介绍的JUC中的AQS机制（AbstractQueuedSynchronizer），就是它提供的实现</p></blockquote><p><br></p><p>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。</p><p><img src="/2020/11/15/一文就明白并发编程/6edea205.png" alt="img"></p><p>ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。</p><p>它有公平锁FairSync和非公平锁NonfairSync两个子类。</p><p><strong>ReentrantLock默认使用非公平锁</strong>，也可以通过构造器来显示的指定使用公平锁。</p><p><br></p><p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p><p><img src="/2020/11/15/一文就明白并发编程/bc6fe583.png" alt="img"></p><p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p><p><img src="/2020/11/15/一文就明白并发编程/bd0036bb.png" alt="img"></p><p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p><p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p><p><br></p><h2 id="4-6、独享锁-排他锁-vs-共享锁"><a href="#4-6、独享锁-排他锁-vs-共享锁" class="headerlink" title="4.6、独享锁(排他锁) vs 共享锁"></a>4.6、独享锁(排他锁) vs 共享锁</h2><p><strong>独享锁</strong>也叫排他锁，是指该锁一次只能被一个线程所持有。获得排它锁的线程<strong>即能读数据又能修改数据</strong>。</p><ul><li>JDK中的synchronized、JUC中Lock的都是独享锁。</li></ul><p><br></p><p><strong>共享锁</strong>是指该锁可被多个线程所持有。获得共享锁的线程只能读数据，不能修改数据。</p><p><br></p><p><strong>独享锁与共享锁也是通过AQS来实现的</strong>，通过实现不同的方法，来实现独享或者共享。</p><p>下图为ReentrantReadWriteLock的部分源码：</p><p><img src="/2020/11/15/一文就明白并发编程/762a042b.png" alt="img"></p><p><br></p><ul><li><p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p></li><li><p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。因为读锁和写锁是分离的，更细粒度的控制，使得ReentrantReadWriteLock的并发性相比一般的独享锁有了很大提升。</p></li></ul><p><br></p><p>那读锁和写锁的具体加锁方式有什么区别呢？</p><ul><li><p>在上文AQS提及的state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p></li><li><p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数）</p></li><li>在共享锁中state就是持有锁的数量。</li><li>但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量，于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</li></ul><p><img src="/2020/11/15/一文就明白并发编程/8793e00a.png" alt="img"></p><p>了解了概念之后我们再来看代码</p><p>先看写锁的加锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line"><span class="keyword">int</span> c = getState(); <span class="comment">// 取到当前锁的个数</span></span><br><span class="line"><span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 取写锁的个数w</span></span><br><span class="line"><span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">    <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"><span class="comment">// Reentrant acquire</span></span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">setExclusiveOwnerThread(current); <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li><li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li><li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li><li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li><li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li></ul><p><br></p><p>接着是读锁的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                   <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。</li><li>如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</li></ul><p><br></p><h2 id="4-7、锁消除"><a href="#4-7、锁消除" class="headerlink" title="4.7、锁消除"></a>4.7、锁消除</h2><p>JVM会加锁的代码进行逃逸分析，当发现是单线程时，会去掉代码所加的锁，以达到优化的目的。</p><p>synchronized采取了此策略。</p><p><br></p><h1 id="5、多线程场景编码"><a href="#5、多线程场景编码" class="headerlink" title="5、多线程场景编码"></a>5、多线程场景编码</h1><h2 id="5-1、常见线程创建写法"><a href="#5-1、常见线程创建写法" class="headerlink" title="5.1、常见线程创建写法"></a>5.1、常见线程创建写法</h2><p><strong>5.1.1、（推荐）利用ThreadPoolExecutor</strong></p><blockquote><p>使用ThreadPoolExecutor，按具体场景细细琢磨下线程池的各个参数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoThreadPoolExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//细细琢磨下各个参数设置</span></span><br><span class="line">    ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">20</span>),</span><br><span class="line">            (<span class="keyword">new</span> ThreadFactoryBuilder()).setNameFormat(<span class="string">"child-request-thread-%d"</span>).build(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)&#123;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 注意点：</span></span><br><span class="line">            <span class="comment">//1、execute里是个Runable方法，简单的可以这么函数式的写。复杂的就单独实现Runnable类。</span></span><br><span class="line">            <span class="comment">//2、execute负责将任务提交到队列，就返回了</span></span><br><span class="line">            System.out.println(<span class="string">"线程名："</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"关闭线程池"</span>);</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">1</span></span><br><span class="line">线程名：child-request-thread-<span class="number">2</span></span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">2</span></span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">1</span></span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">2</span>    《《《 CorePoolSize 是<span class="number">3</span>个</span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">1</span></span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">2</span></span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">4</span>    《《《 当队列满了后，增加线程到MaxPoolSize5个</span><br><span class="line">线程名：child-request-thread-<span class="number">1</span></span><br><span class="line">线程名：child-request-thread-<span class="number">3</span></span><br><span class="line">线程名：child-request-thread-<span class="number">1</span></span><br><span class="line">线程名：child-request-thread-<span class="number">4</span></span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：main                      《《《队列满了，线程最大了，还有任务进来，采取的是CallerRun策略</span><br><span class="line">线程名：child-request-thread-<span class="number">2</span></span><br><span class="line">线程名：main</span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">4</span></span><br><span class="line">线程名：child-request-thread-<span class="number">1</span></span><br><span class="line">线程名：child-request-thread-<span class="number">3</span></span><br><span class="line">线程名：child-request-thread-<span class="number">3</span></span><br><span class="line">线程名：child-request-thread-<span class="number">1</span></span><br><span class="line">线程名：child-request-thread-<span class="number">4</span></span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">关闭线程池</span><br><span class="line">线程名：child-request-thread-<span class="number">2</span></span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">4</span></span><br><span class="line">线程名：child-request-thread-<span class="number">1</span></span><br><span class="line">线程名：child-request-thread-<span class="number">3</span></span><br><span class="line">线程名：child-request-thread-<span class="number">1</span></span><br><span class="line">线程名：child-request-thread-<span class="number">4</span></span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">2</span></span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">4</span></span><br><span class="line">线程名：child-request-thread-<span class="number">1</span></span><br><span class="line">线程名：child-request-thread-<span class="number">3</span></span><br><span class="line">线程名：child-request-thread-<span class="number">1</span></span><br><span class="line">线程名：child-request-thread-<span class="number">4</span></span><br><span class="line">线程名：child-request-thread-<span class="number">0</span></span><br><span class="line">线程名：child-request-thread-<span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>ThreadFactoryBuilder 用的是google guava的实现类</li></ul><p><br></p><p><strong>5.1.2、利用Executors</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// 注意点：</span></span><br><span class="line">            <span class="comment">//1、execute里是个Runable方法，简单的可以这么函数式的写。复杂的就单独实现Runnable类。</span></span><br><span class="line">            <span class="comment">//2、execute负责将任务提交到队列，就返回了</span></span><br><span class="line">            fixedThreadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程名："</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"关闭线程池"</span>);</span><br><span class="line">        <span class="comment">//shutdown()方法解释</span></span><br><span class="line">        <span class="comment">//1、不会立即结束，当方法返回时并不一定真的完全关闭了</span></span><br><span class="line">        <span class="comment">//2、此时不再接收新任务</span></span><br><span class="line">        <span class="comment">//3、尝试关闭线程，但仅会关闭1个。当shutdown返回后，线程池里可能还会存在worker</span></span><br><span class="line">        fixedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">线程名：pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">关闭线程池               《《《 这个就是shutdown()方法特点的证明</span><br><span class="line">线程名：pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">线程名：pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">线程名：pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">线程名：pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">线程名：pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">线程名：pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">线程名：pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">线程名：pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">线程名：pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>其他Executors类里的<code>newSingleThreadExecutor</code>、<code>newCachedThreadPool</code>、<code>newScheduledThread</code>，写法都一样。</li></ul><p><br></p><h2 id="5-2、等待所有线程结束-优雅关闭线程池"><a href="#5-2、等待所有线程结束-优雅关闭线程池" class="headerlink" title="5.2、等待所有线程结束 / 优雅关闭线程池"></a>5.2、等待所有线程结束 / 优雅关闭线程池</h2><p><strong>经典关闭线程池代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">executorService.shutdown();</span><br><span class="line"><span class="keyword">while</span> (!executorService.awaitTermination(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"线程池中还有任务在处理"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><u>结论：【重点】【重点】【重点】shutdown()只会尝试终止1个worker，方法就返回了。当执行shutdown()时，线程池里有多个worker时，待shutdown()返回时，其实线程池里还是有worker在运行着。</u></strong></p><p><br></p><p>为什么shutdown()不够？</p><ul><li><strong>看看shutdown做了什么</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 线程安全性检查</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 更新线程池状态为 SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 尝试关闭空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 空实现</span></span><br><span class="line">        onShutdown();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试中止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>tryTerminate 做了什么？</strong></li></ul><p>这个只是尝试将线程池的状态置为 <code>TERMINATE</code> 态，如果还有worker在执行，则尝试关闭一个worker。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">void</span> tryTerminate() &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) || <span class="comment">// 是运行态</span></span><br><span class="line">            runStateAtLeast(c, TIDYING) ||  <span class="comment">// 是 TIDYING 或者 TERMINATE 态</span></span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) <span class="comment">// SHUTDOWN 态且队列中有任务</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还存在 worker，则尝试关闭一个worker</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过CAS，先置为 TIDYING 态</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// TIDYING 态</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 空方法</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 最终更新为 TERMINATED 态</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如下的方法简单做一些过滤。因为状态是从 TIDYING 态往后才到 TERMINATE 态。从这个过滤条件，可以看出如果是STOP态也是会通过的。不过如果线程池到了STOP应该就不会再使用了吧，所以也是不会有什么影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRunning(c) || <span class="comment">// 是运行态</span></span><br><span class="line">runStateAtLeast(c, TIDYING) ||  <span class="comment">// 是 TIDYING 或者 TERMINATE 态</span></span><br><span class="line">(runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) <span class="comment">// SHUTDOWN 态且队列中有任务</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>如果该线程池中有worker，则中止1个worker。通过上面的过滤条件，到了这一步，那么肯定是 SHUTDOWN 态（忽略 STOP 态），并且任务队列已经被处理完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 还存在 worker，则尝试关闭一个worker</span></span><br><span class="line">    interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>如果该线程池中有多个worker，终止1个worker之后 tryTerminate() 方法就返回了</em>，那么剩下的worker在哪里被处理的呢？（看后面的解答）</p><p>假设线程池中的worker都已经关闭并且队列中也没有任务，那么后面的代码将会将线程池状态置为 TERMINATE 态。<code>terminate()</code> 是空实现，用于有需要的自己实现处理，线程池关闭之后的逻辑。</p><p><br></p><ul><li><strong>awaitTermination 做了什么</strong></li></ul><p>这个方法只是判断当前线程池是否为 TERMINATED 态，如果不是则睡眠指定的时间，如果睡眠中途线程池变为终止态则会被唤醒。这个方法并不会处理线程池的状态变更的操作，纯粹是做状态的判断，所以得要在循环里边做判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public boolean awaitTermination(long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED)) <span class="comment">// 是否为 TERMINATED 态</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            nanos = termination.awaitNanos(nanos);  <span class="comment">// native 方法，睡一觉</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>问题</strong></p><p>从 shutdown() 方法源码来看有很大概率没有完全关闭线程池，而awaitTermination() 方法则只是判断线程池状态，并没有关闭线程池状态，那么剩下的worker什么时候促发关闭呢？</p><ul><li>关键代码逻辑在一个worker被关闭之后，触发了哪些事情。</li></ul><p><br></p><ul><li><strong>runWorker</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">void</span> runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    boolean completedAbruptly = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 省略其他不需要的代码</span></span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               task.run();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于标识是否是task.run报错</span></span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 线程关闭的时候调用</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>completedAbruptly</code>：用于标识是否是task.run报错，如果值为 TRUE，则是task.run 异常；反之，则没有发生异常</p><p>从上面的核心代码来看，当一个<strong>worker被关闭之后会调用 processWorkerExit()</strong> 方法。看看它做了什么。</p><ul><li><strong>processWorkerExit 做了什么</strong></li></ul><p>对一个worker退出之后做善后工作，比如统计完成任务数，将<strong><u>线程池的关闭态传播下去</u></strong>，根据条件补充 worker。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    final ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有worker则尝试关闭一个，否则置为TERMINATE态</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            int min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><strong>线程池关闭的关键就在于一个worker退出之后，会调用 <code>tryTerminate()</code> 方法，将退出的信号传递下去</strong></u>，这样其他的线程才能够被依次处理，最后线程池会变为 TERMINATE 态。</p><p><br></p><h2 id="5-3、获取线程执行结果"><a href="#5-3、获取线程执行结果" class="headerlink" title="5.3、获取线程执行结果"></a>5.3、获取线程执行结果</h2><h3 id="5-3-1、Callable-amp-Future"><a href="#5-3-1、Callable-amp-Future" class="headerlink" title="5.3.1、Callable &amp; Future"></a>5.3.1、Callable &amp; Future</h3><p>一个例子同时说明：Future、FutureTask、Callable</p><p><br></p><ul><li><p><strong>【Interface】Callable</strong>：与Runnable对比，具有返回值能力。</p></li><li><p><strong>【Interface】Future</strong>：与Callable搭配，是装线程返回结果的接口类，是个Interface。注意：future.get()是阻塞方法，直到对应的线程任务运行结束。</p></li><li><p><strong>【Class】FutureTask</strong>：Future Interface的实现类。</p></li></ul><p><img src="/2020/11/15/一文就明白并发编程/image-20201113160949846.png" alt="image-20201113160949846" style="zoom:50%;"></p><p>代码例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoCallable</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">20</span>),</span><br><span class="line">            (<span class="keyword">new</span> ThreadFactoryBuilder()).setNameFormat(<span class="string">"child-request-thread-%d"</span>).build(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交任务</span></span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//submit是异步提交</span></span><br><span class="line">        Future&lt;Integer&gt; result = threadPool.submit(<span class="keyword">new</span> IntegerCallable(i));</span><br><span class="line">        resultList.add(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待线程池执行完所有任务</span></span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    <span class="keyword">while</span> (!threadPool.awaitTermination(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        System.out.println(<span class="string">"线程池中还有任务在处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取执行完成的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resultList.size(); i++) &#123;</span><br><span class="line">        Future&lt;Integer&gt; result = resultList.get(i);</span><br><span class="line">        <span class="keyword">if</span> (result.isDone())&#123;</span><br><span class="line">            System.out.printf(<span class="string">"Task %d is done. value = %d \n"</span>, i, result.get());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"Task %d is not execute \n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="5-4、【重点】CompletableFuture"><a href="#5-4、【重点】CompletableFuture" class="headerlink" title="5.4、【重点】CompletableFuture"></a>5.4、【重点】CompletableFuture</h2><p>从Future模式的缺点说起：</p><ul><li>Future虽然可以实现获取异步执行结果的需求，但是它没有提供通知的机制，我们无法得知Future什么时候完成。</li><li>要么使用阻塞，在future.get()的地方等待future返回的结果，这时又变成同步操作。要么使用isDone()轮询地判断Future是否完成，这样会耗费CPU的资源。</li></ul><p><br></p><p>Java 8新增的<u>CompletableFuture类正是吸收了所有Google Guava中ListenableFuture和SettableFuture的特征</u>，还提供了其它强大的功能，让Java拥有了完整的非阻塞编程模型：Future、Promise 和 Callback(在Java8之前，只有无Callback 的Future)。</p><p>回调执行方面：</p><ul><li>CompletableFuture能将回调放到与主任务线程外的其他线程中异步的执行</li><li>CompletableFuture也能将回调放在主任务线程汇总继续同步的执行。</li><li>它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。</li></ul><p><strong>结果等待方面：</strong></p><ul><li>CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，无需等待。可以直接通过thenAccept、thenApply、thenCompose等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。</li></ul><p><br></p><p><strong>CompletableFuture</strong></p><p>处理非阻塞调用的传统方法是使用事件处理器，程序员为任务完成之后要出现的动作注册一个处理器。但是，要尝试在一组事件处理器中实现一个控制流会很困难。</p><p>CompletableFuture提供了一种候选方法，与事件处理器不同，CompletableFuture可以组合。利用CompletableFuture，可以指定希望做什么，以及希望以什么顺序执行这些工作。这些动作不会立即发生，不过重要的是将所有代码放在一起。</p><p>CompletableFuture提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合 CompletableFuture 的方法。</p><p>对于阻塞或者轮询方式，依然可以通过 CompletableFuture 类的 CompletionStage 和 Future 接口方式支持。</p><p>CompletableFuture 类声明了 CompletionStage 接口，CompletionStage 接口实际上提供了同步或异步运行计算的舞台，所以我们可以通过实现多个 CompletionStage 命令，并且将这些命令串联在一起的方式实现多个命令之间的触发。</p><p><br></p><p><strong>CompletableFuture的特性：</strong></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>runAsync(Runnable runnable)</td><td>使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。</td></tr><tr><td>runAsync(Runnable runnable, Executor executor)</td><td>使用指定的thread pool执行异步代码。</td></tr><tr><td>supplyAsync(Supplier<u> supplier)</u></td><td>使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值</td></tr><tr><td>supplyAsync(Supplier<u> supplier, Executor executor)</u></td><td>使用指定的thread pool执行异步代码，异步操作有返回值</td></tr></tbody></table><p>runAsync 和 supplyAsync 方法的区别是runAsync返回的CompletableFuture是没有返回值的。</p><p>而supplyAsync返回的CompletableFuture是有返回值的，下面的代码打印了future的返回值。</p><p><br></p><p><strong>代码示例：</strong></p><h3 id="5-4-1、【回调型】thenApply、thenApplyAsync、以及子任务串联"><a href="#5-4-1、【回调型】thenApply、thenApplyAsync、以及子任务串联" class="headerlink" title="5.4.1、【回调型】thenApply、thenApplyAsync、以及子任务串联"></a>5.4.1、【回调型】thenApply、thenApplyAsync、以及子任务串联</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoSupplyAsync</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//不指定线程池，默认使用ForkJoinPool里的commonPool</span></span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//延长2秒，观察阻塞点</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="string">"子线程名字： "</span> + name);</span><br><span class="line">            <span class="keyword">return</span> name + <span class="string">" hello"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"......mark 1......"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//【细节】子任务与子任务的串联。future2依赖future1的结果再执行。</span></span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = future1.thenApplyAsync(<span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">        <span class="comment">//thenApplyAsync是在线程池中异步执行</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="string">"线程名字： "</span> + name + <span class="string">" 入参："</span> + s);</span><br><span class="line">            <span class="keyword">return</span> s + <span class="string">" world"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).thenApply(<span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">        <span class="comment">//thenApply是在主线程中执行</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="string">"线程名字： "</span> + name + <span class="string">"线程. 入参："</span> + s);</span><br><span class="line">            <span class="keyword">return</span> s + <span class="string">" Oh!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//观察阻塞点</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">"......mark 2......"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"主线程："</span> + future2.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">......mark <span class="number">1</span>......</span><br><span class="line">子线程名字： ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">线程名字： ForkJoinPool.commonPool-worker-<span class="number">1</span> 入参：ForkJoinPool.commonPool-worker-<span class="number">1</span> hello</span><br><span class="line">线程名字： ForkJoinPool.commonPool-worker-<span class="number">1</span>线程. 入参：ForkJoinPool.commonPool-worker-<span class="number">1</span> hello world</span><br><span class="line">......mark <span class="number">2</span>......</span><br><span class="line">主线程：ForkJoinPool.commonPool-worker-<span class="number">1</span> hello world Oh!  《《《 注：future2是thenApply，在主线程上执行，因为此时主线程sleep中，故是在主线程sleep(<span class="number">5</span>)后执行。</span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-4-2、【消费型】thenAccept"><a href="#5-4-2、【消费型】thenAccept" class="headerlink" title="5.4.2、【消费型】thenAccept"></a>5.4.2、【消费型】thenAccept</h3><p>thenAccept只对结果执行Action，而不返回新的计算值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniAcceptStage(<span class="keyword">null</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">        BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biAcceptStage(<span class="keyword">null</span>, other, action);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoThenAccept</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123; <span class="keyword">return</span> <span class="string">"hello"</span>;&#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; future2 = future1.thenAccept(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"future2 线程名字： "</span> + Thread.currentThread().getName());</span><br><span class="line">            System.out.println(<span class="string">"future2 accept input： "</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"future 2 get() = "</span> + future2.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">future2 线程名字： main</span><br><span class="line">future2 accept input： hello</span><br><span class="line">future <span class="number">2</span> get() = <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-4-3、【消费型】thenRun"><a href="#5-4-3、【消费型】thenRun" class="headerlink" title="5.4.3、【消费型】thenRun"></a>5.4.3、【消费型】thenRun</h3><p>thenRun更彻底地，下面一组方法当计算完成的时候会执行一个Runnable，与thenAccept不同，Runnable并不使用CompletableFuture计算的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRun</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniRunStage(<span class="keyword">null</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biRunStage(<span class="keyword">null</span>, other, action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orRunStage(<span class="keyword">null</span>, other, action);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-4、【批量】allOf-anyOf"><a href="#5-4-4、【批量】allOf-anyOf" class="headerlink" title="5.4.4、【批量】allOf / anyOf"></a>5.4.4、【批量】allOf / anyOf</h3><p>将一堆CompletableFuture放一个集合中，然后等待整个集合的Future全部结束的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> andTree(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orTree(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoAllOf</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="string">"子线程名字： "</span> + name);</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="string">"子线程名字： "</span> + name);</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            </span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="string">"子线程名字： "</span> + name);</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三个future打成一个集合</span></span><br><span class="line">    CompletableFuture futureAll = CompletableFuture.allOf(future1, future2, future3);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"...waiting..."</span>);</span><br><span class="line">    <span class="comment">//等待所有结合统一结束</span></span><br><span class="line">    futureAll.get();</span><br><span class="line">    System.out.println(<span class="string">"...done..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-4-5、【总览】CompletableFuture有多强大"><a href="#5-4-5、【总览】CompletableFuture有多强大" class="headerlink" title="5.4.5、【总览】CompletableFuture有多强大"></a>5.4.5、【总览】CompletableFuture有多强大</h3><p>CompletableFuture有多强大，查看它全部方法就知道了。</p><p>前几个章节介绍了CompletableFuture的常见用法，其余的能力靠大家按需去挖掘了。</p><p>总的来说，CompletableFuture是优选、第一选择！有什么多线程编程方面的需要，优先在这里查找能力。</p><p><img src="/2020/11/15/一文就明白并发编程/CompletableFuture.png" alt=""></p><p><br></p><h2 id="5-5、Guava提供的那些Future"><a href="#5-5、Guava提供的那些Future" class="headerlink" title="5.5、Guava提供的那些Future"></a>5.5、Guava提供的那些Future</h2><p><strong>价值：<u>Future同步等待获取结果的写法更优雅，响应更及时了</u>。免去了low low的while自旋等待。</strong></p><p><br></p><p><img src="/2020/11/15/一文就明白并发编程/image-20201113171714538.png" alt="image-20201113171714538"></p><ul><li>ListenableFuture 类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListenableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addListener</span><span class="params">(Runnable var1, Executor var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类名</th><th>特点</th></tr></thead><tbody><tr><td>ListenableFuture</td><td>支持Listener形式，处理任务的执行结果</td></tr><tr><td>SettableFuture</td><td>异步执行时的同步等待执行结果。<br>主子线程的优雅协同。<br>支持Listener</td></tr><tr><td>CheckedFuture</td><td>支持get方法抛出异常</td></tr><tr><td>ForwardingListenableFuture</td><td>（Forwarding）装饰者模式，支持Future链式传递</td></tr><tr><td>ForwardingCheckedFuture</td><td>（Forwarding）装饰者模式，支持Future链式传递</td></tr></tbody></table><h3 id="5-5-1、SettableFuture"><a href="#5-5-1、SettableFuture" class="headerlink" title="5.5.1、SettableFuture"></a>5.5.1、SettableFuture</h3><p>SettableFuture可以认为是一种异步转同步的工具。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SettableFutureDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建SettableFuture</span></span><br><span class="line">    <span class="keyword">final</span> SettableFuture settableFuture = SettableFuture.create();</span><br><span class="line"></span><br><span class="line">    fixedThreadPool.submit(() -&gt; &#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"线程内 sleep 5秒"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"线程内 sleep 结束"</span>);</span><br><span class="line">        <span class="comment">//任务线程内手动设置结果</span></span><br><span class="line">        settableFuture.set(threadName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> threadName;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"main线程开始 future.get()"</span>);</span><br><span class="line">        <span class="comment">//任务线程内的SettableFuture未被set()前，get()会阻塞等待。</span></span><br><span class="line">        String threadName = (String) settableFuture.get();</span><br><span class="line">        System.out.println(<span class="string">"main线程打印任务线程名称： "</span> + threadName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixedThreadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-5-2、ListenableFuture"><a href="#5-5-2、ListenableFuture" class="headerlink" title="5.5.2、ListenableFuture"></a>5.5.2、ListenableFuture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ListenableFutureDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ListeningExecutorService listeningExecutor = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(<span class="number">3</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> ListenableFuture&lt;String&gt; listenableFuture = listeningExecutor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"任务线程执行..."</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2种方法执行回调处理</span></span><br><span class="line">    <span class="comment">//方法一 listener型</span></span><br><span class="line"><span class="comment">//        listenableFuture.addListener(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println("任务线程返回的结果： " + listenableFuture.get());</span></span><br><span class="line"><span class="comment">//                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125; catch (ExecutionException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;, listeningExecutor);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【推荐】方法二 callback型</span></span><br><span class="line">    Futures.addCallback(listenableFuture,</span><br><span class="line">            <span class="keyword">new</span> FutureCallback&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"callback success, result =  "</span> + result);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"callback failure, error =  "</span> + t.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待任务执行完毕。</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    listeningExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-5-3、同步-监听"><a href="#5-5-3、同步-监听" class="headerlink" title="5.5.3、同步+监听"></a>5.5.3、同步+监听</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SettableListenFutureDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//还是settableFuture，因为其实现了ListenableFuture</span></span><br><span class="line">    <span class="keyword">final</span> SettableFuture settableFuture = SettableFuture.create();</span><br><span class="line">    <span class="comment">//设置listener</span></span><br><span class="line">    settableFuture.addListener(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"listen success, result =  "</span> + settableFuture.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, fixedThreadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交任务</span></span><br><span class="line">    fixedThreadPool.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"任务线程执行..."</span>);</span><br><span class="line"></span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        settableFuture.set(name);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步等待任务执行完毕，然后会自动执行listener</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"main线程开始 future.get()"</span>);</span><br><span class="line">        settableFuture.get();</span><br><span class="line">        System.out.println(<span class="string">"main线程开始 future.get() 完毕"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixedThreadPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码运行结果：</span><br><span class="line">main线程开始 future.get()</span><br><span class="line">任务线程执行...</span><br><span class="line">main线程开始 future.get() 完毕</span><br><span class="line">listen success, result =  pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-5-4、AsyncFunction"><a href="#5-5-4、AsyncFunction" class="headerlink" title="5.5.4、AsyncFunction"></a>5.5.4、AsyncFunction</h3><p>再进一步，拿到执行结果后，异步的处理（非main线程）</p><p><br></p><p>我们调用ListenableFuture.get方法取回AsyncFunction接口处理后的结果。当我们想要异步地执行转换逻辑，而不是阻塞的调用(虽然任务还没有完成的时候调用Future.get方法会阻塞)的时候，可以使用AsyncFunction接口。但是AsyncFunction接口并不会异步的执行转换逻辑；而只是返回一个Future实例。 看看下面代码例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncFuntionSample</span> <span class="title">implements</span> <span class="title">AsyncFunction</span>&lt;<span class="type">Long,String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;<span class="built_in">Long</span>,String&gt; map = Maps.newConcurrentMap();</span><br><span class="line">    <span class="keyword">private</span> ListeningExecutorService listeningExecutorService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ListenableFuture&lt;String&gt; apply(<span class="keyword">final</span> <span class="built_in">Long</span> input) throws Exception &#123;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(input)) &#123;</span><br><span class="line">        SettableFuture&lt;String&gt; listenableFuture = SettableFuture.create();</span><br><span class="line">        listenableFuture.<span class="keyword">set</span>(map.<span class="keyword">get</span>(input));</span><br><span class="line">        <span class="keyword">return</span> listenableFuture;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listeningExecutorService.submit(new Callable&lt;String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String call() throws Exception &#123;</span><br><span class="line">            String retrieved = service.<span class="keyword">get</span>(input);</span><br><span class="line">            map.putIfAbsent (input,retrieved);</span><br><span class="line">            <span class="keyword">return</span> retrieved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这个类实现AsyncFunction接口，并且包含一个ConcurrentHashMap实例。当我们调用apply方法时，我们会首先查看下map中有没有这个值，输入对象作为key。如果我们在map中找到值，我们使用SettableFuture类构造出Future对象，并且设置为从map中取出的对象。否则，我们返回提交Callable给ExecutorService放回的Future对象。同样也会放置返回的值到map中去。</p><p><br></p><h2 id="5-6、“分治”机制"><a href="#5-6、“分治”机制" class="headerlink" title="5.6、“分治”机制"></a>5.6、“分治”机制</h2><ul><li>见上文 2.7章节的“Fork / Join 机制”</li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《一文就明白Java并发编程》&quot;&gt;&lt;a href=&quot;#《一文就明白Java并发编程》&quot; class=&quot;headerlink&quot; title=&quot;《一文就明白Java并发编程》&quot;&gt;&lt;/a&gt;《一文就明白Java并发编程》&lt;/h1&gt;&lt;p&gt;一文系列 之 并发编程。&lt;/p&gt;
&lt;p&gt;行文3万余字，包含了多线程方方面面的知识点，相信对你会有所帮助！&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;黄老师&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;1、进程-amp-线程&quot;&gt;&lt;a href=&quot;#1、进程-amp-线程&quot; class=&quot;headerlink&quot; title=&quot;1、进程&amp;amp;线程&quot;&gt;&lt;/a&gt;1、进程&amp;amp;线程&lt;/h1&gt;&lt;p&gt;虽然大家肯定知道进程、线程的概念，但在介绍整篇文章前还是需要再陈述下，保证行文信息量的连贯性。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/11/15/一文就明白并发编程/image-20201011114411757.png&quot; alt=&quot;image-20201011114411757&quot;&gt;&lt;/p&gt;
&lt;center&gt;Linux系统中线程的位置&lt;/center&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://veryjj.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://veryjj.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>技术团队该有的工作观</title>
    <link href="https://veryjj.github.io/2020/10/19/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E8%AF%A5%E6%9C%89%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%A7%82/"/>
    <id>https://veryjj.github.io/2020/10/19/技术团队该有的工作观/</id>
    <published>2020-10-19T15:03:47.000Z</published>
    <updated>2021-01-10T09:16:19.544Z</updated>
    
    <content type="html"><![CDATA[<p>即使是技术类工作，除了“专业能力过硬”，以下软素质同样重要！</p><p><em>1.</em> <strong>认真负责</strong></p><ul><li>不把“出了问题谁负责”挂在嘴边，相反，“就这么干，出了事我负责”更具备leader的潜质</li><li>交给ta的任何事情，能够拿到结果，如果每件小事都能让人放心。就问你，你踏实不踏实？</li><li>不推三阻四，很少下意识的“找借口”，如果每次沟通都反馈“不是我”、“我没有”。就问你，你气不气？</li></ul><a id="more"></a><p><em>2.</em> <strong>自驱力强</strong></p><ul><li>不事事等别人交代，不是“要我做xxxx”，而是“我要做xxxx”</li><li>主动承担分外的事情，能提高整体效率的事情，例如：将一些每次都手动执行的查找bug命令脚本化，其实并没有人要求ta这么做。就问你，你暖不暖？</li><li>不简单只为“工资”工作，不“一个经验用N年”，而是主动学习，积极进取</li></ul><p><em>3.</em> <strong>主动沟通</strong></p><ul><li>碰到困难，主动和团队同学沟通，不是一股脑闷头干，每次到deadline才反馈有问题的同事。就问你，你怕不怕？</li><li>沟通讲究“主动”，带着方案，当面沟通</li><li>沟通讲究“高效”，每次邮件来来回回，一个问题低效讨论。就问你，你急不急？</li></ul><p><em>4.</em> <strong>团队精神</strong></p><ul><li>不管个人能力多强，永远把集体的利益放在首位，接受公司调动，愿意离开自己舒适区的同事，永远受团队喜欢</li><li>铭记团队目标，当自己成为项目的关键路径时，会主动拼一拼，冲一冲，当自己成为团队的“短板”时，会主动学习，积极提升</li><li>虽然个人有不同意见，但团队一旦达成一致，就积极支持集体决议，而不是故意对抗</li></ul><p><em>5.</em> <strong>结果导向</strong></p><ul><li>不但软素质过硬，工作有成果，而非强调苦劳</li><li>办法永远比问题多，遇事不是一味强调困难，畏首畏尾，而是想办法拿结果</li><li>偶尔，给人惊喜，超出预期</li></ul><p>不看关系，不看资历，出了成绩，你就上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;即使是技术类工作，除了“专业能力过硬”，以下软素质同样重要！&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;strong&gt;认真负责&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不把“出了问题谁负责”挂在嘴边，相反，“就这么干，出了事我负责”更具备leader的潜质&lt;/li&gt;
&lt;li&gt;交给ta的任何事情，能够拿到结果，如果每件小事都能让人放心。就问你，你踏实不踏实？&lt;/li&gt;
&lt;li&gt;不推三阻四，很少下意识的“找借口”，如果每次沟通都反馈“不是我”、“我没有”。就问你，你气不气？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="管理" scheme="https://veryjj.github.io/categories/%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="工作观" scheme="https://veryjj.github.io/tags/%E5%B7%A5%E4%BD%9C%E8%A7%82/"/>
    
      <category term="研发" scheme="https://veryjj.github.io/tags/%E7%A0%94%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM实战 之 奇怪FullGC定位</title>
    <link href="https://veryjj.github.io/2020/10/15/JVM%E5%AE%9E%E6%88%98%20%E4%B9%8B%20%E5%A5%87%E6%80%AAFullGC%E5%AE%9A%E4%BD%8D/"/>
    <id>https://veryjj.github.io/2020/10/15/JVM实战 之 奇怪FullGC定位/</id>
    <published>2020-10-15T15:54:39.000Z</published>
    <updated>2021-01-10T09:07:54.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p><img src="https://img-blog.csdnimg.cn/20201015223319828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图1 真线环境abc-center 堆使用率</center><p> <img src="https://img-blog.csdnimg.cn/20201015223348400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图2 真线环境 abc-center 非堆使用率</center><p>由图1、图2 可见heap和permGen使用率都不高，但是abc-center 2台机器基本上每天会进行2次规律性的FullGC；</p><a id="more"></a><p><br></p><h1 id="二、问题排查"><a href="#二、问题排查" class="headerlink" title="二、问题排查"></a>二、问题排查</h1><p>在线询价真线环境JVM参数配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g</span><br><span class="line">-Xmx2g</span><br><span class="line">-Xmn448m</span><br><span class="line">-XX:SurvivorRatio=5</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+CMSClassUnloadingEnabled</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction=0</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=75</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:MetaspaceSize=300M</span><br><span class="line">-XX:MaxMetaspaceSize=300M</span><br></pre></td></tr></table></figure></p><p>查看真线JVM配置参数CMSInitiatingOccupancyFraction=75，配置的内存是2G，实际堆内存维持在570M左右，老年代内存1.5G，老年代内存使用率也低于75%，达不到触发FullGC的条件；基本上每次FullGC前后，堆内存也无明显变化；</p><p>团队内部分析讨论后，怀疑可能由于System.gc 引起的FullGC。根据pinpoint 触发FullGC的时间点，查看对应时间段的gc-log，确实是由于System.gc引起的FullGC；</p><p><img src="https://img-blog.csdnimg.cn/20201015223808943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center> 图3 真线环境 -center gc日志</center><p>排除掉ABC项目中的程序调用System.gc, 开始猜测二方SDK，三方SDK引入的可能，例如nio包，但是没有找到具有参考价值的日志, 无法定位到具体的调用方法；</p><p>通过反复观察gc日志，发现这些fullgc日志都是周期性的，且周期为10小时，如图3所示；根据GC日志分析可知，应用每10小时触发Full GC的现象大概率是外部组件调用引起的，根据这个线索，开始索骥Google资料，了解到tomcat、nio、cxf部分版本可能会有类似周期性FullGC问题。有价值博客只有:<a href="https://blog.csdn.net/qq_35963057/article/details/85236268" target="_blank" rel="noopener">https://blog.csdn.net/qq_35963057/article/details/85236268</a>，同样的也是每隔10小时FullGC一次；因此大概率判断是由于apache的cxf包引起的FullGC；</p><p><br></p><h1 id="三、定位分析"><a href="#三、定位分析" class="headerlink" title="三、定位分析"></a>三、定位分析</h1><p> 根据上述分析，查看ABC的maven依赖，如图4，果然在ABC中找到了间接引入了apache-cxf的二方SDK包<br><img src="https://img-blog.csdnimg.cn/20201015224357875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center> 图4 inquiry项目maven依赖树</center><p>由于在apache-cxf下的JDKBugHacks利用反射调用了sun.misc.GC中的requestLatency方法如图5所示，调用该方法会创建一个守护线程如图6；</p><p><img src="https://img-blog.csdnimg.cn/20201015224512777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图5 JDKBugHacks类的doHacks方法</center><p><img src="https://img-blog.csdnimg.cn/20201015224548208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图6 GC类中创建守护线程</center><p><img src="https://img-blog.csdnimg.cn/20201015224557199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图7 run方法</center><p><br></p><p>由图7可知，正是由于在守护线程的run方法中调用了System.gc方法导致了FullGC，同时由GC.lock.wait可知，var1是图5 反射调用传入的36000000ms即10小时，当一次FullGC后，var4会变成0，</p><p>因此锁的等待时间是10小时，到这里就基本确定了ABC应用真线是就是由于Apache的cxf包下的JDKBugHacks反射调用导致的；这个GC线程是为了预防部分组件造成的内存泄露问题</p><p>(如javax.management.remote.rmi.RMIConnectorServer等会分配堆外内存)，通过调用sun.misc.GC类中requestLatency创建周期为10小时的GC守护线程，定期通知JVM去回收垃圾。</p><p>这个线程会先判断是否已有其他组件通过requestLatency来创建了GC线程，如果创建了就跳过，否则新建守护进程。根据类名JDKBugHacks，也能猜测这个类是为了修复一些JDK或组件已有的问题，但这个定期FGC在本应用并不需要；</p><p><br></p><p>由于是依赖的二方包引入的，ABC项目中没有显式的调用相关类，需要继续排查是什么地方调用了JDKBugHacks这个类；</p><p>排查发现是由于spring框架在初始化的时候进行了调用，如图8、图9所示(中间省略了几个调用节点)</p><p><img src="https://img-blog.csdnimg.cn/20201015224857258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center> 图8 PostProcessorRegistrationDelegate类</center><p><img src="https://img-blog.csdnimg.cn/20201015224909735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图9   LogUtils类</center><p><br></p><h1 id="四、解决方案"><a href="#四、解决方案" class="headerlink" title="四、解决方案"></a>四、解决方案</h1><p>方案1、由图5可知，可以通过控制判断条件，让其不执行if 里面的逻辑</p><p>直接在启动项目的JVM参数中加入<br>-Dorg.apache.cxf.JDKBugHacks.gcRequestLatency=true   来使JDKBugHacks中的判断为false，然后跳过这段逻辑。</p><p><br><br><br></p><p>方案2、由于二方SDK引入的，实际二方包本身并没有使用到cxf包，maven将Apache-cxf包排除即可,如图10所示；</p><p>本次修改采用第二种解决方案；</p><p><img src="https://img-blog.csdnimg.cn/20201015225231482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图11 真线堆内存</center><p>优化发布上线后，观察近三天确实不在出现FullGC； </p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015223319828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;center&gt;图1 真线环境abc-center 堆使用率&lt;/center&gt;

&lt;p&gt; &lt;img src=&quot;https://img-blog.csdnimg.cn/20201015223348400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;center&gt;图2 真线环境 abc-center 非堆使用率&lt;/center&gt;


&lt;p&gt;由图1、图2 可见heap和permGen使用率都不高，但是abc-center 2台机器基本上每天会进行2次规律性的FullGC；&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://veryjj.github.io/tags/JVM/"/>
    
      <category term="内存" scheme="https://veryjj.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM实战 之 一次内存溢出排查经历</title>
    <link href="https://veryjj.github.io/2020/10/15/JVM%E5%AE%9E%E6%88%98%20%E4%B9%8B%20%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%8E%92%E6%9F%A5%E7%BB%8F%E5%8E%86/"/>
    <id>https://veryjj.github.io/2020/10/15/JVM实战 之 一次内存溢出排查经历/</id>
    <published>2020-10-15T15:09:11.000Z</published>
    <updated>2021-01-10T09:07:49.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源于线上应用事件"><a href="#源于线上应用事件" class="headerlink" title="源于线上应用事件"></a>源于线上应用事件</h1><p>某天团队同学收到线上系统报警，web-abc真线有一台机down掉了。</p><p>为保留事故现场，做剩余应用做了dump。</p><p>然后开始分析</p><a id="more"></a><p><br></p><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>1、 经过对线上出问题周期内的应用日志逐条排查，未发现明显异常。</p><p>2、分析当时的dump快照，发现有两个类的实例数和总大小异常，这两个类是跟poi解析excel有关!这个很关键。</p><p><img src="https://img-blog.csdnimg.cn/20201015230016978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>3、再翻事发时间的真线日志，有所发现，16点11分51秒的时候，确实有流量请求一个上传excel的接口</p><p><img src="https://img-blog.csdnimg.cn/20201015230150609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>4、对比常规接口的日志，事发情况下，只有start没有finish，说明这个请求僵住了，而自这个请求之后的时间，机器才出现不断fullgc的情况</p><p><img src="https://img-blog.csdnimg.cn/20201015230212131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>5、伪造一个excel大文件，在test环境上传，把test服务器搞挂，dump文件分析，与真线类似</p><p><img src="https://img-blog.csdnimg.cn/20201015230357752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>6、通过以上几点证据，判定为本次事件是由于用户上传excel文件出现的极端情况（文件过大，或者一直尝试），具体的情况日志已分析不出。</p><p>8、排查代码中POI读取Excel的方式，发现使用的是用户模式，这样会占用大量的内存；POI提供了2中读取Excel的模式，分别是：</p><ul><li>用户模式：poi下的usermodel有关包，它对用户友好，有统一的接口在ss包下，但是它是把整个文件读取到内存中的，对于大量数据很容易内存溢出，所以只能用来处理相对较小量的数据；</li><li>sax模式：poi下的eventusermodel包下，相对来说实现比较复杂，但是它处理速度快，占用内存少，可以用来处理海量的Excel数据。</li></ul><p>POI sax模式只是改善，并不能完全解决这个问题，所以采用阿里开源easyexcel解决优化。<br><img src="https://img-blog.csdnimg.cn/20201015230508784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><br></p><h1 id="修改优化"><a href="#修改优化" class="headerlink" title="修改优化"></a>修改优化</h1><p>1、poi解析excel的方式改为easyexcel方式</p><p>2、排查后端文件上传、下载的场景，进行大文件极端场景测试</p><p><br></p><h1 id="整改方案"><a href="#整改方案" class="headerlink" title="整改方案"></a>整改方案</h1><p>Java领域解析、生成Excel比较有名的框架有Apache poi、jxl等。但他们都存在一个严重的问题就是非常的耗内存。如果并发量大或excel文件过大，则会OOM或者JVM频繁的full gc。POI的SAX模式虽有改善，但相对比较复杂，excel有03和07两种版本，两个版本数据存储方式截然不同，sax解析方式也各不一样。而阿里开源的easyexcel很好地解决了解析excel大量消耗内存的问题，而且使用简单，功能上也可以覆盖我们的业务需求。<br><br></p><h2 id="easyexcel核心原理"><a href="#easyexcel核心原理" class="headerlink" title="easyexcel核心原理"></a>easyexcel核心原理</h2><p><strong>1、文件解压文件读取通过文件形式</strong></p><p><img src="https://img-blog.csdnimg.cn/20201015230611873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>2、观察者模式按行解析</strong><br>easyExcel采用一行一行的解析模式，并将一行的解析结果以观察者的模式通知处理（AnalysisEventListener）</p><p><img src="https://img-blog.csdnimg.cn/20201015230636250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>3、抛弃不重要数据</strong><br>Excel解析时候会包含样式，字体，宽度等数据，但这些数据是我们不关心的，如果将这部分数据抛弃可以大大降低内存使用。Excel中数据如下Style占了相当大的空间。</p><p><br></p><h2 id="easyexcel的使用："><a href="#easyexcel的使用：" class="headerlink" title="easyexcel的使用："></a>easyexcel的使用：</h2><p>请自行百度</p><p>推荐读物：<a href="https://alibaba-easyexcel.github.io/quickstart/faq.html" target="_blank" rel="noopener">https://alibaba-easyexcel.github.io/quickstart/faq.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;源于线上应用事件&quot;&gt;&lt;a href=&quot;#源于线上应用事件&quot; class=&quot;headerlink&quot; title=&quot;源于线上应用事件&quot;&gt;&lt;/a&gt;源于线上应用事件&lt;/h1&gt;&lt;p&gt;某天团队同学收到线上系统报警，web-abc真线有一台机down掉了。&lt;/p&gt;
&lt;p&gt;为保留事故现场，做剩余应用做了dump。&lt;/p&gt;
&lt;p&gt;然后开始分析&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://veryjj.github.io/tags/JVM/"/>
    
      <category term="内存" scheme="https://veryjj.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>一文就让你精通JVM</title>
    <link href="https://veryjj.github.io/2020/10/04/%E4%B8%80%E6%96%87%E5%B0%B1%E8%AE%A9%E4%BD%A0%E7%B2%BE%E9%80%9AJVM/"/>
    <id>https://veryjj.github.io/2020/10/04/一文就让你精通JVM/</id>
    <published>2020-10-04T12:34:00.000Z</published>
    <updated>2021-01-10T08:42:00.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《一文就让你精通JVM》"><a href="#《一文就让你精通JVM》" class="headerlink" title="《一文就让你精通JVM》"></a>《一文就让你精通JVM》</h1><p>网上有关JVM的知识贴多如牛毛，其中有纷杂的零碎知识贴，也有整理优秀的长贴。信息量非常充分。</p><p>但作为复习或整理JVM知识的而言，还可以有更好的学习用户体验和高效的方式。因此，就想尝试写一篇有关JVM知识点的“秘籍”，让初学者仅读此文就能快速精通JVM的知识脉络以及关键知识，也能让复习着快速反查知识和经验之谈。</p><p align="right">黄老师</p><a id="more"></a><p><img src="/2020/10/04/一文就让你精通JVM/目录.png" alt="目录"></p><h1 id="1、背景知识铺垫"><a href="#1、背景知识铺垫" class="headerlink" title="1、背景知识铺垫"></a>1、背景知识铺垫</h1><h2 id="1-1、JRE、JVM、JDK"><a href="#1-1、JRE、JVM、JDK" class="headerlink" title="1.1、JRE、JVM、JDK"></a>1.1、JRE、JVM、JDK</h2><p>先讲讲JVM、JRE、JDK是什么</p><ul><li>JVM (Java Virtual Machine)<ul><li>JVM有自己的规范，所有的JVM版本都必须按此规范实现。</li><li>JVM是一个抽象、虚拟、不物理存在的”机器”。是通过在真实的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。</li><li>JVM负责执行Java代码</li></ul></li><li>JRE (Java Runtime Environment)<ul><li>JRE包含JVM</li><li>JRE是一个运行环境容器，提供诸多Java运行需要的libs。包括：标准、非标准的Java组件；Java规范要求、Java规范未要求的组件。</li><li>JRE为JVM服务</li><li>rt.jar(contains: lang, util, awt, swing, math, runtime libraries)</li></ul></li><li>JDK (Java Development Kit)<ul><li>从Kit单词上可预知JDK会包含很多东西，的确，JDK包含：JVM、JRE，以及Java语言和工具包。</li><li>JDK比JRE多的部分：Development, debugging tools</li></ul></li><li>Oracle 官方Java概念图    </li></ul><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002123247830.png" alt="image-20201002123247830"></p><h2 id="1-2、HotSpot-Client-Server模式"><a href="#1-2、HotSpot-Client-Server模式" class="headerlink" title="1.2、HotSpot Client/Server模式"></a>1.2、HotSpot Client/Server模式</h2><p>为什么要铺垫下 HotSpot Client/Server模式？因为后续GC章节默认收集器在不同模式下不同。</p><p>HotSpot JVM具有两种模式：Client模式和Server模式。可以理解为针对不同的硬件环境和软件场景做的JVM优化版本。</p><ul><li>Java HotSpot Client VM(-client)：轻量级。为在客户端环境中减少启动时间而优化，使用的策略和功能都是较简单版本。</li><li>Java HotSpot Server VM(-server)：重量级。为在服务器环境中最大化程序执行速度而设计，使用的策略和功能是为了最大化的发挥硬件优势，提升吞吐量。《《《 作为服务端Java开发，大多数情况下默认Server模式。</li></ul><p>HotSpot的安装的模式，32位的hotspot都是client模式；64位的都是server模式的。</p><p>可通过java -version查看</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201003153939596.png" alt="image-20201003153939596"></p><p>若想要修改模式，则需变更JVM的配置文件。32位的虚拟机在 “%JAVA_HOME%/jre/lib/i386/jvm.cfg”；64位的虚拟机在“%JAVA_HOME%/jre/lib/amd64/jvm.cfg”；</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201003155003824.png" alt="image-20201003155003824"></p><h1 id="2、JVM体系结构"><a href="#2、JVM体系结构" class="headerlink" title="2、JVM体系结构"></a>2、JVM体系结构</h1><p><img src="/2020/10/04/一文就让你精通JVM/image-20200927212354198.png" alt="image-20200927212354198"></p><center>JVM体系结构图</center><p><img src="/2020/10/04/一文就让你精通JVM/image-20200928214421885.png" alt="image-20200928214421885"></p><center>操作系统视角</center><h2 id="2-1、Class文件"><a href="#2-1、Class文件" class="headerlink" title="2.1、Class文件"></a>2.1、Class文件</h2><ul><li>Class 文件是一种特定的<strong>二进制文件</strong>格式的文件。格式紧凑，包含了JVM指令集和符号表以及若干其他辅助信息，其编码结构风格被称为“字节码”。</li><li>在JVM体系里，不同的硬件(主要是CPU)和操作系统环境下的JVM是不同版本的实现，而<strong>Java语言的平台无关性，主要体现在“Class文件”上</strong>。Java代码一次编译成Class文件，可以在不同体系的JVM版本下运行。</li></ul><p><img src="/2020/10/04/一文就让你精通JVM/image-20200927204916941.png" alt="image-20200927204916941"></p><ul><li>其他语言只要其代码能被编译成符合Class文件规范的Class文件，就能在JVM上运行。</li></ul><h2 id="2-2、内存区-之-虚拟机栈区"><a href="#2-2、内存区-之-虚拟机栈区" class="headerlink" title="2.2、内存区 之 虚拟机栈区"></a>2.2、内存区 之 虚拟机栈区</h2><blockquote><p>见上图《JVM体系结构图》</p></blockquote><p>在JVM里有一块专门为Java线程分配栈空间的内存区，叫”虚拟机栈区”。</p><p>每个Java线程创建时都会分配一个“虚拟机栈”，此虚拟机栈的生命周期与其所绑定的线程生命周期一致。</p><p>而当线程执行Java代码时，JVM会为每个Java方法创建一个固定结构的内存模型：栈帧。</p><ul><li>此“栈帧”结构是线程虚拟机栈入栈/出栈操作的基本单位（入栈/出栈的时机对应Java方法的调用和返回）</li><li>栈帧是用于支持JVM进行方法调用和方法执行的数据结构</li></ul><p><strong>2.2.1、栈帧(Stack Frame)结构</strong></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20200927213751205.png" alt="image-20200927213751205" style="zoom:50%;" align="left"></p><ol><li><p><strong>局部变量表</strong>： 编译期确定局部变量表大小。一组变量存储空间， 容量以slot为最小单位，而slot的大小随硬件体系而定，以此来适应硬件体系的差异。</p><ul><li><blockquote><p>虚拟机规范中未明确指明一个Slot应占用的内存空间大小，只是导向性的说到每个Slot都应该存放一个boolean、byte、char、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型都可以使用32位或更小的物理内存来存放，Slot的长度可以随着处理器、操作系统或虚拟机的不同而发生变化。</p></blockquote></li></ul></li><li><p><strong>操作栈</strong>：编译期确定操作数栈最大深度。是一个后入先出栈（LIFO）。操作数栈可类比CPU的寄存器，协助JVM完成Java方法内的调用传值，计算操作。</p><ul><li><blockquote><p>例如：整数加法的字节码指令iadd再运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int类型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。</p></blockquote></li></ul></li><li><p><strong>动态连接</strong>： 指向运行时常量池中该栈帧所属Java方法的引用，这样才能找到真正&amp;完整的代码片段。</p><ul><li><blockquote><p>Class文件中关于方法调用，存的是符号引用。字节码在运行期，需要将符号引用转化为带具体内存地址的代码片段的直接引用。</p></blockquote></li></ul></li><li><p><strong>方法返回地址</strong>：方法退出的过程实际上等同于把当前栈帧出栈，并恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p><ul><li>方法返回地址里一般存的是调用者当时的PC计数器的值。当方法正常返回时，就返回这个地址。而当方法异常退出时，返回地址要通过异常处理器表来确定。</li></ul></li><li><p><strong>额外附加信息</strong>：预留的扩展区域，由JVM实现方按需使用。</p></li></ol><h2 id="2-3、内存区-之-本地方法栈区"><a href="#2-3、内存区-之-本地方法栈区" class="headerlink" title="2.3、内存区 之 本地方法栈区"></a>2.3、内存区 之 本地方法栈区</h2><p>本地方法栈是JVM为Native方法提供的内存空间。</p><p>本地方法栈里的基本元素结构取决于本地方法接口的具体实现机制。若其使用C连接模型,那么本地方法栈就是C栈。</p><p>Java方法栈和本地方法栈之间可以灵活交叉切换。</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20200928213456079.png" alt="image-20200928213456079" style="zoom:50%;"></p><p>有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如典型的Sun HotSpot虚拟机。</p><h2 id="2-4、内存区-之-堆内存区"><a href="#2-4、内存区-之-堆内存区" class="headerlink" title="2.4、内存区 之 堆内存区"></a>2.4、内存区 之 堆内存区</h2><p><img src="/2020/10/04/一文就让你精通JVM/image-20200928220414158.png" alt="image-20200928220414158" style="zoom:80%;"></p><p>Java堆，是JVM管理的最大的一块内存，也是GC的主战场。里面存放的是几乎所有的对象实例和数组数据。</p><blockquote><p>JIT编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在Java堆，而是栈内存。</p></blockquote><ul><li><p><strong>从内存回收角度</strong>：Java堆为分代回收机制，分为年轻代和老年代。这样划分的好处是为了更快的回收内存（每次回收的内存范围相对小）</p></li><li><p><strong>从内存分配角度</strong>：Java堆可以划分出线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB)；这样划分的好处是为了更快的分配内存；</p><ul><li><blockquote><p>关联知识点：</p><p>1、标量替换：允许将对象打散分配在栈上，比如若一个对象拥有两个字段，会将这两个 字段视作局部变量进行分配。</p></blockquote></li></ul></li></ul><h3 id="2-4-1、各内存区默认配比"><a href="#2-4-1、各内存区默认配比" class="headerlink" title="2.4.1、各内存区默认配比"></a><strong>2.4.1、各内存区默认配比</strong></h3><ul><li>年轻代：老年代 默认 1：2（将堆空间分为3份）</li><li>Eden ：from ：to  默认  8：1：1</li></ul><p><img src="/2020/10/04/一文就让你精通JVM/image-20200928231435881.png" alt="image-20200928231435881" style="zoom:40%;"></p><p>相关JVM参数</p><ul><li>-Xms：初始堆大小。默认物理内存的1/64。</li><li>-Xmx：最大堆大小。默认物理内存的1/4。</li><li>-Xmn：年轻代大小</li><li>-XX:NewRatio：年轻代与老年代的比值</li><li>-XX:SurvivorRatio：Eden区域Survivor区的大小比值。默认8:1:1。</li></ul><h3 id="2-4-2、TLAB"><a href="#2-4-2、TLAB" class="headerlink" title="2.4.2、TLAB"></a><strong>2.4.2、TLAB</strong></h3><p>全称 Thread Local Allocation Buffer，线程本地分配缓冲区。</p><p>默认是开始的。JVM命令 -XX:+UseTLAB。</p><p>由于堆是全局共享的，因此存在同一时间会有多个线程在堆上申请空间的并发情况。为保证堆内存分配操作的原子性，JVM采用“CAS+失败重试”的方式，但这种方式在并发竞争激烈的情况下效率会进一步下降。</p><p>因此，JVM额外设计了TLAB 来避免多线程分配对象内存时的冲突处理。</p><p>大致原理：</p><ul><li>JVM在内存年轻代Eden Space中开辟了一小块线程私有的区域，称作TLAB。默认设定为占用Eden Space的1%。</li><li>Java中每个线程都会有自己的缓冲区称作TLAB。</li><li>由于TLAB是线程私有的，所以内存分配没有锁开销，效率高。</li><li>在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上。</li></ul><blockquote><p>故，对象仍旧是在堆上被分配的，只不过分配的方式变了而已。</p></blockquote><h3 id="2-4-3、逃逸分析"><a href="#2-4-3、逃逸分析" class="headerlink" title="2.4.3、逃逸分析"></a><strong>2.4.3、逃逸分析</strong></h3><blockquote><p>关联知识点：逃逸分析只在JVM运行在server模式时才能启用。</p></blockquote><p>逃逸分析 是一种可以有效减少Java 中堆内存分配压力的分析算法。JVM默认开启。</p><p>通过逃逸分析，Java Hotspot编译器能够分析出一个即将新创建对象的引用的使用范围，从而决定通过哪种方式分配对象内存（栈上标量替换；TLAB分配；堆分配；）。</p><h3 id="2-4-4、对象内存分配的两种方法"><a href="#2-4-4、对象内存分配的两种方法" class="headerlink" title="2.4.4、对象内存分配的两种方法"></a><strong>2.4.4、对象内存分配的两种方法</strong></h3><p>为对象分配内存空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p><ul><li><strong>指针碰撞</strong>    (Serial、ParNew等带Compact过程的收集器)<br>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）。 </li><li><strong>空闲列表</strong>    (CMS这种基于Mark-Sweep算法的收集器)<br>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。 </li></ul><p><img src="/2020/10/04/一文就让你精通JVM/image-20200928224239531.png" alt="image-20200928224239531" style="zoom:50%;" align="left"></p><h3 id="2-4-5、对象实例的具体结构"><a href="#2-4-5、对象实例的具体结构" class="headerlink" title="2.4.5、对象实例的具体结构"></a><strong>2.4.5、对象实例的具体结构</strong></h3><p><img src="/2020/10/04/一文就让你精通JVM/java_object.png" alt="java_object" style="zoom:80%;"></p><ul><li>对于填充数据不是一定存在的，仅仅是为了字节对齐。</li></ul><h2 id="2-5、内存区-之-方法区"><a href="#2-5、内存区-之-方法区" class="headerlink" title="2.5、内存区 之 方法区"></a>2.5、内存区 之 方法区</h2><p>当JVM使用<strong>类装载</strong>器装载某个类时，它首先要定位对应的class文件，然后读入这个class文件，最后，JVM<strong>提取该文件的内容</strong>信息，并将这些信息<strong>存储到方法区</strong>，最后返回一个class实例。</p><ul><li>注：方法区 是 JVM规范的一部分，并不是实际的实现。实际实现有JDK7以前的永久代，以及JDK8的元空间。</li></ul><p><strong>方法区的特点：</strong></p><p>1、方法区是线程安全的。假如同时有两个线程都企图访问方法区中的同一个类，而这个类还没有被装入JVM，那么只允许一个线程去装载它，而其它线程必须等待。</p><p>2、方法区的大小不是固定的，JVM可根据应用运行期的需要动态调整。其内存也不一定是连续的。</p><p>3、方法区也可被垃圾收集（GC），当某个类不在被使用(不可触及)时，JVM将卸载这个类，进行垃圾收集。</p><p>方法区主要存放的是<strong>已被虚拟机加载</strong>的类信息、常量、静态变量、编译器编译后的代码等数据。</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20200929213621269.png" alt="image-20200929213621269" style="zoom:50%;"></p><center>常量池分解</center><p><strong>2.5.1、静态常量池：</strong></p><p>即class文件中的常量池，是文件级、静态级的。class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。</p><p><strong>2.5.2、运行时常量池：</strong></p><p>运行时常量池是方法区的一部分，可以理解为一块专门存放常量的内存。包括装载class文件而放入的常量，也包括代码运行时动态生成的常量（String类的intern()方法）。</p><p>静态常量池和运行时常量池的差别在于，一个是存在文件中，是“静”的，一个是存在内存中，是“动”的。</p><p>而我们常说的常量池，一般是指在方法区中的动态常量池。</p><h2 id="2-6、内存区-之-堆外内存区"><a href="#2-6、内存区-之-堆外内存区" class="headerlink" title="2.6、内存区 之 堆外内存区"></a>2.6、内存区 之 堆外内存区</h2><p>讲堆外内存前，首先带大家从操作系统视角看堆外内存所处的位置。相信看了直观的图示后能立马有清晰的记忆和理解。</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20200929221651061.png" alt="image-20200929221651061" style="zoom:80%;"></p><p>助读说明：</p><p>1、先着眼操作系统进程视角，每个进程都拥有自己独占的进程级内存空间。每个进程看到的机器内存大小是一样的，且内存范围也是一样的。为什么？因为用户态进程看到的是逻辑内存地址，并不是真实的物理内存地址。</p><p>2、用户态进程的内存地址都是逻辑地址，用malloc分配，故物理上不连续。</p><p>3、堆内存在JVM内。受JVM管理，参与GC。</p><p>4、<strong>堆外内存处于进程内存空间，但属于JVM堆内存之外</strong>。</p><p>5、堆外内存不受JVM管理，不参与GC。编码时需要主动释放。</p><p><strong>2.6.1、直接内存</strong>（Direct Buffer）</p><p>Direct Buffer是堆外内存的一种具体类型，常出现于NIO模型中。</p><p>NIO模型中为什么要用Direct Buffer？</p><p>答：NIO需要进行socket连接的收包和发包，这个操作最终要从操作系统用户态进入到内核态进行操作。而内核态调用要求内存地址必须可靠（即在一次完整调用周期内内存地址是不会变的）。但Java堆里的内存会受GC影响而移动整理，地址会变。故NIO不能用堆里的内存。</p><blockquote><p>即使代码层面非要用Java堆内存区做NIO操作，JVM仍会自动将堆内存对象转换为直接内存对象，然后再进行内核态操作。</p></blockquote><p>故Direct Buffer对于JVM来说有如下优点：</p><p>1、对于NIO操作,直接用Direct Buffer比用Java堆内存,免去一次内存拷贝，相比之下效率高了。</p><p>2、GC压力更小。因Direct Buffer是堆外内存，是代码者自行管理，不用JVM额外操心,GC的范围就缩小了。</p><p>其他须知：</p><p>1、Direct Buffer创建是比较耗时的，高性能或高频场景下，建议池化。</p><h1 id="3、JVM垃圾收集器"><a href="#3、JVM垃圾收集器" class="headerlink" title="3、JVM垃圾收集器"></a>3、JVM垃圾收集器</h1><p>JVM垃圾回收是继掌握内存模型后，必须进阶更进一步掌握的JVM内存知识。</p><p>全世界的程序员都知道：“Java的内存是会自动回收的”。这背后会有哪些知识点呢，请看下文。</p><h2 id="3-1、垃圾回收原理"><a href="#3-1、垃圾回收原理" class="headerlink" title="3.1、垃圾回收原理"></a>3.1、垃圾回收原理</h2><p><strong>3.1.1、垃圾分析策略</strong></p><ul><li>引用计数 策略</li></ul><blockquote><p>比较古老的回收算法。原理是额外维护对象上的引用计数。当发生GC时，回收引用计数为0的对象的内存。</p><p>此算法的缺点：无法处理循环引用的问题。</p><p>​        那怎么破解呢？用Java里的弱引用（Weak Reference）破开强引用关系。</p></blockquote><ul><li>可达性分析 策略（主流JVM用的都是这种）</li></ul><blockquote><p>从GC ROOT开始，遍历引用关系节点，当所有的引用节点遍历完毕之后，剩余未遍历到的节点则被认为是没有被引用到的节点，即可被回收的对象节点。</p></blockquote><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002123907218.png" alt="image-20201002123907218" style="zoom:40%;"></p><center>GC Root 示例</center><p>需要知晓的是：</p><p>1、会有一些列的“GC Roots”且同时工作，在Java中可作为GC Root的对象包括：</p><p>​      a）虚拟机栈中引用的对象（栈帧中的本地变量表）</p><p>​      b）方法区中类静态属性引用的对象</p><p>​      c）方法区中常量引用的对象</p><p>​      d）本地方法栈中JNI（Native）引用的对象</p><p>2、<strong>基于GC Root做可达性分析时，需要STW（Stop The World），必须记住此知识点</strong>，对于了解后续垃圾回收算法有帮助。</p><p> <strong>3.1.2、垃圾回收算法</strong></p><p><strong>一、引用计数 算法</strong></p><blockquote><p>略</p></blockquote><p><strong>二、标记-清除 算法（Mark-Sweep）</strong></p><p>最基础的垃圾回收算法，思想简单且容易实现。</p><p>工作上分为两个阶段：</p><p>一、标记阶段：从GC Roots开始标记被引用对象；</p><p>二、清除阶段：遍历整个堆，把未标记的对象清除；</p><p>缺点：会有内存碎片。导致下一次GC的提前到来。</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002130408084.png" alt="image-20201002130408084" style="zoom:30%;"></p><p><strong>三、复制 算法（Copying）</strong></p><p>为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。</p><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把此内存区域空间一次清空，这样一来就不容易出现内存碎片的问题。</p><p>优点：不会出现内存碎片。</p><p>缺点：需要两倍的内存空间。</p><p>适合对象生命周期短的内存区域，一次能回收绝大部分内存。例如：年轻代</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002132644475.png" alt="image-20201002132644475" style="zoom:30%;"></p><p><strong>四、标记-整理 算法（Mark-Compact）</strong></p><p>此算法结合了“标记<strong>-</strong>清除”和“复制”两个算法的优点。</p><p>分为三个阶段：（我更喜欢划分为三个阶段）</p><p>第一阶段：从GC Root开始标记所有被引用对象</p><p>第二阶段：遍历整个堆，将存活对象往集中的一片内存区域移动。</p><p>第三阶段：基于内存整理后的指针边界，清除整理区域以外的内存空间。</p><p><strong>再强调下特殊点：时序上是“标记-&gt;整理-&gt;清理”。</strong></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002133558462.png" alt="image-20201002133558462" style="zoom:30%;"></p><p><strong>3.1.3、小结一下</strong></p><table><thead><tr><th>堆内存区</th><th>垃圾分析策略</th><th>常用垃圾回收算法</th></tr></thead><tbody><tr><td>年轻代</td><td>GC Root可达性分析</td><td>1、复制算法</td></tr><tr><td>老年代</td><td>GC Root可达性分析</td><td>1、标记-清除算法<br>2、标记-整理算法</td></tr></tbody></table><p><strong>衍生的知识点：</strong></p><p>GC Roots的可达性分析，会衍生到图论的算法。有一个比较经典的有向图的问题：有向图检测是否存在环。</p><p>这也是调用引擎，规则引擎经常会遇到的算法问题（新加入一个节点时预检测是否构成环）</p><blockquote><p>考虑简单环，所谓的简单环，即除了第一个和最后一个顶点，其余所有顶点在路径中只出现一次。</p></blockquote><p>实现思路一：DFS    时间复杂度O(V+E)</p><p>做DFS（深度优先搜索）遍历时，每深入遍历一个的节点就把节点都压入<strong>栈</strong>，每退回一层遍历就把节点从栈中退出，且每次压入前都检测当前节点在栈中是否已存在。如果已存在，就表明曾经经过此节点，说明已构成环。</p><p><a href="https://blog.csdn.net/login_sonata/article/details/78002042" target="_blank" rel="noopener">参考之一</a></p><p>实现思路二：拓扑排序    时间复杂度O(n^2)    从有向图的末梢逐步往上砍叶子节点。</p><p>出度和入度的概念。一张有向图是有顶点和带有方向的边组成的。对于一个顶点，如果有n边从其他顶点指向此顶点，则这个顶点的入度就是n。相应的，如果有n条边从这个顶点指向其他顶点，则这个顶点的出度就是n。</p><p><strong>拓扑排序</strong>的一般流程：</p><p>1.初始化各个顶点的出度。</p><p>2.移除出度为0的顶点和与此顶点相连的边。</p><p>3.更新出度。</p><p>4.重复步骤2和3，直到不存在出度为0的顶点或者顶点已经全部被移除了。</p><p>5.判断是否存在剩余顶点，若存在则存在环，若不存在则无环。</p><p><a href="https://blog.csdn.net/weixin_48607921/article/details/107224420?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">参考</a></p><h2 id="3-2、分代收集策略"><a href="#3-2、分代收集策略" class="headerlink" title="3.2、分代收集策略"></a>3.2、分代收集策略</h2><p>分代收集策略的目的本质是为了更高效效率的进行内存回收。</p><p>核心思想是根据对象存活生命周期的特点，将JVM内存划分为若干个区域，不同内存区域按其对象生命周期的特点采用不同的回收频率和回收算法。常见的分代方式：年轻代、老年代、永久代。</p><blockquote><p>反过来试想，假设JVM在一次垃圾回收窗口时，要对整个JVM内存区对垃圾回收分析和清除，Stop The World会持续很长时间。</p></blockquote><p><strong>与垃圾回收策略的匹配</strong></p><table><thead><tr><th>堆内存区</th><th>内存区特点</th><th>垃圾分析策略</th><th>常用垃圾回收算法</th></tr></thead><tbody><tr><td>年轻代</td><td>对象生命周期短，每次回收量大</td><td>GC Root可达性分析</td><td>1、复制算法</td></tr><tr><td>老年代</td><td>对象生命周期长，每次回收量小</td><td>GC Root可达性分析</td><td>1、标记-清除算法<br>2、标记-整理算法</td></tr></tbody></table><h2 id="3-3、JVM触发GC的时机"><a href="#3-3、JVM触发GC的时机" class="headerlink" title="3.3、JVM触发GC的时机"></a>3.3、JVM触发GC的时机</h2><p><strong>3.2.1、JVM自动触发GC的时机</strong></p><ul><li><strong>触发YoungGC：</strong><ul><li>新建对象时，发现eden space满了（或者因内存碎片找不到足够连续的内存），JVM会触发一次YoungGC</li></ul></li><li><strong>触发FullGC：</strong><ul><li>升到老年代的对象空间大于老年代剩余空间，JVM会触发一次FullGC。或者被HandlePromotionFailure参数强制FullGC。</li></ul></li></ul><p><strong>3.2.2、手动触发GC</strong></p><ul><li>代码System.gc()。但只是像JVM提交了一次GC请求，至于何时会真正执行GC，未知。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates to the VM that it would be a good time to run the</span></span><br><span class="line"><span class="comment">     * garbage collector. Note that this is a hint only. There is no guarantee</span></span><br><span class="line"><span class="comment">     * that the garbage collector will actually be run.</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> shouldRunGC;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    shouldRunGC = justRanFinalization;</span><br><span class="line">    <span class="keyword">if</span> (shouldRunGC) &#123;</span><br><span class="line">      justRanFinalization = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      runGC = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shouldRunGC) &#123;</span><br><span class="line">    Runtime.getRuntime().gc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在justRanFinalization=true的时候才会执行。</p><p>强制执行GC的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br><span class="line">runtime.runFinalizationSync();</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><h2 id="3-4、“Stop-The-World”是怎么执行的（SafePoint）"><a href="#3-4、“Stop-The-World”是怎么执行的（SafePoint）" class="headerlink" title="3.4、“Stop The World”是怎么执行的（SafePoint）"></a>3.4、“Stop The World”是怎么执行的（SafePoint）</h2><p>我们知道JVM GC是需要”Stop The World”的，“Stop The World”代表着所有Java线程需要全部暂停。在JVM Java线程高频并发运行的状态下，怎么让所有Java线程全部都进入安全的暂停状态呢？答案：<strong>SafePoint机制</strong>。</p><p><br></p><p>3.4.1、【概念】</p><p>从线程角度看，safepoint可以理解成在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停。比如：GC时需要暂停所以Java线程的需求。</p><p>safepoint的特性可以用在不同的地方：GC、Deoptimization。</p><p>常见的safepoint位置：</p><ol><li><p>循环的末尾 (防止大循环的时候一直不进入 safepoint，而其他线程在等待它进入 safepoint)</p></li><li><p>方法返回前</p></li><li>调用方法的call之后 </li><li>抛出异常的位置</li></ol><p><br></p><p>3.4.2、【Safepoint放在代码什么位置】</p><blockquote><p> 以Hotspot为例说明一下什么地方会放置safepoint</p></blockquote><p>1、理论上，在解释器的每条字节码的边界都可以放一个Safepoint，但挂载Safepoint的调试符号信息（为GC生成的符号信息是OopMap）要占用内存空间，如果每条机器码后面都加safepoint的话，需要保存大量的运行时数据，所以在放置Safepoint方面会取折中适用的策略。</p><p>2、HotSpot JVM在通过JIT编译时，会在所有方法返回之前以及循环跳转、异常跳转之前放置Safepoint，为了防止发生GC需要STW时，该线程一直不能暂停。并且，在每个Safepoint都生成一些信息存储哪些地方是引用（<strong>OopMap</strong>），以便JVM能找到需要的引用。</p><p><br></p><p>3.4.3、【线程如何被挂起】</p><p>有两种方法：<strong>抢占式中断</strong>(Preemptive Suspension)和<strong>主动式中断</strong>(Voluntary Suspension)。</p><p>（线程被）<strong>抢占式中断：</strong></p><p>抢占式中断不需要线程的执行代码去主动配合。当触发GC时，JVM会中断所有线程，然后依次检查每个线程中断的位置是否为Safepoint，如果不是则恢复线程，让它执行至Safepoint再进行终端。</p><p><br></p><p>（线程）<strong>主动式中断：</strong>《《《 <strong>HotSpot JVM的实现方式</strong></p><p>即GC需要中断线程的时候，它仅仅简单地设个标志，每个Java线程会在进入Safepoint时主动轮询这个标志位，如果标志位就绪的话就自行中断。</p><blockquote><p>如果触发GC动作，VM thread会在<code>VMThread::loop()</code>方法中调用<code>SafepointSynchronize::begin()</code>方法，最终使所有的线程都进入到safepoint。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Roll all threads forward to a safepoint and suspend them all</span></span><br><span class="line"><span class="keyword">void</span> SafepointSynchronize::begin() &#123;</span><br><span class="line">  Thread* myThread = Thread::current();</span><br><span class="line">  <span class="keyword">assert</span>(myThread-&gt;is_VM_thread(), <span class="string">"Only VM thread may execute a safepoint"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (PrintSafepointStatistics || PrintSafepointStatisticsTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    _safepoint_begin_time = os::javaTimeNanos();</span><br><span class="line">    _ts_of_current_safepoint = tty-&gt;time_stamp().seconds();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>3.4.4、【线程如何恢复】</p><p>有了<code>begin</code>方法，自然有对应的<code>end</code>方法，在<code>SafepointSynchronize::end()</code>中，会最终唤醒所有挂起等待的线程。</p><p>思考题：</p><p>1、GC时最大的影响就是STW周期，本文讲的所有线程都进入safepoint的也是有个周期，且此周期受并发线程个数和safepoint距离影响。问：线程池配的越多，对GC的耗时有明显的影响吗？</p><h2 id="3-5、垃圾收集器"><a href="#3-5、垃圾收集器" class="headerlink" title="3.5、垃圾收集器"></a>3.5、垃圾收集器</h2><h3 id="3-5-1、垃圾收集器类型"><a href="#3-5-1、垃圾收集器类型" class="headerlink" title="3.5.1、垃圾收集器类型"></a><strong>3.5.1、垃圾收集器类型</strong></h3><p>HotSpot JVM里有7种垃圾收集器，你是怎么记忆它们的呢？</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002145206418.png" alt="image-20201002145206418" style="zoom:50%;"></p><p>上图解读：</p><p>（A）图中展示了<strong>7种</strong>收集器：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；</p><p>（B）图中它们所处区域，表明其是属于年轻代收集器还是老年代收集器：</p><ul><li><p>年轻代收集器**：Serial、ParNew、Parallel Scavenge；</p></li><li><p><strong>老年代收集器</strong>：Serial Old、Parallel Old、CMS；</p></li><li><p><strong>整堆收集器</strong>：G1；</p></li></ul><p>（C）两个收集器间的连线，表明它们<strong>可以搭配使用</strong>：</p><pre><code>- Serial 配 ：Serial Old 或 CMS；- ParNew 配 ：Serial Old 或 CMS；- Parallel Scavenge 配 ：Serial Old 或 Parallel Old；</code></pre><p>（D）CMS与Serial Old的连线表示Serial Old是作为CMS出现<strong>“Concurrent Mode Failure”失败</strong>的后备预案。</p><h3 id="3-5-2、常见垃圾收集器对比"><a href="#3-5-2、常见垃圾收集器对比" class="headerlink" title="3.5.2、常见垃圾收集器对比"></a><strong>3.5.2、常见垃圾收集器对比</strong></h3><p><img src="/2020/10/04/一文就让你精通JVM/image-20201003160503899.png" alt="image-20201003160503899"></p><p><strong>GC时STW的停顿时长的排行</strong>：G1 &lt; CMS &lt; Parallel收集器 &lt; Serial收集器</p><p><strong>JVM默认收集器</strong></p><p>怎么查看？</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002231309561.png" alt="image-20201002231309561"></p><p>怎么切换？</p><p>例子：-XX:+UseConcMarkSweepGC</p><table><thead><tr><th>参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>UseSerialGC</td><td style="text-align:left">JVM运行下<u><strong>Client模式下的默认收集器</strong></u>，打开此开关后，使用<strong>Serial+Serial Old</strong>的收集器组合。</td></tr><tr><td>UseParNewGC</td><td style="text-align:left">使用ParNew+Serial Old的收集器组合。</td></tr><tr><td>UseConcMarkSweepGC</td><td style="text-align:left">使用ParNew+CMS的收集器组合。</td></tr><tr><td>UseParallelGC</td><td style="text-align:left">虚拟机运行在<strong>Server模式下的默认收集器</strong>，打开此开关后：<br>- <u>JDK 7u4版本前</u>：使用<strong>Parallel Scavenge + Serial Old</strong>的收集器组合。也是Java书上的说法。<br>- <u>JDK 7u4版本后</u>：使用<strong>Parallel Scavenge + Parallel Old</strong>的收集器组合，此时的Parallel已经很成熟了。<br>求证过程：<a href="https://blog.csdn.net/youanyyou/article/details/106464291?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">Link</a></td></tr><tr><td>UseParallelOldGC</td><td style="text-align:left">使用Parallel Scavenge + Parallel Old的收集器组合</td></tr></tbody></table><h3 id="3-5-3、常见垃圾收集器及原理"><a href="#3-5-3、常见垃圾收集器及原理" class="headerlink" title="3.5.3、常见垃圾收集器及原理"></a><strong>3.5.3、常见垃圾收集器及原理</strong></h3><p><strong>1、（年轻代）Serial</strong></p><p>​        Serial（串行）垃圾收集器是最基本、发展历史最悠久的收集器；JDK1.3.1前是HotSpot年轻代收集的唯一选择；</p><p>​       <strong>特点</strong>：</p><p>​       1、针对年轻代；</p><p>​       2、采用<strong>复制算法</strong>；单线程收集；全程STW；</p><p>​       3、HotSpot Client模式下的默认年轻代收集器；</p><p><img src="/2020/10/04/一文就让你精通JVM/20170102225015841.png" alt="img"></p><center>Serial/Serial Old组合收集器运行示意图</center><p>​       <strong>适用场景</strong>：小内存（小于200M），单CPU的环境。</p><p>2、 <strong>（年轻代）ParNew</strong></p><p>​       ParNew垃圾收集器是<strong>Serial收集器的多线程版本</strong>。</p><p>​       <strong>特点</strong>：</p><p>​       1、除了多线程外，其余的行为、特点和Serial收集器一样（两者还共用了不少代码）。</p><p>​       2、也是针对年轻代，也是<strong>复制算法</strong>。</p><p>​       3、”-XX:+UseConcMarkSweepGC”<strong>：</strong>指定使用CMS后，会<strong>默认使用</strong>ParNew作为年轻代收集器；</p><p>​       4、”-XX:ParallelGCThreads”：指定垃圾收集的线程数量，ParNew<strong>默认</strong>开启的收集线程与<strong>CPU的数量</strong>相同；</p><p><img src="/2020/10/04/一文就让你精通JVM/20170102225016331.png" alt="img"></p><center>ParNew/Serial Old组合收集器运行示意图</center><p>​       <strong>适用场景</strong>：</p><p>​       在HotSpot Server模式下，ParNew收集器是一个非常重要的收集器，<strong>因为除了Serial外，只有它能与CMS收集器配合工作</strong>。</p><p>3、 <strong>（年轻代）Parallel Scavenge</strong></p><p>​       （Java8 默认的收集器）Parallel Scavenge又称为吞吐量优先收集器，特点是多线程回收，以吞吐量优先，高效率的利用CPU时间。</p><p>​       <strong>特点</strong>：</p><p>​       1、Java8 默认的收集器；</p><p>​       2、年轻代收集器；<strong>复制算法</strong>；多线程收集；</p><p>​       3、Parallel Scavenge收集器的目标是以高吞吐量为目标，达一个可控制的吞吐量。</p><blockquote><p>吞吐量：</p><p>吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</p><p>高吞吐量即减少垃圾收集时间，让用户代码获得更长的运行时间</p></blockquote><p><img src="/2020/10/04/一文就让你精通JVM/3699e6695a1d4ac69cb66f7c1f52e219.jpeg" alt="img" style="zoom:80%;"></p><p>​       <strong>适用场景</strong>：</p><p>​       Parallel Scavenge收集器的高吞吐量可以最高效率的利用CPU时间，尽快的完成程序的运算任务等，主要适合在后台运算而不是太多交互的任务（其<em>不适合需要与用户交互的程序</em>，良好的响应速度能提升用户的体验，此种场景CMS效果更好）。</p><p>4、 <strong>（老年代）Serial Old</strong></p><p>​       Serial Old是 <strong>Serial收集器的老年代版本</strong>。是JDK 7u4版本前的老年代默认收集器。</p><p>​       <strong>特点</strong>：</p><p>​       1、采用标记整理法；</p><p>​       2、单线程；</p><p><img src="/2020/10/04/一文就让你精通JVM/20170102225016763.png" alt="img"></p><center>Serial/Serial Old组合收集器运行示意图</center><p>​       <strong>适用场景</strong>：</p><p>​       1、主要用于HotSpot的Client模式。</p><p>5、 <strong>（老年代）Parallel Old</strong></p><p>​       Parallel Old垃圾收集器是Parallel Scavenge收集器的老年代版本；<strong>目前已经很成熟了，是JDK 7u4版本后的老年代默认收集器（JDK8的老年代默认收集器）</strong>。</p><p>​       <strong>特点</strong>：</p><p>​       1、标记-整理 算法；</p><p>​       2、多线程收集；</p><p><img src="/2020/10/04/一文就让你精通JVM/20170102225017065.png" alt="img"></p><center>Parallel Scavenge/Parallel Old收集器运行示意图</center><p>6、 <strong>（老年代）CMS</strong></p><p>​       CMS收集器也称为并发低停顿收集器（或低延迟垃圾收集器），以获取最短回收停顿时间为目标。</p><p>​       CMS并不是等内存不足了才进行FullGC，而是基于设定的GC阈值，当超过阈值时主动进行CMS GC，因为CMS GC是与用户线程并发的，故用户线程对于CMS GC的停顿感知是很少的。</p><blockquote><p>CMS的GC阈值：</p><p>1、设定了CMSInitiatingOccupancyFraction时，以此为阈值，区间：0~100。</p><p>2、CMSInitiatingOccupancyFraction默认为-1，则按“((100 - MinHeapFreeRatio) + (double)( CMSTriggerRatio * MinHeapFreeRatio) / 100.0) / 100.0 ”的值决定，其中MinHeapFreeRatio默认值40，CMSTriggerRatio默认值80，那么阈值为92%。</p><p>为什么要通过阈值留有一部分空闲内存时进行GC？因为CMS GC时可能会遇到“浮动垃圾”，见下文。</p></blockquote><p><strong>^敲黑板：</strong> 需要注意：CMS GC不是FullGC！！！</p><ul><li>HotSpot VM里对concurrent collection和full collection有明确的区分。所有带有“FullCollection”字样的VM参数都是跟真正的full GC相关，而跟CMS并发GC无关的，cms收集算法只是清理老年代。</li></ul><p><strong>CMS收集器运作过程</strong></p><p><strong>第一步：初始标记（CMS initial mark）</strong>： 仅标记一下GC Roots能直接关联到的对象。<em>需要STW</em>，但速度很快。</p><p><strong>第二步：并发标记（CMS concurrent mark）</strong>：进行GC Roots Tracing的过程，标出存活对象。因与用户线程并发运行，不能保证标记出所有存活对象。</p><p><strong>第三步：重新标记（CMS remark）</strong>：<strong>多线程</strong>。修正并发标记期的标记结果。<em>需要STW</em>，相对也不长。</p><p><strong>第四步：并发清除（CMS concurrent sweep）</strong>：回收所有垃圾对象。</p><p>整个过程中<strong>耗时最长的并发标记和并发清除都可以与用户线程一起工作</strong>；所以总体上说，CMS收集器的内存回收过程与用户线程一起并发执行；</p><p><img src="/2020/10/04/一文就让你精通JVM/20170102225017372.png" alt="img"></p><center>CMS收集器运行示意图</center><p>​     <strong>特点</strong>：</p><p>​       1、<u>并发收集</u>（与用户线程并发执行），<strong>低停顿</strong>。</p><p>​       2、标记-清除算法，会产生内存碎片。  </p><p>​     <strong>缺点</strong>：</p><p>​       1、对CPU资源非常敏感</p><blockquote><p>CMS的默认收集线程数量 = (ParallelGCThreads + 3) / 4</p><p>ParallelGCThreads = （ncpus &lt;= 8）? ncpus : (3 + （(ncpus * 5) / 8))。CPU数量小于8时，ParallelGCThreads为CPU数量。</p><p>并发收集线程占用一部分CPU资源，当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。</p></blockquote><p>​      </p><p>​       2、无法处理浮动垃圾，可能出现“Concurrent Mode Failure”</p><p>​           a）浮动垃圾（Floating Garbage）</p><blockquote><p>   在并发清除时，用户线程新产生的垃圾，称为浮动垃圾；</p><p>   这使得并发清除时需要预留一定的内存空间，CMS所需要的空间比其他垃圾收集器大；</p><p>   “-XX:CMSInitiatingOccupancyFraction”：用于设置CMS预留内存空间比例；</p></blockquote><p>​          b）”Concurrent Mode Failure”失败</p><blockquote><p>   如果CMS预留内存空间无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败；</p><p>   这时JVM启用后备预案：临时启用Serail Old收集器，而导致另一次FullGC的产生；</p><p>   这样的代价是很大的，所以CMSInitiatingOccupancyFraction不能设置得太大。</p></blockquote><p>​      <strong>3、产生内存碎片</strong></p><blockquote><p>解决方法：        </p><p>（1）”-XX:+UseCMSCompactAtFullCollection + -XX:+CMSFullGCsBeforeCompaction” 设置CMS执行N次FullGC后，进行一次带整理的FullGC。默认未开启。</p><p>（2）降低-XX:CMSInitiatingOccupancyFraction参数，以提早执行CMS GC动作，虽然CMS GC不会进行内存碎片的压缩整理，但它会合并老年代中相邻的free空间。这样就可以容纳更多的年轻代晋升行为。</p></blockquote><p>   <strong>适用场景</strong>：</p><p>​       1、与用户交互多的场景，注重服务的响应速度，常见于WEB、B/S系统的服务器上的应用。系统停顿时间最短，给用户带来较好的体验。</p><p>7、 <strong>（整堆）G1</strong></p><p><strong>G1收集器运作过程：</strong></p><p><strong>第一步、初始标记（Initial Marking）</strong>：仅标记一下GC Roots能直接关联到的对象；且修改TAMS（Next Top at Mark Start）,让下一阶段并发运行时，用户程序能在正确可用的Region中创建新对象；<strong>需要”Stop The World”，但速度很快</strong>；</p><p><strong>第二步、并发标记（Concurrent Marking）</strong>：   进行GC Roots Tracing的过程； 刚才产生的集合中标记出存活对象；耗时较长，但应用程序也在运行；并不能保证可以标记出所有的存活对象；</p><p><strong>第三步、最终标记（Final Marking）</strong>：   为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录； 上一阶段对象的变化记录在线程的Remembered Set Log；这里把Remembered Set Log合并到Remembered Set中； <strong>需要”Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短</strong>；<strong>采用多线程并行执行来提升效率</strong>。</p><p><strong>第四步、筛选回收（Live Data Counting and Evacuation）</strong>：   首先<strong>排序各个Region的回收价值和成本</strong>； <strong>然后根据用户期望的GC停顿时间来制定回收计划</strong>； 最后按计划回收一些价值高的Region中垃圾对象；</p><p>回收时采用”复制”算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中压缩和释放内存；</p><p> 可以并发进行，降低停顿时间，并增加吞吐量；</p><p><img src="/2020/10/04/一文就让你精通JVM/20170102225017799.png" alt="img"></p><p>​       <strong>特点</strong>：</p><p>​       1、充分利用多CPU的硬件优势，通过并行缩短STW时间，通过并发让用户线程同时进程。</p><p>​       2、能独立管理整个堆（年轻代和老年代）</p><p>​       3、结合多种垃圾收集算法，整体上基于标记-整理算法，局部Region间基于复制算法。不会产生内存碎片。</p><p>​       4、可预测的停顿，低停顿，高吞吐。</p><p>​      </p><p>​       <strong>适用场景</strong>：</p><p>​       针对具有大内存、多处理器机器的服务端应用。可提供低GC停顿的能力。</p><h1 id="4、GC调优"><a href="#4、GC调优" class="headerlink" title="4、GC调优"></a>4、GC调优</h1><h2 id="4-1、GC调优的目标内存区"><a href="#4-1、GC调优的目标内存区" class="headerlink" title="4.1、GC调优的目标内存区"></a>4.1、GC调优的目标内存区</h2><p><img src="/2020/10/04/一文就让你精通JVM/image-20201003160844073.png" alt="image-20201003160844073"></p><ul><li>一般都针对年轻代、老年代调优，<strong>尤其是老年代</strong>。</li><li>方法区可以进行GC，但一般不操心方法区的GC，因为GC的性价比太低，主要回收“废弃常量和无用的类”。如果内存不够就扩大吧。JDK8方法区的实现为元空间，元空间使用的是本地内存（非堆内存），默认情况下元空间的大小是无限的。</li></ul><h2 id="4-2、GC调优的策略"><a href="#4-2、GC调优的策略" class="headerlink" title="4.2、GC调优的策略"></a>4.2、GC调优的策略</h2><blockquote><p>常见的招数，一招招使</p><p>注：一定是先找1台机器进行试验，对比，然后再做出选择，发布生产环境。</p></blockquote><p><strong>4.3.1、大多数的Java应用不需要GC调优</strong></p><ul><li>大部分需要GC调优的，不是JVM参数问题，是代码问题。</li><li>在实际情况中，基于GC情况优化代码比优化GC参数要多得多。</li></ul><p><strong>4.2.2、（选择合适的GC收集器）互联网Web应用考虑CMS收集器，提升交互响应性能</strong></p><ul><li>GC低停顿：CMS收集器是与用户线程并发的内存垃圾收集器；</li><li>大幅减少FullGC：CMS GC是concurrent GC，是周期性主动的回收内存。大幅减少FullGC的发生。</li></ul><p><strong>4.2.3、（选择合适的堆大小） 去设置堆大小，别不设置用默认的</strong></p><ul><li>拍脑袋定初始参数 -&gt; 运行JVM -&gt; 查监控 -&gt; 调整JVM -&gt; 查监控 -&gt; 反复试验 -&gt; 确认JVM参数</li></ul><p><strong>4.2.4、（选择合适的年轻代比重）年轻代尽量大</strong></p><ul><li>年轻代 尽量大，那么可以减少YoungGC。进而减少了对象进入老年代的频率,进而减少FullGC的频率。</li></ul><p><strong>4.2.5、-XX:MaxTenuringThreshold 合理年轻代对象晋升进入老年代的年龄</strong></p><ul><li>-XX:MaxTenuringThreshold 设置年轻代对象进入老年代的年龄大小，减少老年代的内存占用，降低 FullGC 发生的频率</li></ul><p><strong>4.3.6、（小心大对象）避免大对象直接进入老年代</strong></p><ul><li><p>怎么应对/避免？</p><ul><li>一：-XX:+PretenureSizeThreshold 控制<ul><li>设置-XX:+PretenureSizeThreshold 参数：代表超过这个值的时候，对象直接在old区分配内存。默认值是0，代表不管新对象多大都是先在eden中分配内存。</li><li>注意：PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。</li></ul></li><li>二：更大的年轻代，含：eden区、survivor区<ul><li>eden区能申请的到，就不会去old区申请了。同时可适当调高-XX:MaxTenuringThreshold（Linux 64下，默认15），让大对象在年轻代生，在年轻代亡。</li><li>同时，可考虑搭配最小堆大小和最大堆大小，并设置MinHeapFreeRatio或MaxHeapFreeRatio来掌控堆大小的按需扩大与收缩。</li></ul></li></ul></li></ul><h2 id="4-3、GC调优分析工具"><a href="#4-3、GC调优分析工具" class="headerlink" title="4.3、GC调优分析工具"></a>4.3、GC调优分析工具</h2><p>发现JVM内存问题以及查看对应GC情况是简单的</p><ul><li>（原始一点的）登录到服务器上敲命令：jstat、jmap、jstack。</li><li>（常见的）登录公司运维平台查看指标情况：Grafana、容器管理平台等</li><li>（辅助工具型的）APM工具，如：pinpoint。</li></ul><p><strong>pinpoint：</strong></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004145438049.png" alt="image-20201004145438049"></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004145634898.png" alt="image-20201004145634898"></p><p><strong>Grafana：</strong></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004145721175.png" alt="image-20201004145721175"></p><p>一般我们能从统计图表里<strong>快速的看到问题</strong>现象，例如：</p><ul><li>FullGC频繁；</li><li>年轻代占用比例不高，但老年代会有规律性FullGC；</li><li>……</li></ul><p>然后，进一步<strong>定位GC现象发生的原因和具体代码位置</strong>，是需要些技术分析能力和不断试验的。</p><p>这里我们需要用工具来帮我们高效的定位问题。</p><p><strong>常用工具</strong>：</p><blockquote><p>使用顺序：</p><p>1、dump JVM堆</p><p>2、用工具load dump后的文件，通过工具查看内存占用Top的对象，通过对象Class声明或Reference找到代码位置。</p></blockquote><p><strong>1、JProfiler（推荐）（功能很强大；需付费）</strong></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004141701029.png" alt="image-20201004141701029" style="zoom:40%;" align="left"></p><ul><li><p>软件下载地址：<a href="https://www.ej-technologies.com/products/jprofiler/overview.html" target="_blank" rel="noopener">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p></li><li><p>IntelliJ IDEA有插件版本</p></li></ul><p><strong>例图</strong>：</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004144703464.png" alt="image-20201004144703464"></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004144713940.png" alt="image-20201004144713940"></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004144723484.png" alt="image-20201004144723484"></p><p><strong>2、JVisualVM</strong>（免费）</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004141748324.png" alt="image-20201004141748324" style="zoom:40%;" align="left"></p><ul><li><p>软件下载地址：<a href="http://visualvm.github.io/index.html" target="_blank" rel="noopener">http://visualvm.github.io/index.html</a></p></li><li><p>IntelliJ IDEA有插件版本</p></li><li>使用指导贴：<a href="https://www.cnblogs.com/happy-rabbit/p/6232581.html" target="_blank" rel="noopener">https://www.cnblogs.com/happy-rabbit/p/6232581.html</a></li></ul><p><strong>例图：<img src="/2020/10/04/一文就让你精通JVM/image-20201004144918722.png" alt="image-20201004144918722"></strong></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004144929718.png" alt="image-20201004144929718"></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004144951229.png" alt="image-20201004144951229"></p><h2 id="4-4、GC调优的问题举例"><a href="#4-4、GC调优的问题举例" class="headerlink" title="4.4、GC调优的问题举例"></a>4.4、GC调优的问题举例</h2><h1 id="5、监控指标怎么看"><a href="#5、监控指标怎么看" class="headerlink" title="5、监控指标怎么看"></a>5、监控指标怎么看</h1><h2 id="5-1、Heap-amp-Non-Heap"><a href="#5-1、Heap-amp-Non-Heap" class="headerlink" title="5.1、Heap &amp; Non-Heap"></a>5.1、Heap &amp; Non-Heap</h2><blockquote><p>以JDK8及以后为背景</p></blockquote><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004195603358.png" alt="image-20201004195603358"></p><center>例图来自Grafana</center><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004202053909.png" alt="image-20201004202053909"></p><center>例图来自JProfiler</center><p><strong>5.1.1、Heap Memory  =  堆内存</strong></p><p>​    看完之前章节，应熟悉堆内存包含什么。这里不再赘述。</p><p><strong>5.1.2、Non-Heap Memory  =  非堆内存</strong></p><p>如果non-heap使用上升趋势，我们应该关注什么呢？</p><p>non-heap（非堆内存）指Java进程内存中，JVM 堆内存范围以外的内存。不清楚的同学，复习上文第2章节：《JVM体系结构》</p><p>那么，non-heap（非堆内存）主要包含哪些内容呢？</p><p>1、【栈区】：虚拟机栈；本地方法栈；&lt;&lt;&lt;&lt; 这块基本不用操心。也不会持续增大。</p><p>2、【方法区】； &lt;&lt;&lt;&lt; 存在持续增大的可能，见本文《怎么构造方法区OOM》</p><p>3、【Native Memory】； &lt;&lt;&lt;&lt; 一般是JNI用到的内存，可能是频繁NIO导致大量Direct Buffer；也可能是内存未管理好，持续泄露内存了。</p><p>4、【Code Cache】：&lt;&lt;&lt;&lt; 用于编译和保存本地代码的内存。JVM内部处理或优化。一般不操心。</p><h1 id="6、JVM类加载器"><a href="#6、JVM类加载器" class="headerlink" title="6、JVM类加载器"></a>6、JVM类加载器</h1><h2 id="6-1、类加载过程"><a href="#6-1、类加载过程" class="headerlink" title="6.1、类加载过程"></a>6.1、类加载过程</h2><p>类加载的7个步骤:</p><ul><li>装载。根据查找路径找到相应的 class 文件，然后导入。</li><li>验证，检查待加载的 class 文件的正确性。《《《链接的 3 小步</li><li>准备，给类中的静态变量分配存储空间。《《《链接的 3 小步</li><li>解析，将符号引用转换为直接引用(这一步可选)。《《《链接的 3 小步</li><li>初始化。对静态变量和静态代码块执行初始化工作。</li><li>使用</li><li>卸载</li></ul><p>类的加载方式分为隐式加载和显示加载。</p><ul><li>隐式加载指的是程序在使 用 new 等方式创建对象时，会隐式地调用类的加载器把对应的类 加载到 JVM 中。</li><li>显示加载指的是通过直接调用 class.forName() 方法来把所需的类加载到 JVM 中。</li></ul><blockquote><p>1、Class.forName 和 ClassLoader.loadClass 都能加载类，这两者在加载类时的区别？</p><p>Class.forName有重载方法可以指定是否需要初始化，而默认的方法初始化设置为true这会初始化类执行链接和初始化操作</p><p>ClasaLoader是有类加载器的loadClass方法加载，传入的是false，只会执行连接操作，不会初始化操作</p></blockquote><p>类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行 时对内存的开销。</p><p>此外，在 Java 语言中，每个类或接口都对应一 个 .class 文件，这些文件可以被看成是一个个可以被动态加载的</p><p>单元，<strong>因此当只有部分类被修改时，只需要重新编译变化的类即可， 而不需要重新编译所有文件</strong>，因此加快了编译速度。</p><h2 id="6-2、类加载器的种类"><a href="#6-2、类加载器的种类" class="headerlink" title="6.2、类加载器的种类"></a>6.2、类加载器的种类</h2><p>在Java中，类加载器主要有下面四种：</p><ul><li>BootstrapClassLoader：启动类加载器，使用C++实现；</li><li>ExtClassLoader：扩展类加载器，使用Java实现；</li><li>AppClassLoader：应用程序类加载器，加载当前应用的classpath的所有类；</li><li>UserDefinedClassLoader：用户自定义类加载器；</li></ul><p><img src="/2020/10/04/一文就让你精通JVM/Users/chenjie/Documents/笔记中转区/周报/《一文就让你精通JVM》.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlaXhpYW9odWFp,size_16,color_FFFFFF,t_70.png" alt="img"></p><h2 id="6-3、双亲委派机制"><a href="#6-3、双亲委派机制" class="headerlink" title="6.3、双亲委派机制"></a>6.3、双亲委派机制</h2><p>类加载器的加载过程中使用到了双亲委派机制：当一个类收到了类加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器(BootstrapClassLoader)中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。</p><p>好处：</p><p>比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。</p><h2 id="6-4、沙箱安全机制"><a href="#6-4、沙箱安全机制" class="headerlink" title="6.4、沙箱安全机制"></a>6.4、沙箱安全机制</h2><p>沙箱安全机制是由基于双亲委派机制上采取的一种JVM的自我保护机制，假设我们自定了一个java.lang.String 的类，由于双亲委派机制，加载请求会先交给BootstrapClassLoader启动类加载器试图去进行加载，但是BootstrapClassLoader在加载类时首先通过包和类名查找rt.jar中有没有java.lang.String，有则优先加载rt.jar包中的类，由于rt.jar中已经包含了java.lang.String类，所以我们自定义的String类永远得不到加载(当然编译是不会报错的)，它保证了Java源代码的安全。</p><h1 id="7、其他独立知识点"><a href="#7、其他独立知识点" class="headerlink" title="7、其他独立知识点"></a>7、其他独立知识点</h1><h2 id="7-1、内存逃逸分析"><a href="#7-1、内存逃逸分析" class="headerlink" title="7.1、内存逃逸分析"></a>7.1、内存逃逸分析</h2><ul><li>见本文《2.4.3、堆内存区 - 逃逸分析》章节</li></ul><h2 id="7-2、直接内存"><a href="#7-2、直接内存" class="headerlink" title="7.2、直接内存"></a>7.2、直接内存</h2><ul><li>见本文《2.4.6、堆外内存区》章节</li></ul><h2 id="7-3、Java内存屏障"><a href="#7-3、Java内存屏障" class="headerlink" title="7.3、Java内存屏障"></a>7.3、Java内存屏障</h2><p><strong>7.3.1、什么是内存屏障（Memory Barrier）？</strong><br>     内存屏障（memory barrier）是一个CPU指令。</p><p>​     通过在代码中插入这样一条指令可达到几种目的效果：</p><p>作用一：干预编译器的指令重排行为，确保内存屏障前后的代码指令有严格的先后执行顺序。</p><p>作用二：内存屏障的另一个作用是强制更新一次不同CPU的缓存。以此来主动影响一些数据的可见性。</p><blockquote><p>例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p></blockquote><p><strong>7.3.2、为什么需要内存屏障</strong><br>    在多CPU（核）场景下，为了充分利用CPU，会通过流水线将指令并行进行。为了能并行执行，又需要将指令进行重排序以便进行并行执行，那么问题来了，那些指令不是在所有场景下都能进行重排，除了本身的一些规则（如Happens Before 规则）之外，我们还需要确保多CPU的高速缓存中的数据与内存保持一致性, 不能确保内存与CPU缓存数据一致性的指令也不能重排，<strong>内存屏障正是通过阻止屏障两边的指令重排序来避免编译器和硬件的不正确优化而提出的一种解决办法</strong>。</p><p><strong>7.3.3、Java中内存屏障的主要类型</strong><br>Java内存屏障主要有Load和Store两类。 </p><p>对Load Barrier来说，在读指令前插入读屏障，<strong>可以让高速缓存中的数据失效，重新从主内存加载数据</strong> 。</p><p>对Store Barrier来说，在写指令之后插入写屏障，<strong>能让写入缓存的最新数据写回到主内存</strong>。</p><p>对于Load和Store，在实际使用中，又分为以下四种：</p><p>1、LoadLoad 屏障：序列：Load1，Loadload，Load2 。</p><blockquote><p>确保Load1所要读入的数据能够在被Load2和后续的load指令访问前读入。通常能执行预加载指令或/和支持乱序处理的处理器中需要显式声明Loadload屏障。</p></blockquote><p>2、StoreStore 屏障：序列：Store1，StoreStore，Store2 。</p><blockquote><p>确保Store1的数据在Store2以及后续Store指令操作相关数据之前<strong>对其它处理器可见</strong>（例如向主存刷新数据）。</p></blockquote><p>3、LoadStore 屏障：序列： Load1，LoadStore， Store2 。</p><blockquote><p>确保Load1的数据在Store2和后续Store指令<strong>被刷新之前读取</strong>。在等待Store指令可以越过loads指令的乱序处理器上需要使用LoadStore屏障。</p></blockquote><p>4、StoreLoad 屏障：序列: Store1，StoreLoad， Load2 。</p><blockquote><p>确保Store1的数据在被Load2和后续的Load指令读取之前<strong>对其他处理器可见</strong>。</p></blockquote><p><strong>7.3.4、Java中内存屏障的使用</strong></p><p><strong>1、Synchronized</strong></p><p>通过 Synchronized关键字包住的代码区域，当线程进入到该区域读取变量信息时，JVM保证读到的是最新的值。这是因为在同步区内对变量的写入操作，在离开同步区时就将当前线程内的数据刷新到内存中，而对数据的读取也不能从缓存读取，只能从内存中读取，保证了数据的读有效性。这就是插入了StoreStore屏障</p><p><strong>2、volatile</strong></p><p>知识点：如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p>使用了volatile修饰变量，则对变量的写操作，会插入StoreLoad屏障。</p><blockquote><p>大致过程：</p><p>1、在volatile变量的作用域插入内存屏障，防止指令重排序</p><p>2、通过内存屏障，强制将本CPU的修改操作立即写入主存。此时会利用缓存一致性机制，组织多个CPU同时刷主存的此数据区域。</p><p>3、本CPU回写volatile字段数据到主存后，其他CPU的嗅探技术会发现此字段已被回写过主存了，其他CPU的嗅探技术会将它的字段缓存设置为无效，其他CPU下次访问此字段时没，会强制从主存读最新值。</p></blockquote><p><strong>3、Unsafe类</strong></p><p>UNSAFE.putOrderedObject类似这样的方法,会插入StoreStore内存屏障 </p><p>Unsafe.putVolatiObject 则是插入了StoreLoad屏障</p><h2 id="7-4、Java的平台无关性"><a href="#7-4、Java的平台无关性" class="headerlink" title="7.4、Java的平台无关性"></a>7.4、Java的平台无关性</h2><ul><li>Java的平台无关性(一次编译、到处运行)得益于：<ul><li>1、统一的Class字节码文件格式；</li><li>2、统一的JVM 规范 (指令集，内存模型，操作数栈架构)；</li></ul></li><li>JVM将平台相关性的活给干了，屏蔽了差异。</li><li>JVM不止有”平台无关性”，还有”语言无关性”，只要最终能编译成符合Class字节码文件格式规范要求的，都能在JVM上运行。如：Coljure, Groovy, JRuby, Scala等</li></ul><h2 id="7-5、Java对象引用类型"><a href="#7-5、Java对象引用类型" class="headerlink" title="7.5、Java对象引用类型"></a>7.5、Java对象引用类型</h2><p>对象引用类型分为强引用、软引用、弱引用、虚引用。</p><ul><li><strong>强引用</strong>：就是我们一般声明对象时是虚拟机生成的引用，强引用环境下，垃圾回收时需要严格判断当前对象是否被强引用，如果被强引用，则不会被垃圾回收。<strong>对应到我们日常写的代码</strong>。</li><li><strong>软引用</strong>：软引用一般被<strong>作为缓存来使用</strong>。与强引用的区别是，软引用在垃圾回收时，<strong>虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收</strong>。如果剩余内存紧张，则虚拟机会回收软引用所引用的空间。 </li><li><strong>弱引用</strong>：弱引用与软引用类似，都是<strong>作为缓存来使用</strong>。但与软引用不同，弱引用在进行<strong>垃圾回收时，是一定会被回收掉</strong>的，因此其生命周期只存在于一个垃圾回收周期内。 <ul><li>“软引用”和“弱引用”比较少见。 他们一般被作为缓存使用，而且一般是在内存大小比较受限的情况下做为缓存。因为如果内存足够大的话，可以直接使用强引用作为缓存即可，同时可控性更高。</li></ul></li><li><strong>虚引用</strong>：使用虚引用的目的就是为了得知对象被GC的时机，可以利用虚引用来进行销毁前的一些操作，比如说资源释放等。虚引用一个很重要的用途就是用来做堆外内存的释放，<strong>DirectByteBuffer就是通过虚引用来实现堆外内存的释放的</strong>。</li></ul><h2 id="7-6-、容器化环境中的JVM内存设置须知"><a href="#7-6-、容器化环境中的JVM内存设置须知" class="headerlink" title="7.6 、容器化环境中的JVM内存设置须知"></a>7.6 、容器化环境中的JVM内存设置须知</h2><p>在JDK10前，JVM是无法感知容器环境存在的，JVM获取到的有关系统硬件的指标都是实际物理机的CPU和内存指标。这其实对于JVM运行环境来说是不合理的。</p><p>Java在JDK10以后，开始了对容器资源限制的支持（支持向linux cgroup获取容器内的硬件资源指标），可以使用<strong>-XX:+UseContainerSupport</strong>参数来指定JVM使用容器的内存指标，注：此参数是JVM内默认开启的。（其他类似的JVM还有：-XX:InitialRAMPercentage； -XX:MaxRAMPercentage等）</p><p>值得庆幸的是，其中一些功能已被移植到JDK-8u131及以后的版本。在JDK-8u131+及java9，需要加上”-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap”才能使得Xmx感知docker的memory limit。</p><p>我们知道JVM对于CPU和内存都有默认取值逻辑，且这个对于JVM的运行性能影响非常大。这个值设置的不对会严重影响线上应用的可用性和性能。</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004210626874.png" alt="image-20201004210626874"></p><p><u>推荐</u>：</p><p>建议大家部署Java应用时，必须设置明确的”Xms,Xmx”。减少外部依赖或假设，以减少未知风险的发生概率。</p><h2 id="7-7、怎么构造方法区OOM？"><a href="#7-7、怎么构造方法区OOM？" class="headerlink" title="7.7、怎么构造方法区OOM？"></a>7.7、怎么构造方法区OOM？</h2><p>先牢记知识点方法区存的是哪些东西：“<strong>已被虚拟机加载</strong>的类信息、常量、静态变量、编译器编译后的代码等数据”</p><p><strong>观察这些存放的信息里，哪几个在JVM运行期是动态的？</strong></p><ul><li>运行期产生大量的动态类。</li><li>持续高频使用String.intern()方法，产生大量常量。</li></ul><p><strong>怎么优化？</strong></p><ul><li>通过工具查看方法区大量的动态类的来源代码。</li><li>一般方法区的溢出是由于大量的动态类，而动态类往往来自于框架或三发SDK。基本没的干预，所以一般是调大方法区大小。</li></ul><h2 id="7-8、怎么构造Java内存泄露"><a href="#7-8、怎么构造Java内存泄露" class="headerlink" title="7.8、怎么构造Java内存泄露"></a>7.8、怎么构造Java内存泄露</h2><p>Java 中的内存泄露的情况:<strong>长生命周期的对象持有短生命周期对象的引用</strong>就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是<strong>因为长生命周期对象持有它的引用而导致不能被回收</strong>，这 就是 Java 中内存泄露的发生场景</p><p>例如</p><ul><li>缓存系统，我们加载了一个对 象放在缓存中 (例如放在一个全局 map 对象中)，然后一直不再 使用它，这个对象一直被缓存引用，但却不再被使用。</li><li>如果一个外部类的实例对象的方法返回了一个内部类的实例对象， 这个内部类对象被长期引用了，即使那个外部类实例对象不再被使 用，但由于内部类持久外部类的实例对象，这个外部类对象将不会 被垃圾回收，这也会造成内存泄露。</li><li>内存泄露的另外一种情况:当一个对象被存储进 HashSet 集合中 以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否 则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希 值就不同了，在这种情况下，即使在 contains 方法使用该对象的 当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不 到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前 对象，造成内存泄露。</li></ul><center><font size="8" face="微软雅黑"> &gt;&gt;&gt;&gt; 更多内容，很快到来 &lt;&lt;&lt;&lt; </font></center>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《一文就让你精通JVM》&quot;&gt;&lt;a href=&quot;#《一文就让你精通JVM》&quot; class=&quot;headerlink&quot; title=&quot;《一文就让你精通JVM》&quot;&gt;&lt;/a&gt;《一文就让你精通JVM》&lt;/h1&gt;&lt;p&gt;网上有关JVM的知识贴多如牛毛，其中有纷杂的零碎知识贴，也有整理优秀的长贴。信息量非常充分。&lt;/p&gt;
&lt;p&gt;但作为复习或整理JVM知识的而言，还可以有更好的学习用户体验和高效的方式。因此，就想尝试写一篇有关JVM知识点的“秘籍”，让初学者仅读此文就能快速精通JVM的知识脉络以及关键知识，也能让复习着快速反查知识和经验之谈。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;黄老师&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://veryjj.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API命名规范</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API命名规范/</id>
    <published>2018-09-30T09:46:20.000Z</published>
    <updated>2020-10-05T14:14:57.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API命名规范"><a href="#API命名规范" class="headerlink" title="API命名规范"></a>API命名规范</h1><h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h2><hr><h3 id="面向资源"><a href="#面向资源" class="headerlink" title="面向资源"></a>面向资源</h3><blockquote><p>同RESTful命名风格</p></blockquote><p>在大型系统中，常以”业务领域”视角进行模块划分，以达到业务”高内聚低耦合”的效果。</p><p>“业务领域”必有”数据对象”沉淀，<code>从宏观抽象的角度看，&quot;数据对象&quot;可统称为&quot;资源&quot;</code>，”业务领域”就是业务相近的”资源”的集合。</p><a id="more"></a><p><code>&quot;资源&quot;一定是业务抽象后的对象</code>：</p><ol><li>可以是具体的数据对象：<ul><li>商品</li><li>订单</li><li>合同</li><li>发票</li><li>采购计划</li><li>etc</li></ul></li><li>可以是抽象的对象概念：<ul><li>租户</li><li>用户</li><li>支付</li><li>文件</li><li>需求</li><li>etc</li></ul></li></ol><p><code>&quot;业务领域&quot;与&quot;业务领域&quot;之间的依赖，可理解为是对&quot;资源&quot;操作(读、写、通知)的依赖。</code></p><p><code>所以，API作为&quot;业务领域&quot;间沟通的手段，其应该(Should)以面向资源角度进行命名。</code></p><p>注：子资源，需要逐级索引命名，例如：修改-订单-商品：updateOrderItem。</p><hr><h3 id="单一视角"><a href="#单一视角" class="headerlink" title="单一视角"></a>单一视角</h3><ul><li>参见<a href="">单一视角原则</a></li></ul><hr><h3 id="动宾风格"><a href="#动宾风格" class="headerlink" title="动宾风格"></a>动宾风格</h3><p>API应该(Should)以<code>&quot;动宾短语&quot;风格命名</code>。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xxx.xxx.xxx.OrderService            // 上下文已涵盖Order语义</span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; save(...)   </span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; updateItem(Long orderId, List&lt;T&gt; items)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xxx.xxx.xxx.WCService               // 上下文未涵盖Order语义</span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; saveOrder(...)   </span><br><span class="line"></span><br><span class="line">Response&lt;Boolean&gt; removeOrder(Long orderId)   </span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; updateOrderItem(Long orderId, List&lt;T&gt; items) // 逐级索引子资源</span><br></pre></td></tr></table></figure><hr><h3 id="统一术语"><a href="#统一术语" class="headerlink" title="统一术语"></a>统一术语</h3><p>API命名统一”动词”术语、”名词”术语。优点是能风格一致，经验复用。</p><p>详见<a href="">政采云API术语参考</a></p><p>注：统一术语的节奏，参考研发级术语规范逐步执行：业务内统一、业务领域内统一、平台统一。</p><h5 id="错误实践-1：”商品”命名不统一"><a href="#错误实践-1：”商品”命名不统一" class="headerlink" title="错误实践-1：”商品”命名不统一"></a>错误实践-1：”商品”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">业务1：商品 -&gt; item ✔️</span><br><span class="line">业务2：商品 -&gt; items</span><br><span class="line">业务3: 商品 -&gt; product</span><br><span class="line">业务4：商品 -&gt; goods</span><br></pre></td></tr></table></figure><h5 id="错误实践-2：”特性”命名不统一"><a href="#错误实践-2：”特性”命名不统一" class="headerlink" title="错误实践-2：”特性”命名不统一"></a>错误实践-2：”特性”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：特性 -&gt; feature ✔️</span><br><span class="line">业务2: 特性 -&gt; character</span><br><span class="line">业务3：特性 -&gt; rule</span><br></pre></td></tr></table></figure><h5 id="错误实践-3：”金额”命名不统一"><a href="#错误实践-3：”金额”命名不统一" class="headerlink" title="错误实践-3：”金额”命名不统一"></a>错误实践-3：”金额”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：金额 -&gt; amount ✔️</span><br><span class="line">业务2: 金额 -&gt; money</span><br><span class="line">业务3：金额 -&gt; sum</span><br></pre></td></tr></table></figure><h5 id="错误实践-4：”校验”命名不统一"><a href="#错误实践-4：”校验”命名不统一" class="headerlink" title="错误实践-4：”校验”命名不统一"></a>错误实践-4：”校验”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：校验 -&gt; verify</span><br><span class="line">业务2: 校验 -&gt; check ✔️</span><br><span class="line">业务3：校验 -&gt; test</span><br></pre></td></tr></table></figure><h5 id="错误实践-5：”分页”命名不统一"><a href="#错误实践-5：”分页”命名不统一" class="headerlink" title="错误实践-5：”分页”命名不统一"></a>错误实践-5：”分页”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：分页 -&gt; page</span><br><span class="line">业务2: 分页 -&gt; paging✔️</span><br><span class="line">业务3：分页 -&gt; list</span><br></pre></td></tr></table></figure><h5 id="错误实践-6：”创建”命名不统一"><a href="#错误实践-6：”创建”命名不统一" class="headerlink" title="错误实践-6：”创建”命名不统一"></a>错误实践-6：”创建”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：创建 -&gt; save✔️</span><br><span class="line">业务2: 创建 -&gt; create</span><br><span class="line">业务3：创建 -&gt; insert</span><br></pre></td></tr></table></figure><h5 id="错误实践-7：”删除”命名不统一"><a href="#错误实践-7：”删除”命名不统一" class="headerlink" title="错误实践-7：”删除”命名不统一"></a>错误实践-7：”删除”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">业务1：删除 -&gt; delete</span><br><span class="line">业务2: 删除 -&gt; remove✔️</span><br><span class="line">业务3：删除 -&gt; disable </span><br><span class="line">业务3：删除 -&gt; cancel</span><br></pre></td></tr></table></figure><h5 id="错误实践-8：”检索”命名不统一"><a href="#错误实践-8：”检索”命名不统一" class="headerlink" title="错误实践-8：”检索”命名不统一"></a>错误实践-8：”检索”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：搜索 -&gt; query✔️</span><br><span class="line">业务2: 搜索 -&gt; search</span><br><span class="line">业务3：搜索 -&gt; list</span><br></pre></td></tr></table></figure><hr><h2 id="常见API命名参考"><a href="#常见API命名参考" class="headerlink" title="常见API命名参考"></a>常见API命名参考</h2><blockquote><p>假设：未按资源划分Service(上下文未界定资源域)的情况</p></blockquote><blockquote><p>“XXX”指某一种资源，”xxx”指”XXX”下的子资源</p></blockquote><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;Page&lt;T&gt;&gt; pagingXXX(QueryDTO q)    //用对象包装查询条件</span><br></pre></td></tr></table></figure><ul><li>错误实践    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;Page&lt;T&gt;&gt; pagingXXX(String name, String code, Long orgId, Long creatorId, Integer pageNo, Integer PageSize)</span><br></pre></td></tr></table></figure><p>以上错误实践缺点：<br>1、对于调用方来说，无论以什么条件查询，都需要逐个条件传参<br>2、API对扩展不友好，一旦想增加查询条件，API就不兼容。</p><h3 id="列表查询"><a href="#列表查询" class="headerlink" title="列表查询"></a>列表查询</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;List&lt;T&gt;&gt; listXXX(...)</span><br></pre></td></tr></table></figure><h3 id="获取单个详情"><a href="#获取单个详情" class="headerlink" title="获取单个详情"></a>获取单个详情</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; getXXX(Long id) </span><br><span class="line"></span><br><span class="line">类同条件，用重载</span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; getXXX(String code)</span><br></pre></td></tr></table></figure><ul><li>错误实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; getXXXById(Long id) </span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; getXXXByCode(String code)</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>API契约应该由”API名 + 入参”共同组成，而不是只靠”API名”说明一切。</li><li>API方法支持获取单个详情的方式，可以通过入参字段名自解释。无需再用”By***”来额外标注。</li><li>不带”By***”声明的方法语义上更具有扩展性。</li></ol><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; saveXXX(...)      //参照《阿里巴巴Java编码规范》</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; removeXXX(...)      //参照《阿里巴巴Java编码规范》</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; updateXXX(...)      //参照《阿里巴巴Java编码规范》</span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; updateXXXxxx(...)   //更新主资源下的子资源</span><br></pre></td></tr></table></figure><h3 id="提审"><a href="#提审" class="headerlink" title="提审"></a>提审</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; submitXXX(...)</span><br></pre></td></tr></table></figure><h3 id="审核"><a href="#审核" class="headerlink" title="审核"></a>审核</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; auditXXX(...)</span><br></pre></td></tr></table></figure><h3 id="退回（退回到流程中的某一步）"><a href="#退回（退回到流程中的某一步）" class="headerlink" title="退回（退回到流程中的某一步）"></a>退回（退回到流程中的某一步）</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; returnXXX(...)</span><br></pre></td></tr></table></figure><h3 id="撤销（退回到流程的第一步）"><a href="#撤销（退回到流程的第一步）" class="headerlink" title="撤销（退回到流程的第一步）"></a>撤销（退回到流程的第一步）</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; cancelXXX(...)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;API命名规范&quot;&gt;&lt;a href=&quot;#API命名规范&quot; class=&quot;headerlink&quot; title=&quot;API命名规范&quot;&gt;&lt;/a&gt;API命名规范&lt;/h1&gt;&lt;h2 id=&quot;命名风格&quot;&gt;&lt;a href=&quot;#命名风格&quot; class=&quot;headerlink&quot; title=&quot;命名风格&quot;&gt;&lt;/a&gt;命名风格&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;面向资源&quot;&gt;&lt;a href=&quot;#面向资源&quot; class=&quot;headerlink&quot; title=&quot;面向资源&quot;&gt;&lt;/a&gt;面向资源&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;同RESTful命名风格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在大型系统中，常以”业务领域”视角进行模块划分，以达到业务”高内聚低耦合”的效果。&lt;/p&gt;
&lt;p&gt;“业务领域”必有”数据对象”沉淀，&lt;code&gt;从宏观抽象的角度看，&amp;quot;数据对象&amp;quot;可统称为&amp;quot;资源&amp;quot;&lt;/code&gt;，”业务领域”就是业务相近的”资源”的集合。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="API命名" scheme="https://veryjj.github.io/tags/API%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API错误返回规范</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E9%94%99%E8%AF%AF%E8%BF%94%E5%9B%9E%E8%A7%84%E8%8C%83/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API错误返回规范/</id>
    <published>2018-09-30T09:32:14.000Z</published>
    <updated>2020-10-05T14:14:57.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API错误返回规范"><a href="#API错误返回规范" class="headerlink" title="API错误返回规范"></a>API错误返回规范</h1><h2 id="禁止通过抛异常形式返回API业务错误"><a href="#禁止通过抛异常形式返回API业务错误" class="headerlink" title="禁止通过抛异常形式返回API业务错误"></a>禁止通过抛异常形式返回API业务错误</h2><p>API禁止抛Checked异常，即业务处理上的参数错误、逻辑错误、业务错误等禁止通过抛异常形式返回，应用Response#code, message表达业务错误。</p><p>注：不要逼调用方到处写try{}catch()。</p><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; saveDesposit(...);</span><br></pre></td></tr></table></figure><ul><li>反例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T saveDesposit(...) throws ServiceException, IllegalArgumentException, ValidationException;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="禁止通过抛异常形式返回API业务错误-1"><a href="#禁止通过抛异常形式返回API业务错误-1" class="headerlink" title="禁止通过抛异常形式返回API业务错误"></a>禁止通过抛异常形式返回API业务错误</h2><p>API禁止抛Checked异常，即业务处理上的参数错误、逻辑错误、业务错误等禁止通过抛异常形式返回，应用Response#code, message表达业务错误。</p><p>注：不要逼调用方到处写try{}catch()。</p><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; saveDesposit(...);</span><br></pre></td></tr></table></figure><ul><li>反例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T saveDesposit(...) throws ServiceException, IllegalArgumentException, ValidationException;</span><br></pre></td></tr></table></figure><h2 id="需要调用方做错误细分处理的，API提供方务必一并提供判断工具类"><a href="#需要调用方做错误细分处理的，API提供方务必一并提供判断工具类" class="headerlink" title="需要调用方做错误细分处理的，API提供方务必一并提供判断工具类"></a>需要调用方做错误细分处理的，API提供方务必一并提供判断工具类</h2><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void saveXXX()&#123;</span><br><span class="line">    Response&lt;T&gt; result = xxxWriteService(...)</span><br><span class="line">    if (!result.isSuccess())&#123;</span><br><span class="line">        if (xxxUtils.isBankUnSupport(result.getCode))&#123;   &lt;&lt;&lt;API提供方提供工具类解析code含义，且code含义可持续迭代更新，调用方无感知。</span><br><span class="line">            //银行渠道未开通，需要特殊提示</span><br><span class="line">            ...</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void saveXXX()&#123;</span><br><span class="line">    Response&lt;T&gt; result = xxxWriteService(...)</span><br><span class="line">    if (!result.isSuccess())&#123;</span><br><span class="line">        if (&quot;10101&quot;.equals(result.getCode))&#123;   &lt;&lt;&lt;调用方按API提供方的错误码值做硬编码，代码耦合。</span><br><span class="line">            //银行渠道未开通，需要特殊提示</span><br><span class="line">            ...</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【推荐】API返回可直接显示给用户的中文提示信息"><a href="#【推荐】API返回可直接显示给用户的中文提示信息" class="headerlink" title="【推荐】API返回可直接显示给用户的中文提示信息"></a>【推荐】API返回可直接显示给用户的中文提示信息</h2><p>API失败时，只有API实现方最清楚是什么原因，该怎么提示。那么，请提供对应的提示信息。</p><p>我们系统中存在一些用国际化风格的error message，而当前的国际化实现方式真如你想的那么好用吗？</p><h4 id="error-message国际化原理："><a href="#error-message国际化原理：" class="headerlink" title="error message国际化原理："></a><strong>error message国际化原理：</strong></h4><ul><li>代码中的提示信息国际化配置文件</li></ul><p><img src="/2018/09/30/服务API设计之——API错误返回规范/img-1.png" alt="image-20180930154223074"></p><ul><li>国际化提示原理</li></ul><p><img src="/2018/09/30/服务API设计之——API错误返回规范/img-2.png" alt="image-20180930162340975"></p><p>1) 提示信息国际化的行为发生在Web层，Web层启动时会加载Web层的resources/messages提示信息文件</p><p>2)当REST API需要返回提示信息时，Web会根据HTTP 请求中的Locale值（例如：zh_CN、zh_TW、en_US、es_ES_Traditional_WIN等）来决定返回哪一种语言的提示信息。将errorMessage以此种语言方式返回给浏览器进行提示。</p><p>问题：</p><p>1）在分布式系统中，各个应用按领域自治，其resources/messages只维护了自身业务需要的errorMessage。</p><p>2）当图中C Service 将errorMessage = template.status.not.match 返回给 XX Service，XX Service直接透传给XX Web的情况下，XX Web的resources/messages是不包括template.status.not.match的，所以此errorMessage将无法正确的展示其本应该提示的信息。</p><p>所以，推荐API返回可直接显示给用户的中文提示信息。</p><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(&quot;模板配置正在审核中，请在审核完成后再更新&quot;);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反例： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(&quot;模板管理状态机异常&quot;);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【推荐】返回具备可读性，引导性的错误提示信息"><a href="#【推荐】返回具备可读性，引导性的错误提示信息" class="headerlink" title="【推荐】返回具备可读性，引导性的错误提示信息"></a>【推荐】返回具备可读性，引导性的错误提示信息</h2><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(&quot;模板配置正在审核中，请在审核完成后再更新&quot;);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反例：</li></ul><p>例1 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(&quot;模板管理状态机异常&quot;);  &lt;&lt;&lt;&lt; 你作为用户，是不是吓一跳？</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(e.getMessage());    &lt;&lt;&lt;&lt; message谁都看不懂，没有任何意义</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;API错误返回规范&quot;&gt;&lt;a href=&quot;#API错误返回规范&quot; class=&quot;headerlink&quot; title=&quot;API错误返回规范&quot;&gt;&lt;/a&gt;API错误返回规范&lt;/h1&gt;&lt;h2 id=&quot;禁止通过抛异常形式返回API业务错误&quot;&gt;&lt;a href=&quot;#禁止通过抛异常形式返回API业务错误&quot; class=&quot;headerlink&quot; title=&quot;禁止通过抛异常形式返回API业务错误&quot;&gt;&lt;/a&gt;禁止通过抛异常形式返回API业务错误&lt;/h2&gt;&lt;p&gt;API禁止抛Checked异常，即业务处理上的参数错误、逻辑错误、业务错误等禁止通过抛异常形式返回，应用Response#code, message表达业务错误。&lt;/p&gt;
&lt;p&gt;注：不要逼调用方到处写try{}catch()。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正例：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Response&amp;lt;T&amp;gt; saveDesposit(...);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;反例：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;T saveDesposit(...) throws ServiceException, IllegalArgumentException, ValidationException;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="错误码" scheme="https://veryjj.github.io/tags/%E9%94%99%E8%AF%AF%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API版本规范</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E7%89%88%E6%9C%AC%E8%A7%84%E8%8C%83/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API版本规范/</id>
    <published>2018-09-30T09:32:07.000Z</published>
    <updated>2020-10-05T14:14:57.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API版本规范"><a href="#API版本规范" class="headerlink" title="API版本规范"></a>API版本规范</h1><h2 id="发布RELEASE版本"><a href="#发布RELEASE版本" class="headerlink" title="发布RELEASE版本"></a>发布RELEASE版本</h2><p>正式发布的api包必须是RELEASE版本</p><p>eg.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.gov.zcy.paas.template&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;template-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="版本号风格"><a href="#版本号风格" class="headerlink" title="版本号风格"></a>版本号风格</h2><p>使用 《<a href="https://semver.org/" target="_blank" rel="noopener">Semantic Versioning</a>》风格</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Version号由 “MAJOR.MINOR.PATCH” 三段组合构成，version号增加含义：</p><ol><li>MAJOR version：【主版本号】代表API发生了不兼容的变更，即使是微小的不兼容。</li><li>MINOR version：【次版本号】代表以兼容的方式新增了功能、特性</li><li>PATCH version：【补丁版本号】代表以兼容的方式做了bugfix</li></ol><h3 id="用法-FAQ"><a href="#用法-FAQ" class="headerlink" title="用法 / FAQ"></a>用法 / FAQ</h3><h3 id="版本号以0开始"><a href="#版本号以0开始" class="headerlink" title="版本号以0开始"></a>版本号以0开始</h3><ul><li>X.Y.Z 三个版本号都是以0开始。</li><li>【特别注意】当版本号是 “1.0.9.RELEASE”时，它的下一个补丁版本号是”1.0.10.RELEASE”  ！！！ <ul><li>而不是”1.1.0.RELEASE”，这里不存在满十进位之说。</li></ul></li></ul><h3 id="初始-MAJOR-version"><a href="#初始-MAJOR-version" class="headerlink" title="初始 MAJOR version"></a>初始 MAJOR version</h3><ul><li>初始MAJOR version以0开始，代表业务的初始开发阶段，这过程中功能上任何改变都可能发生，此时的API是不稳定的。</li><li>初始版本一旦发布生产环境，即将MAJOR version变更为1，即 1.0.0.RELEASE。是第一个基线版本。</li></ul><h3 id="预发布版本"><a href="#预发布版本" class="headerlink" title="预发布版本"></a>预发布版本</h3><ul><li>可以通过在补丁版本之后紧跟附加连字符和一系列点分隔标识符来表示预发布版本。标识符必须仅包含ASCII字母数字和连字符[0-9A-Za-z-]。标识符不能为空。数字标识符不得包含前导零。</li><li>预发布版本的优先级低于关联的普通版本。</li><li>预发布版本表示版本不稳定，可能无法满足其关联的正常版本所表示的预期兼容性要求。示例：1.0.0-alpha，1.0.0-alpha.1,1.0.0-0.3.7,1.0.0-x.7.z.92</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;API版本规范&quot;&gt;&lt;a href=&quot;#API版本规范&quot; class=&quot;headerlink&quot; title=&quot;API版本规范&quot;&gt;&lt;/a&gt;API版本规范&lt;/h1&gt;&lt;h2 id=&quot;发布RELEASE版本&quot;&gt;&lt;a href=&quot;#发布RELEASE版本&quot; class=&quot;headerlink&quot; title=&quot;发布RELEASE版本&quot;&gt;&lt;/a&gt;发布RELEASE版本&lt;/h2&gt;&lt;p&gt;正式发布的api包必须是RELEASE版本&lt;/p&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;cn.gov.zcy.paas.template&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;template-api&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;2.1.1.RELEASE&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;版本号风格&quot;&gt;&lt;a href=&quot;#版本号风格&quot; class=&quot;headerlink&quot; title=&quot;版本号风格&quot;&gt;&lt;/a&gt;版本号风格&lt;/h2&gt;&lt;p&gt;使用 《&lt;a href=&quot;https://semver.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Semantic Versioning&lt;/a&gt;》风格&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="API版本" scheme="https://veryjj.github.io/tags/API%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API参数规范</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E5%8F%82%E6%95%B0%E8%A7%84%E8%8C%83/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API参数规范/</id>
    <published>2018-09-30T09:32:03.000Z</published>
    <updated>2020-10-05T14:14:57.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【强制】字段名称用小驼峰风格"><a href="#【强制】字段名称用小驼峰风格" class="headerlink" title="【强制】字段名称用小驼峰风格"></a>【强制】字段名称用小驼峰风格</h3><h3 id="【强制】Service-API返回值必须使用Response包装"><a href="#【强制】Service-API返回值必须使用Response包装" class="headerlink" title="【强制】Service API返回值必须使用Response包装"></a>【强制】Service API返回值必须使用Response包装</h3><ul><li>Service API返回值强制要求进行通用包装，例如：Response。</li><li><p>Response的作用：</p><ol><li>统一方法表示API调用是否成功</li><li>API调用失败时，统一格式反馈错误Code，错误Message</li><li>统一的Response易于调用方经验复用，框架集成</li></ol></li><li><p>作为API调用方，其编码诉求很简单：</p><ol><li>API调用是否成功；</li><li>调用不成功时，提示文案是什么；</li></ol></li><li><p>调用方几不想：</p><ol><li>不想关心API内部有多牛逼</li><li>不想关心API可能会抛的各种Exception，以及因此不得不做各种异常处理</li></ol></li><li><p>关于当前不统一的Response</p><ul><li>【新业务】【强制】使用架构组定义的统一Response：<a href="http://confluence.cai-inc.com/pages/viewpage.action?pageId=6623775" target="_blank" rel="noopener">ZCY Response</a></li><li>目前业务方有自定义Result/Response，风格和作用大同小异。有更好的设计可以自荐给架构组集成，杜绝各自开辟重复的新定义。</li></ul></li></ul><a id="more"></a><h3 id="【强制】杜绝完全不规范的缩写，避免望文不知义。（国际通用缩写除外）"><a href="#【强制】杜绝完全不规范的缩写，避免望文不知义。（国际通用缩写除外）" class="headerlink" title="【强制】杜绝完全不规范的缩写，避免望文不知义。（国际通用缩写除外）"></a>【强制】杜绝完全不规范的缩写，避免望文不知义。（国际通用缩写除外）</h3><ul><li>错误实践<ul><li>AbstractClass“缩写”命名成 AbsClass;</li><li>condition“缩写”命名成 condi；</li><li>此类随意缩写严重降低了代码的可阅读性。</li></ul></li></ul><h3 id="【强制】禁止使用-Map-作为参数类型"><a href="#【强制】禁止使用-Map-作为参数类型" class="headerlink" title="【强制】禁止使用 Map 作为参数类型"></a>【强制】禁止使用 Map 作为参数类型</h3><p>Map&lt;K,V&gt;机制非常灵活，但这样的灵活却是负作用巨大。</p><ol><li>Map的数据说明是晦涩的，调用方、实现方之间需要具有隐式的契约解释支持哪些Key，每个Key的Value是什么类型。增加了双方的使用复杂度。</li><li>Map&lt;K,V&gt;不可被校验。加之第1条的使用复杂度，导致使用上非常容易出错。</li><li>用Map类型字段做预留扩展性的设计都是不优雅的设计。</li></ol><p>注：参数中的调用方自定义数据部分允许使用Map。API提供方不关系、不解析、只透传。</p><h3 id="【强制】业务对象-查询条件用DTO封装，禁止以入参方式平铺字段。"><a href="#【强制】业务对象-查询条件用DTO封装，禁止以入参方式平铺字段。" class="headerlink" title="【强制】业务对象/查询条件用DTO封装，禁止以入参方式平铺字段。"></a>【强制】业务对象/查询条件用DTO封装，禁止以入参方式平铺字段。</h3><ul><li>正确实践</li></ul><p>分页查询，将查询条件以DTO方式包装。</p><p>Dubbo序列化特点：</p><ul><li>Dubbo API的POJO类中，UID不一致：没关系。</li><li>Dubbo API的POJO类中，字段数量不一致：没关系，只要字段名和类型一致，数据能反序列化成功。</li><li>发送方比接收方的字段多：没关系。</li><li>发送方比接收方的字段少：没关系。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;Page&lt;T&gt;&gt; pagingXXX(QueryDTO q)</span><br></pre></td></tr></table></figure><ul><li>错误实践    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;Page&lt;T&gt;&gt; pagingXXX(String name, String code, Long orgId, Long creatorId, Integer pageNo, Integer PageSize)</span><br></pre></td></tr></table></figure><p>以上错误实践缺点：<br>1、对于调用方来说，无论以什么条件查询，都需要逐个条件传参。<br>2、API对扩展不友好，一旦想增加查询条件，API就不兼容。</p><h3 id="【推荐】DTO字段设置JSR303-Annotation进行基础校验"><a href="#【推荐】DTO字段设置JSR303-Annotation进行基础校验" class="headerlink" title="【推荐】DTO字段设置JSR303 Annotation进行基础校验"></a>【推荐】DTO字段设置JSR303 Annotation进行基础校验</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ZcyPayFacade &#123;</span><br><span class="line">    Result&lt;Boolean&gt; validTradePay(@NotNull @Valid TradePayPO tradePayPO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class TradePayPO implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(max = 15)</span><br><span class="line">    /** 业务交易编号(订单编号) */</span><br><span class="line">    private String businessTradeNo;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 业务渠道：1-订阅，2-CA</span><br><span class="line">     * @see BusinessTypeEnum</span><br><span class="line">     *</span><br><span class="line">     * */</span><br><span class="line">    @NotNull</span><br><span class="line">    @Range(min = 1, max = 2)</span><br><span class="line">    private Integer businessType;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    /** 商户名称(商家) */</span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(max = 50)</span><br><span class="line">    private String merchantName;</span><br><span class="line"></span><br><span class="line">    /** 订单标题（即商品名称），粗略描述用户的支付目的。如“喜士多（浦东店）消费”*/</span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(max = 256)</span><br><span class="line">    private String orderSubject;</span><br><span class="line"></span><br><span class="line">    /** 订单描述（即商品描述），可以对交易或商品进行一个详细地描述，比如填写&quot;购买商品2件共15.00元&quot;*/</span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(max = 128)</span><br><span class="line">    private String orderBody;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【推荐】在客户端完成基础字段校验"><a href="#【推荐】在客户端完成基础字段校验" class="headerlink" title="【推荐】在客户端完成基础字段校验"></a>【推荐】在客户端完成基础字段校验</h3><ul><li>方式1：【推荐】自定义Dubbo Filter实现通用拦截、校验。</li><li>方式2：【推荐】通过Builder模式构建入参对象。</li><li>方式3：【不推荐】Dubbo 客户端参数校验，要求consumer方设置validation=”true”，<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/parameter-validation.html" target="_blank" rel="noopener">Dubbo 客户端参数校验</a>。缺点：以抛异常方式处理校验失败，需要业务方额外处理Exception。而且，IDE并不会提示consumer方需要处理ConstraintViolationException。</li><li>方式4：Dubbo方式，local-stub特性。实现较复杂，校验代码通用性低。<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html" target="_blank" rel="noopener">Dubbo local-stub</a></li></ul><hr><h3 id="注：此规范与《阿里巴巴Java编码规范》互补，同时有效。"><a href="#注：此规范与《阿里巴巴Java编码规范》互补，同时有效。" class="headerlink" title="注：此规范与《阿里巴巴Java编码规范》互补，同时有效。"></a>注：此规范与《阿里巴巴Java编码规范》互补，同时有效。</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【强制】字段名称用小驼峰风格&quot;&gt;&lt;a href=&quot;#【强制】字段名称用小驼峰风格&quot; class=&quot;headerlink&quot; title=&quot;【强制】字段名称用小驼峰风格&quot;&gt;&lt;/a&gt;【强制】字段名称用小驼峰风格&lt;/h3&gt;&lt;h3 id=&quot;【强制】Service-API返回值必须使用Response包装&quot;&gt;&lt;a href=&quot;#【强制】Service-API返回值必须使用Response包装&quot; class=&quot;headerlink&quot; title=&quot;【强制】Service API返回值必须使用Response包装&quot;&gt;&lt;/a&gt;【强制】Service API返回值必须使用Response包装&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Service API返回值强制要求进行通用包装，例如：Response。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Response的作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统一方法表示API调用是否成功&lt;/li&gt;
&lt;li&gt;API调用失败时，统一格式反馈错误Code，错误Message&lt;/li&gt;
&lt;li&gt;统一的Response易于调用方经验复用，框架集成&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;作为API调用方，其编码诉求很简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;API调用是否成功；&lt;/li&gt;
&lt;li&gt;调用不成功时，提示文案是什么；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用方几不想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不想关心API内部有多牛逼&lt;/li&gt;
&lt;li&gt;不想关心API可能会抛的各种Exception，以及因此不得不做各种异常处理&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于当前不统一的Response&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【新业务】【强制】使用架构组定义的统一Response：&lt;a href=&quot;http://confluence.cai-inc.com/pages/viewpage.action?pageId=6623775&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ZCY Response&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;目前业务方有自定义Result/Response，风格和作用大同小异。有更好的设计可以自荐给架构组集成，杜绝各自开辟重复的新定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="API规范" scheme="https://veryjj.github.io/tags/API%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API设计原则</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API设计原则/</id>
    <published>2018-09-30T09:31:47.000Z</published>
    <updated>2020-10-05T14:14:57.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="你是否也感同身受？"><a href="#你是否也感同身受？" class="headerlink" title="你是否也感同身受？"></a>你是否也感同身受？</h2><ol><li>对接XX业务时，XX业务具备的功能和API全靠跑业务负责人那反复逐个询问、确认。用哪个API；怎么用；有没有限制；等等</li><li>各个业务间，甚至同一业务内，API风格不统一。<ul><li>API命名：按自然语义全翻译的；按属性角度定义的；按操作角度定义的；动宾、非动宾的；复数、非复数的；等等</li><li>API入参：带Map的；相同语义字段名称不一样；</li><li>API出参：有包装Resoponse的；直接返回结果数据的；相同数据，返回格式和字段名称有差别的；</li><li>错误信息：直接返回中文提示的；返回提示信息编码的；返回异常类型的；等等</li></ul></li><li>XX业务API性能方面未知。</li><li>随着业务的演进，开放的API持续在增加，但类同的很多</li></ol><a id="more"></a><h5 id="API编码规范迫在眉睫"><a href="#API编码规范迫在眉睫" class="headerlink" title="API编码规范迫在眉睫"></a><strong>API编码规范迫在眉睫</strong></h5><hr><h2 id="优秀API的特质"><a href="#优秀API的特质" class="headerlink" title="优秀API的特质"></a>优秀API的特质</h2><ol><li>自解释<ul><li>从API本身一眼就能看懂API是干什么的，支持的用法，适用的场景，异常的处理等</li></ul></li><li>易学习<ul><li>有完善的文档，以及提供尽可能多的示例和可copy－paste的代码。</li></ul></li><li>易使用<ul><li>功能强大，但使用简单。不增加调用方的使用成本（例如要求业务方用API时需要额外的配置和依赖），不暴露复杂的细节、冗长的使用流程给调用方感知。调用方只做最小的感知和最少的传参。</li></ul></li><li>难误用<ul><li>优秀的API可以使有经验的开发直接使用API而不需要阅读文档。</li><li>充分的静态检查、动态校验、显式的异常说明、有效的错误提示。</li></ul></li></ol><hr><h2 id="ZCY-API-设计原则"><a href="#ZCY-API-设计原则" class="headerlink" title="ZCY API 设计原则"></a>ZCY API 设计原则</h2><h3 id="1-充分原则"><a href="#1-充分原则" class="headerlink" title="1. 充分原则"></a>1. 充分原则</h3><p>不是随便一个功能就要有个接口，也不是随便一个需求就要加个接口。</p><p>每新建一个接口，要有充分的理由和考虑，即这个接口的存在是十分有意义和价值的。无意义的接口不仅增加了维护的难度，更重要是对于程序的可控性的大大降低，接口也会十分臃肿。</p><h3 id="2-单一视角原则"><a href="#2-单一视角原则" class="headerlink" title="2. 单一视角原则"></a>2. 单一视角原则</h3><p>设计接口时，分析的角度要统一。否则会造成接口结构的混乱。例如：不要一会以角色的角度设计，一会儿就要以功能的角度设计。</p><p>推荐：以”属性对象 + 行为”的视角定义API</p><h3 id="3-单一功能原则"><a href="#3-单一功能原则" class="headerlink" title="3. 单一功能原则"></a>3. 单一功能原则</h3><p>每个API接口应该只专注一件事，并做好。产品概念简单、关系清楚。功能模棱两可，诸多特殊逻辑的API肯定不是个优雅的API，且会造成功能类似重复的API。</p><p>注：如果API它很难命名，那么这或许是个不好的征兆，好的名称可以驱动开发、并且只需拆分与合并模块即可。</p><p>功能大而全的API在灵活性、简单性方面肯定捉襟见肘。定义API的粒度之前，建议先将业务分领域、划边界，以此来提取业务对象，然后再根据业务对象用例来设计单一功能的API。</p><p>比如：查询会员，可能除了查询会员表外还要获取该会员的其他必要信息，但不要在查询会员的同时还有修改权限等类似的其他业务功能，应该分成两个接口执行。</p><h3 id="4-简单原则"><a href="#4-简单原则" class="headerlink" title="4. 简单原则"></a>4. 简单原则</h3><p>接口设计简单、清晰。API执行的功能可以很丰富、很强大，但API声明和用法一定要尽量的简单，不能将功能的丰富通过复杂的用法来实现，这会导致API功能不单一，演进不可控。</p><p>最终的评审要看API的简单易用程度。</p><ul><li>你写的例子，能不能让你的代码看起来更简单？</li><li>你是不是强迫调用方关注/提供他们不在乎的选项/配置？</li><li>有没有毫无价值的额外步骤？</li></ul><p>编写的代码一定要易于读、易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</p><h3 id="5-抽象原则"><a href="#5-抽象原则" class="headerlink" title="5. 抽象原则"></a>5. 抽象原则</h3><p>API的入参、出参所述的对象、属性，一定是按业务特性进行抽象后的实体。误将底层数据模型概念如实的反应到API上。抽象API、抽象对象实体更宏观，具有更好的适用性、兼容性、扩展性。</p><h3 id="6-兼容扩展原则"><a href="#6-兼容扩展原则" class="headerlink" title="6. 兼容扩展原则"></a>6. 兼容扩展原则</h3><p>对扩展开放，对修改关闭。保证API的向后兼容。</p><p>扩展参数应当是便利的，保证后续类似的需求，可以在已有的API上通过兼容扩展的方式实现。</p><h3 id="7-最小惊讶原则"><a href="#7-最小惊讶原则" class="headerlink" title="7. 最小惊讶原则"></a>7. 最小惊讶原则</h3><p>代码应该尽可能减少让读者惊喜。业务API只需根据需求来设计即可，不需要刻意去设计一下复杂无用、华而不实的API，以免弄巧成拙。</p><h3 id="8-低耦合原则"><a href="#8-低耦合原则" class="headerlink" title="8. 低耦合原则"></a>8. 低耦合原则</h3><p>API应该减少对其他业务代码的依赖关系。低耦合往往是完美结构系统和优秀设计的标志。</p><p>耦合的种类：</p><ul><li>代码实现业务逆向调用。</li><li>条件逻辑依赖耦合。例如：此API在处理国税网超订单类型时，需要额外发送结算支付凭证上传的事件MQ出来。</li><li>耦合API无关的业务行为。例如：采购计划链路日志API被调用时，若是项目采购委托单的情况，需要额外调用公告的API拉取链路信息，新建成为一条此委托单的一条链路日志。</li></ul><h3 id="9-正交原则"><a href="#9-正交原则" class="headerlink" title="9. 正交原则"></a>9. 正交原则</h3><p>正交性是指改变某个特性而不会影响到其他的特性。</p><p>API之间的功能应该成正交性，无功能重合。API之间应该是互相补充的关系。</p><h3 id="10-易测试原则"><a href="#10-易测试原则" class="headerlink" title="10. 易测试原则"></a>10. 易测试原则</h3><p>对于API调用者而言，API应该是可被测试且易于被测试的。测试API不需要依赖额外的环境、容器、配置、公共服务等。</p><p>对可测试友好的API也是可被有效集成测试的前提。</p><h3 id="11-统一原则"><a href="#11-统一原则" class="headerlink" title="11. 统一原则"></a>11. 统一原则</h3><p>API要具备统一的命名、统一的入/出参规范、统一的异常规范、统一的错误码规范、统一的版本规范等。</p><p>统一规范的API优点：</p><ul><li>易于被框架集成、处理</li><li>有助于API调用方、API提供方开发经验复用</li><li>避免犯错，避免误用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;你是否也感同身受？&quot;&gt;&lt;a href=&quot;#你是否也感同身受？&quot; class=&quot;headerlink&quot; title=&quot;你是否也感同身受？&quot;&gt;&lt;/a&gt;你是否也感同身受？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;对接XX业务时，XX业务具备的功能和API全靠跑业务负责人那反复逐个询问、确认。用哪个API；怎么用；有没有限制；等等&lt;/li&gt;
&lt;li&gt;各个业务间，甚至同一业务内，API风格不统一。&lt;ul&gt;
&lt;li&gt;API命名：按自然语义全翻译的；按属性角度定义的；按操作角度定义的；动宾、非动宾的；复数、非复数的；等等&lt;/li&gt;
&lt;li&gt;API入参：带Map的；相同语义字段名称不一样；&lt;/li&gt;
&lt;li&gt;API出参：有包装Resoponse的；直接返回结果数据的；相同数据，返回格式和字段名称有差别的；&lt;/li&gt;
&lt;li&gt;错误信息：直接返回中文提示的；返回提示信息编码的；返回异常类型的；等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;XX业务API性能方面未知。&lt;/li&gt;
&lt;li&gt;随着业务的演进，开放的API持续在增加，但类同的很多&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="API设计原则" scheme="https://veryjj.github.io/tags/API%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JStorm-分享资料</title>
    <link href="https://veryjj.github.io/2018/09/16/JStorm-%E5%88%86%E4%BA%AB%E8%B5%84%E6%96%99/"/>
    <id>https://veryjj.github.io/2018/09/16/JStorm-分享资料/</id>
    <published>2018-09-16T04:34:33.000Z</published>
    <updated>2020-10-05T14:14:57.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JStorm分享-课件资料"><a href="#JStorm分享-课件资料" class="headerlink" title="JStorm分享-课件资料"></a>JStorm分享-课件资料</h2><p><img src="/2018/09/16/JStorm-分享资料/幻灯片01.png" alt="幻灯片01"></p><a id="more"></a><p><img src="/2018/09/16/JStorm-分享资料/幻灯片02.png" alt="幻灯片02"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片03.png" alt="幻灯片03"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片04.png" alt="幻灯片04"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片05.png" alt="幻灯片05"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片06.png" alt="幻灯片06"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片07.png" alt="幻灯片07"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片08.png" alt="幻灯片08"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片09.png" alt="幻灯片09"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片10.png" alt="幻灯片10"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片11.png" alt="幻灯片11"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片12.png" alt="幻灯片12"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片13.png" alt="幻灯片13"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片14.png" alt="幻灯片14"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片15.png" alt="幻灯片15"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片16.png" alt="幻灯片16"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片17.png" alt="幻灯片17"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片18.png" alt="幻灯片18"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片19.png" alt="幻灯片19"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片20.png" alt="幻灯片20"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片21.png" alt="幻灯片21"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片22.png" alt="幻灯片22"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片23.png" alt="幻灯片23"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片24.png" alt="幻灯片24"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片25.png" alt="幻灯片25"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片26.png" alt="幻灯片26"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片27.png" alt="幻灯片27"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片28.png" alt="幻灯片28"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片29.png" alt="幻灯片29"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片30.png" alt="幻灯片30"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片31.png" alt="幻灯片31"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片32.png" alt="幻灯片32"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片33.png" alt="幻灯片33"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片34.png" alt="幻灯片34"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片35.png" alt="幻灯片35"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片36.png" alt="幻灯片36"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JStorm分享-课件资料&quot;&gt;&lt;a href=&quot;#JStorm分享-课件资料&quot; class=&quot;headerlink&quot; title=&quot;JStorm分享-课件资料&quot;&gt;&lt;/a&gt;JStorm分享-课件资料&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/09/16/JStorm-分享资料/幻灯片01.png&quot; alt=&quot;幻灯片01&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大数据" scheme="https://veryjj.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="实时计算" scheme="https://veryjj.github.io/tags/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97/"/>
    
      <category term="JStorm" scheme="https://veryjj.github.io/tags/JStorm/"/>
    
      <category term="Storm" scheme="https://veryjj.github.io/tags/Storm/"/>
    
  </entry>
  
</feed>
