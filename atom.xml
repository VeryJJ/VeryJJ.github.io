<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄老师</title>
  
  <subtitle>Life Note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://veryjj.github.io/"/>
  <updated>2018-09-30T09:49:22.000Z</updated>
  <id>https://veryjj.github.io/</id>
  
  <author>
    <name>黄老师</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>服务API设计之——API命名规范</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API命名规范/</id>
    <published>2018-09-30T09:46:20.000Z</published>
    <updated>2018-09-30T09:49:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API命名规范"><a href="#API命名规范" class="headerlink" title="API命名规范"></a>API命名规范</h1><h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h2><hr><h3 id="面向资源"><a href="#面向资源" class="headerlink" title="面向资源"></a>面向资源</h3><blockquote><p>同RESTful命名风格</p></blockquote><p>在大型系统中，常以”业务领域”视角进行模块划分，以达到业务”高内聚低耦合”的效果。</p><p>“业务领域”必有”数据对象”沉淀，<code>从宏观抽象的角度看，&quot;数据对象&quot;可统称为&quot;资源&quot;</code>，”业务领域”就是业务相近的”资源”的集合。</p><a id="more"></a><p><code>&quot;资源&quot;一定是业务抽象后的对象</code>：</p><ol><li>可以是具体的数据对象：<ul><li>商品</li><li>订单</li><li>合同</li><li>发票</li><li>采购计划</li><li>etc</li></ul></li><li>可以是抽象的对象概念：<ul><li>租户</li><li>用户</li><li>支付</li><li>文件</li><li>需求</li><li>etc</li></ul></li></ol><p><code>&quot;业务领域&quot;与&quot;业务领域&quot;之间的依赖，可理解为是对&quot;资源&quot;操作(读、写、通知)的依赖。</code></p><p><code>所以，API作为&quot;业务领域&quot;间沟通的手段，其应该(Should)以面向资源角度进行命名。</code></p><p>注：子资源，需要逐级索引命名，例如：修改-订单-商品：updateOrderItem。</p><hr><h3 id="单一视角"><a href="#单一视角" class="headerlink" title="单一视角"></a>单一视角</h3><ul><li>参见<a href="">单一视角原则</a></li></ul><hr><h3 id="动宾风格"><a href="#动宾风格" class="headerlink" title="动宾风格"></a>动宾风格</h3><p>API应该(Should)以<code>&quot;动宾短语&quot;风格命名</code>。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xxx.xxx.xxx.OrderService            // 上下文已涵盖Order语义</span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; save(...)   </span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; updateItem(Long orderId, List&lt;T&gt; items)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xxx.xxx.xxx.WCService               // 上下文未涵盖Order语义</span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; saveOrder(...)   </span><br><span class="line"></span><br><span class="line">Response&lt;Boolean&gt; removeOrder(Long orderId)   </span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; updateOrderItem(Long orderId, List&lt;T&gt; items) // 逐级索引子资源</span><br></pre></td></tr></table></figure><hr><h3 id="统一术语"><a href="#统一术语" class="headerlink" title="统一术语"></a>统一术语</h3><p>API命名统一”动词”术语、”名词”术语。优点是能风格一致，经验复用。</p><p>详见<a href="">政采云API术语参考</a></p><p>注：统一术语的节奏，参考研发级术语规范逐步执行：业务内统一、业务领域内统一、平台统一。</p><h5 id="错误实践-1：”商品”命名不统一"><a href="#错误实践-1：”商品”命名不统一" class="headerlink" title="错误实践-1：”商品”命名不统一"></a>错误实践-1：”商品”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">业务1：商品 -&gt; item ✔️</span><br><span class="line">业务2：商品 -&gt; items</span><br><span class="line">业务3: 商品 -&gt; product</span><br><span class="line">业务4：商品 -&gt; goods</span><br></pre></td></tr></table></figure><h5 id="错误实践-2：”特性”命名不统一"><a href="#错误实践-2：”特性”命名不统一" class="headerlink" title="错误实践-2：”特性”命名不统一"></a>错误实践-2：”特性”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：特性 -&gt; feature ✔️</span><br><span class="line">业务2: 特性 -&gt; character</span><br><span class="line">业务3：特性 -&gt; rule</span><br></pre></td></tr></table></figure><h5 id="错误实践-3：”金额”命名不统一"><a href="#错误实践-3：”金额”命名不统一" class="headerlink" title="错误实践-3：”金额”命名不统一"></a>错误实践-3：”金额”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：金额 -&gt; amount ✔️</span><br><span class="line">业务2: 金额 -&gt; money</span><br><span class="line">业务3：金额 -&gt; sum</span><br></pre></td></tr></table></figure><h5 id="错误实践-4：”校验”命名不统一"><a href="#错误实践-4：”校验”命名不统一" class="headerlink" title="错误实践-4：”校验”命名不统一"></a>错误实践-4：”校验”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：校验 -&gt; verify</span><br><span class="line">业务2: 校验 -&gt; check ✔️</span><br><span class="line">业务3：校验 -&gt; test</span><br></pre></td></tr></table></figure><h5 id="错误实践-5：”分页”命名不统一"><a href="#错误实践-5：”分页”命名不统一" class="headerlink" title="错误实践-5：”分页”命名不统一"></a>错误实践-5：”分页”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：分页 -&gt; page</span><br><span class="line">业务2: 分页 -&gt; paging✔️</span><br><span class="line">业务3：分页 -&gt; list</span><br></pre></td></tr></table></figure><h5 id="错误实践-6：”创建”命名不统一"><a href="#错误实践-6：”创建”命名不统一" class="headerlink" title="错误实践-6：”创建”命名不统一"></a>错误实践-6：”创建”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：创建 -&gt; save✔️</span><br><span class="line">业务2: 创建 -&gt; create</span><br><span class="line">业务3：创建 -&gt; insert</span><br></pre></td></tr></table></figure><h5 id="错误实践-7：”删除”命名不统一"><a href="#错误实践-7：”删除”命名不统一" class="headerlink" title="错误实践-7：”删除”命名不统一"></a>错误实践-7：”删除”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">业务1：删除 -&gt; delete</span><br><span class="line">业务2: 删除 -&gt; remove✔️</span><br><span class="line">业务3：删除 -&gt; disable </span><br><span class="line">业务3：删除 -&gt; cancel</span><br></pre></td></tr></table></figure><h5 id="错误实践-8：”检索”命名不统一"><a href="#错误实践-8：”检索”命名不统一" class="headerlink" title="错误实践-8：”检索”命名不统一"></a>错误实践-8：”检索”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：搜索 -&gt; query✔️</span><br><span class="line">业务2: 搜索 -&gt; search</span><br><span class="line">业务3：搜索 -&gt; list</span><br></pre></td></tr></table></figure><hr><h2 id="常见API命名参考"><a href="#常见API命名参考" class="headerlink" title="常见API命名参考"></a>常见API命名参考</h2><blockquote><p>假设：未按资源划分Service(上下文未界定资源域)的情况</p></blockquote><blockquote><p>“XXX”指某一种资源，”xxx”指”XXX”下的子资源</p></blockquote><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;Page&lt;T&gt;&gt; pagingXXX(QueryDTO q)    //用对象包装查询条件</span><br></pre></td></tr></table></figure><ul><li>错误实践    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;Page&lt;T&gt;&gt; pagingXXX(String name, String code, Long orgId, Long creatorId, Integer pageNo, Integer PageSize)</span><br></pre></td></tr></table></figure><p>以上错误实践缺点：<br>1、对于调用方来说，无论以什么条件查询，都需要逐个条件传参<br>2、API对扩展不友好，一旦想增加查询条件，API就不兼容。</p><h3 id="列表查询"><a href="#列表查询" class="headerlink" title="列表查询"></a>列表查询</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;List&lt;T&gt;&gt; listXXX(...)</span><br></pre></td></tr></table></figure><h3 id="获取单个详情"><a href="#获取单个详情" class="headerlink" title="获取单个详情"></a>获取单个详情</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; getXXX(Long id) </span><br><span class="line"></span><br><span class="line">类同条件，用重载</span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; getXXX(String code)</span><br></pre></td></tr></table></figure><ul><li>错误实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; getXXXById(Long id) </span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; getXXXByCode(String code)</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>API契约应该由”API名 + 入参”共同组成，而不是只靠”API名”说明一切。</li><li>API方法支持获取单个详情的方式，可以通过入参字段名自解释。无需再用”By***”来额外标注。</li><li>不带”By***”声明的方法语义上更具有扩展性。</li></ol><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; saveXXX(...)      //参照《阿里巴巴Java编码规范》</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; removeXXX(...)      //参照《阿里巴巴Java编码规范》</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; updateXXX(...)      //参照《阿里巴巴Java编码规范》</span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; updateXXXxxx(...)   //更新主资源下的子资源</span><br></pre></td></tr></table></figure><h3 id="提审"><a href="#提审" class="headerlink" title="提审"></a>提审</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; submitXXX(...)</span><br></pre></td></tr></table></figure><h3 id="审核"><a href="#审核" class="headerlink" title="审核"></a>审核</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; auditXXX(...)</span><br></pre></td></tr></table></figure><h3 id="退回（退回到流程中的某一步）"><a href="#退回（退回到流程中的某一步）" class="headerlink" title="退回（退回到流程中的某一步）"></a>退回（退回到流程中的某一步）</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; returnXXX(...)</span><br></pre></td></tr></table></figure><h3 id="撤销（退回到流程的第一步）"><a href="#撤销（退回到流程的第一步）" class="headerlink" title="撤销（退回到流程的第一步）"></a>撤销（退回到流程的第一步）</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; cancelXXX(...)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;API命名规范&quot;&gt;&lt;a href=&quot;#API命名规范&quot; class=&quot;headerlink&quot; title=&quot;API命名规范&quot;&gt;&lt;/a&gt;API命名规范&lt;/h1&gt;&lt;h2 id=&quot;命名风格&quot;&gt;&lt;a href=&quot;#命名风格&quot; class=&quot;headerlink&quot; title=&quot;命名风格&quot;&gt;&lt;/a&gt;命名风格&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;面向资源&quot;&gt;&lt;a href=&quot;#面向资源&quot; class=&quot;headerlink&quot; title=&quot;面向资源&quot;&gt;&lt;/a&gt;面向资源&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;同RESTful命名风格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在大型系统中，常以”业务领域”视角进行模块划分，以达到业务”高内聚低耦合”的效果。&lt;/p&gt;
&lt;p&gt;“业务领域”必有”数据对象”沉淀，&lt;code&gt;从宏观抽象的角度看，&amp;quot;数据对象&amp;quot;可统称为&amp;quot;资源&amp;quot;&lt;/code&gt;，”业务领域”就是业务相近的”资源”的集合。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="API命名" scheme="https://veryjj.github.io/tags/API%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API错误返回规范</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E9%94%99%E8%AF%AF%E8%BF%94%E5%9B%9E%E8%A7%84%E8%8C%83/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API错误返回规范/</id>
    <published>2018-09-30T09:32:14.000Z</published>
    <updated>2018-09-30T09:58:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API错误返回规范"><a href="#API错误返回规范" class="headerlink" title="API错误返回规范"></a>API错误返回规范</h1><h2 id="禁止通过抛异常形式返回API业务错误"><a href="#禁止通过抛异常形式返回API业务错误" class="headerlink" title="禁止通过抛异常形式返回API业务错误"></a>禁止通过抛异常形式返回API业务错误</h2><p>API禁止抛Checked异常，即业务处理上的参数错误、逻辑错误、业务错误等禁止通过抛异常形式返回，应用Response#code, message表达业务错误。</p><p>注：不要逼调用方到处写try{}catch()。</p><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; saveDesposit(...);</span><br></pre></td></tr></table></figure><ul><li>反例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T saveDesposit(...) throws ServiceException, IllegalArgumentException, ValidationException;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="禁止通过抛异常形式返回API业务错误-1"><a href="#禁止通过抛异常形式返回API业务错误-1" class="headerlink" title="禁止通过抛异常形式返回API业务错误"></a>禁止通过抛异常形式返回API业务错误</h2><p>API禁止抛Checked异常，即业务处理上的参数错误、逻辑错误、业务错误等禁止通过抛异常形式返回，应用Response#code, message表达业务错误。</p><p>注：不要逼调用方到处写try{}catch()。</p><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; saveDesposit(...);</span><br></pre></td></tr></table></figure><ul><li>反例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T saveDesposit(...) throws ServiceException, IllegalArgumentException, ValidationException;</span><br></pre></td></tr></table></figure><h2 id="需要调用方做错误细分处理的，API提供方务必一并提供判断工具类"><a href="#需要调用方做错误细分处理的，API提供方务必一并提供判断工具类" class="headerlink" title="需要调用方做错误细分处理的，API提供方务必一并提供判断工具类"></a>需要调用方做错误细分处理的，API提供方务必一并提供判断工具类</h2><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void saveXXX()&#123;</span><br><span class="line">    Response&lt;T&gt; result = xxxWriteService(...)</span><br><span class="line">    if (!result.isSuccess())&#123;</span><br><span class="line">        if (xxxUtils.isBankUnSupport(result.getCode))&#123;   &lt;&lt;&lt;API提供方提供工具类解析code含义，且code含义可持续迭代更新，调用方无感知。</span><br><span class="line">            //银行渠道未开通，需要特殊提示</span><br><span class="line">            ...</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void saveXXX()&#123;</span><br><span class="line">    Response&lt;T&gt; result = xxxWriteService(...)</span><br><span class="line">    if (!result.isSuccess())&#123;</span><br><span class="line">        if (&quot;10101&quot;.equals(result.getCode))&#123;   &lt;&lt;&lt;调用方按API提供方的错误码值做硬编码，代码耦合。</span><br><span class="line">            //银行渠道未开通，需要特殊提示</span><br><span class="line">            ...</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【推荐】API返回可直接显示给用户的中文提示信息"><a href="#【推荐】API返回可直接显示给用户的中文提示信息" class="headerlink" title="【推荐】API返回可直接显示给用户的中文提示信息"></a>【推荐】API返回可直接显示给用户的中文提示信息</h2><p>API失败时，只有API实现方最清楚是什么原因，该怎么提示。那么，请提供对应的提示信息。</p><p>我们系统中存在一些用国际化风格的error message，而当前的国际化实现方式真如你想的那么好用吗？</p><h4 id="error-message国际化原理："><a href="#error-message国际化原理：" class="headerlink" title="error message国际化原理："></a><strong>error message国际化原理：</strong></h4><ul><li>代码中的提示信息国际化配置文件</li></ul><p><img src="/2018/09/30/服务API设计之——API错误返回规范/img-1.png" alt="image-20180930154223074"></p><ul><li>国际化提示原理</li></ul><p><img src="/2018/09/30/服务API设计之——API错误返回规范/img-2.png" alt="image-20180930162340975"></p><p>1) 提示信息国际化的行为发生在Web层，Web层启动时会加载Web层的resources/messages提示信息文件</p><p>2)当REST API需要返回提示信息时，Web会根据HTTP 请求中的Locale值（例如：zh_CN、zh_TW、en_US、es_ES_Traditional_WIN等）来决定返回哪一种语言的提示信息。将errorMessage以此种语言方式返回给浏览器进行提示。</p><p>问题：</p><p>1）在分布式系统中，各个应用按领域自治，其resources/messages只维护了自身业务需要的errorMessage。</p><p>2）当图中C Service 将errorMessage = template.status.not.match 返回给 XX Service，XX Service直接透传给XX Web的情况下，XX Web的resources/messages是不包括template.status.not.match的，所以此errorMessage将无法正确的展示其本应该提示的信息。</p><p>所以，推荐API返回可直接显示给用户的中文提示信息。</p><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(&quot;模板配置正在审核中，请在审核完成后再更新&quot;);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反例： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(&quot;模板管理状态机异常&quot;);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【推荐】返回具备可读性，引导性的错误提示信息"><a href="#【推荐】返回具备可读性，引导性的错误提示信息" class="headerlink" title="【推荐】返回具备可读性，引导性的错误提示信息"></a>【推荐】返回具备可读性，引导性的错误提示信息</h2><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(&quot;模板配置正在审核中，请在审核完成后再更新&quot;);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反例：</li></ul><p>例1 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(&quot;模板管理状态机异常&quot;);  &lt;&lt;&lt;&lt; 你作为用户，是不是吓一跳？</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(e.getMessage());    &lt;&lt;&lt;&lt; message谁都看不懂，没有任何意义</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;API错误返回规范&quot;&gt;&lt;a href=&quot;#API错误返回规范&quot; class=&quot;headerlink&quot; title=&quot;API错误返回规范&quot;&gt;&lt;/a&gt;API错误返回规范&lt;/h1&gt;&lt;h2 id=&quot;禁止通过抛异常形式返回API业务错误&quot;&gt;&lt;a href=&quot;#禁止通过抛异常形式返回API业务错误&quot; class=&quot;headerlink&quot; title=&quot;禁止通过抛异常形式返回API业务错误&quot;&gt;&lt;/a&gt;禁止通过抛异常形式返回API业务错误&lt;/h2&gt;&lt;p&gt;API禁止抛Checked异常，即业务处理上的参数错误、逻辑错误、业务错误等禁止通过抛异常形式返回，应用Response#code, message表达业务错误。&lt;/p&gt;
&lt;p&gt;注：不要逼调用方到处写try{}catch()。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正例：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Response&amp;lt;T&amp;gt; saveDesposit(...);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;反例：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;T saveDesposit(...) throws ServiceException, IllegalArgumentException, ValidationException;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="错误码" scheme="https://veryjj.github.io/tags/%E9%94%99%E8%AF%AF%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API版本规范</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E7%89%88%E6%9C%AC%E8%A7%84%E8%8C%83/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API版本规范/</id>
    <published>2018-09-30T09:32:07.000Z</published>
    <updated>2018-09-30T09:47:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API版本规范"><a href="#API版本规范" class="headerlink" title="API版本规范"></a>API版本规范</h1><h2 id="发布RELEASE版本"><a href="#发布RELEASE版本" class="headerlink" title="发布RELEASE版本"></a>发布RELEASE版本</h2><p>正式发布的api包必须是RELEASE版本</p><p>eg.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.gov.zcy.paas.template&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;template-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="版本号风格"><a href="#版本号风格" class="headerlink" title="版本号风格"></a>版本号风格</h2><p>使用 《<a href="https://semver.org/" target="_blank" rel="noopener">Semantic Versioning</a>》风格</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Version号由 “MAJOR.MINOR.PATCH” 三段组合构成，version号增加含义：</p><ol><li>MAJOR version：【主版本号】代表API发生了不兼容的变更，即使是微小的不兼容。</li><li>MINOR version：【次版本号】代表以兼容的方式新增了功能、特性</li><li>PATCH version：【补丁版本号】代表以兼容的方式做了bugfix</li></ol><h3 id="用法-FAQ"><a href="#用法-FAQ" class="headerlink" title="用法 / FAQ"></a>用法 / FAQ</h3><h3 id="版本号以0开始"><a href="#版本号以0开始" class="headerlink" title="版本号以0开始"></a>版本号以0开始</h3><ul><li>X.Y.Z 三个版本号都是以0开始。</li><li>【特别注意】当版本号是 “1.0.9.RELEASE”时，它的下一个补丁版本号是”1.0.10.RELEASE”  ！！！ <ul><li>而不是”1.1.0.RELEASE”，这里不存在满十进位之说。</li></ul></li></ul><h3 id="初始-MAJOR-version"><a href="#初始-MAJOR-version" class="headerlink" title="初始 MAJOR version"></a>初始 MAJOR version</h3><ul><li>初始MAJOR version以0开始，代表业务的初始开发阶段，这过程中功能上任何改变都可能发生，此时的API是不稳定的。</li><li>初始版本一旦发布生产环境，即将MAJOR version变更为1，即 1.0.0.RELEASE。是第一个基线版本。</li></ul><h3 id="预发布版本"><a href="#预发布版本" class="headerlink" title="预发布版本"></a>预发布版本</h3><ul><li>可以通过在补丁版本之后紧跟附加连字符和一系列点分隔标识符来表示预发布版本。标识符必须仅包含ASCII字母数字和连字符[0-9A-Za-z-]。标识符不能为空。数字标识符不得包含前导零。</li><li>预发布版本的优先级低于关联的普通版本。</li><li>预发布版本表示版本不稳定，可能无法满足其关联的正常版本所表示的预期兼容性要求。示例：1.0.0-alpha，1.0.0-alpha.1,1.0.0-0.3.7,1.0.0-x.7.z.92</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;API版本规范&quot;&gt;&lt;a href=&quot;#API版本规范&quot; class=&quot;headerlink&quot; title=&quot;API版本规范&quot;&gt;&lt;/a&gt;API版本规范&lt;/h1&gt;&lt;h2 id=&quot;发布RELEASE版本&quot;&gt;&lt;a href=&quot;#发布RELEASE版本&quot; class=&quot;headerlink&quot; title=&quot;发布RELEASE版本&quot;&gt;&lt;/a&gt;发布RELEASE版本&lt;/h2&gt;&lt;p&gt;正式发布的api包必须是RELEASE版本&lt;/p&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;cn.gov.zcy.paas.template&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;template-api&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;2.1.1.RELEASE&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;版本号风格&quot;&gt;&lt;a href=&quot;#版本号风格&quot; class=&quot;headerlink&quot; title=&quot;版本号风格&quot;&gt;&lt;/a&gt;版本号风格&lt;/h2&gt;&lt;p&gt;使用 《&lt;a href=&quot;https://semver.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Semantic Versioning&lt;/a&gt;》风格&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="API版本" scheme="https://veryjj.github.io/tags/API%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API参数规范</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E5%8F%82%E6%95%B0%E8%A7%84%E8%8C%83/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API参数规范/</id>
    <published>2018-09-30T09:32:03.000Z</published>
    <updated>2018-09-30T09:44:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【强制】字段名称用小驼峰风格"><a href="#【强制】字段名称用小驼峰风格" class="headerlink" title="【强制】字段名称用小驼峰风格"></a>【强制】字段名称用小驼峰风格</h3><h3 id="【强制】Service-API返回值必须使用Response包装"><a href="#【强制】Service-API返回值必须使用Response包装" class="headerlink" title="【强制】Service API返回值必须使用Response包装"></a>【强制】Service API返回值必须使用Response包装</h3><ul><li>Service API返回值强制要求进行通用包装，例如：Response。</li><li><p>Response的作用：</p><ol><li>统一方法表示API调用是否成功</li><li>API调用失败时，统一格式反馈错误Code，错误Message</li><li>统一的Response易于调用方经验复用，框架集成</li></ol></li><li><p>作为API调用方，其编码诉求很简单：</p><ol><li>API调用是否成功；</li><li>调用不成功时，提示文案是什么；</li></ol></li><li><p>调用方几不想：</p><ol><li>不想关心API内部有多牛逼</li><li>不想关心API可能会抛的各种Exception，以及因此不得不做各种异常处理</li></ol></li><li><p>关于当前不统一的Response</p><ul><li>【新业务】【强制】使用架构组定义的统一Response：<a href="http://confluence.cai-inc.com/pages/viewpage.action?pageId=6623775" target="_blank" rel="noopener">ZCY Response</a></li><li>目前业务方有自定义Result/Response，风格和作用大同小异。有更好的设计可以自荐给架构组集成，杜绝各自开辟重复的新定义。</li></ul></li></ul><a id="more"></a><h3 id="【强制】杜绝完全不规范的缩写，避免望文不知义。（国际通用缩写除外）"><a href="#【强制】杜绝完全不规范的缩写，避免望文不知义。（国际通用缩写除外）" class="headerlink" title="【强制】杜绝完全不规范的缩写，避免望文不知义。（国际通用缩写除外）"></a>【强制】杜绝完全不规范的缩写，避免望文不知义。（国际通用缩写除外）</h3><ul><li>错误实践<ul><li>AbstractClass“缩写”命名成 AbsClass;</li><li>condition“缩写”命名成 condi；</li><li>此类随意缩写严重降低了代码的可阅读性。</li></ul></li></ul><h3 id="【强制】禁止使用-Map-作为参数类型"><a href="#【强制】禁止使用-Map-作为参数类型" class="headerlink" title="【强制】禁止使用 Map 作为参数类型"></a>【强制】禁止使用 Map 作为参数类型</h3><p>Map&lt;K,V&gt;机制非常灵活，但这样的灵活却是负作用巨大。</p><ol><li>Map的数据说明是晦涩的，调用方、实现方之间需要具有隐式的契约解释支持哪些Key，每个Key的Value是什么类型。增加了双方的使用复杂度。</li><li>Map&lt;K,V&gt;不可被校验。加之第1条的使用复杂度，导致使用上非常容易出错。</li><li>用Map类型字段做预留扩展性的设计都是不优雅的设计。</li></ol><p>注：参数中的调用方自定义数据部分允许使用Map。API提供方不关系、不解析、只透传。</p><h3 id="【强制】业务对象-查询条件用DTO封装，禁止以入参方式平铺字段。"><a href="#【强制】业务对象-查询条件用DTO封装，禁止以入参方式平铺字段。" class="headerlink" title="【强制】业务对象/查询条件用DTO封装，禁止以入参方式平铺字段。"></a>【强制】业务对象/查询条件用DTO封装，禁止以入参方式平铺字段。</h3><ul><li>正确实践</li></ul><p>分页查询，将查询条件以DTO方式包装。</p><p>Dubbo序列化特点：</p><ul><li>Dubbo API的POJO类中，UID不一致：没关系。</li><li>Dubbo API的POJO类中，字段数量不一致：没关系，只要字段名和类型一致，数据能反序列化成功。</li><li>发送方比接收方的字段多：没关系。</li><li>发送方比接收方的字段少：没关系。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;Page&lt;T&gt;&gt; pagingXXX(QueryDTO q)</span><br></pre></td></tr></table></figure><ul><li>错误实践    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;Page&lt;T&gt;&gt; pagingXXX(String name, String code, Long orgId, Long creatorId, Integer pageNo, Integer PageSize)</span><br></pre></td></tr></table></figure><p>以上错误实践缺点：<br>1、对于调用方来说，无论以什么条件查询，都需要逐个条件传参。<br>2、API对扩展不友好，一旦想增加查询条件，API就不兼容。</p><h3 id="【推荐】DTO字段设置JSR303-Annotation进行基础校验"><a href="#【推荐】DTO字段设置JSR303-Annotation进行基础校验" class="headerlink" title="【推荐】DTO字段设置JSR303 Annotation进行基础校验"></a>【推荐】DTO字段设置JSR303 Annotation进行基础校验</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ZcyPayFacade &#123;</span><br><span class="line">    Result&lt;Boolean&gt; validTradePay(@NotNull @Valid TradePayPO tradePayPO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class TradePayPO implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(max = 15)</span><br><span class="line">    /** 业务交易编号(订单编号) */</span><br><span class="line">    private String businessTradeNo;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 业务渠道：1-订阅，2-CA</span><br><span class="line">     * @see BusinessTypeEnum</span><br><span class="line">     *</span><br><span class="line">     * */</span><br><span class="line">    @NotNull</span><br><span class="line">    @Range(min = 1, max = 2)</span><br><span class="line">    private Integer businessType;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    /** 商户名称(商家) */</span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(max = 50)</span><br><span class="line">    private String merchantName;</span><br><span class="line"></span><br><span class="line">    /** 订单标题（即商品名称），粗略描述用户的支付目的。如“喜士多（浦东店）消费”*/</span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(max = 256)</span><br><span class="line">    private String orderSubject;</span><br><span class="line"></span><br><span class="line">    /** 订单描述（即商品描述），可以对交易或商品进行一个详细地描述，比如填写&quot;购买商品2件共15.00元&quot;*/</span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(max = 128)</span><br><span class="line">    private String orderBody;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【推荐】在客户端完成基础字段校验"><a href="#【推荐】在客户端完成基础字段校验" class="headerlink" title="【推荐】在客户端完成基础字段校验"></a>【推荐】在客户端完成基础字段校验</h3><ul><li>方式1：【推荐】自定义Dubbo Filter实现通用拦截、校验。</li><li>方式2：【推荐】通过Builder模式构建入参对象。</li><li>方式3：【不推荐】Dubbo 客户端参数校验，要求consumer方设置validation=”true”，<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/parameter-validation.html" target="_blank" rel="noopener">Dubbo 客户端参数校验</a>。缺点：以抛异常方式处理校验失败，需要业务方额外处理Exception。而且，IDE并不会提示consumer方需要处理ConstraintViolationException。</li><li>方式4：Dubbo方式，local-stub特性。实现较复杂，校验代码通用性低。<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html" target="_blank" rel="noopener">Dubbo local-stub</a></li></ul><hr><h3 id="注：此规范与《阿里巴巴Java编码规范》互补，同时有效。"><a href="#注：此规范与《阿里巴巴Java编码规范》互补，同时有效。" class="headerlink" title="注：此规范与《阿里巴巴Java编码规范》互补，同时有效。"></a>注：此规范与《阿里巴巴Java编码规范》互补，同时有效。</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【强制】字段名称用小驼峰风格&quot;&gt;&lt;a href=&quot;#【强制】字段名称用小驼峰风格&quot; class=&quot;headerlink&quot; title=&quot;【强制】字段名称用小驼峰风格&quot;&gt;&lt;/a&gt;【强制】字段名称用小驼峰风格&lt;/h3&gt;&lt;h3 id=&quot;【强制】Service-API返回值必须使用Response包装&quot;&gt;&lt;a href=&quot;#【强制】Service-API返回值必须使用Response包装&quot; class=&quot;headerlink&quot; title=&quot;【强制】Service API返回值必须使用Response包装&quot;&gt;&lt;/a&gt;【强制】Service API返回值必须使用Response包装&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Service API返回值强制要求进行通用包装，例如：Response。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Response的作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统一方法表示API调用是否成功&lt;/li&gt;
&lt;li&gt;API调用失败时，统一格式反馈错误Code，错误Message&lt;/li&gt;
&lt;li&gt;统一的Response易于调用方经验复用，框架集成&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;作为API调用方，其编码诉求很简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;API调用是否成功；&lt;/li&gt;
&lt;li&gt;调用不成功时，提示文案是什么；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用方几不想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不想关心API内部有多牛逼&lt;/li&gt;
&lt;li&gt;不想关心API可能会抛的各种Exception，以及因此不得不做各种异常处理&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于当前不统一的Response&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【新业务】【强制】使用架构组定义的统一Response：&lt;a href=&quot;http://confluence.cai-inc.com/pages/viewpage.action?pageId=6623775&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ZCY Response&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;目前业务方有自定义Result/Response，风格和作用大同小异。有更好的设计可以自荐给架构组集成，杜绝各自开辟重复的新定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="API规范" scheme="https://veryjj.github.io/tags/API%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API设计原则</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API设计原则/</id>
    <published>2018-09-30T09:31:47.000Z</published>
    <updated>2018-09-30T10:00:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="你是否也感同身受？"><a href="#你是否也感同身受？" class="headerlink" title="你是否也感同身受？"></a>你是否也感同身受？</h2><ol><li>对接XX业务时，XX业务具备的功能和API全靠跑业务负责人那反复逐个询问、确认。用哪个API；怎么用；有没有限制；等等</li><li>各个业务间，甚至同一业务内，API风格不统一。<ul><li>API命名：按自然语义全翻译的；按属性角度定义的；按操作角度定义的；动宾、非动宾的；复数、非复数的；等等</li><li>API入参：带Map的；相同语义字段名称不一样；</li><li>API出参：有包装Resoponse的；直接返回结果数据的；相同数据，返回格式和字段名称有差别的；</li><li>错误信息：直接返回中文提示的；返回提示信息编码的；返回异常类型的；等等</li></ul></li><li>XX业务API性能方面未知。</li><li>随着业务的演进，开放的API持续在增加，但类同的很多</li></ol><a id="more"></a><h5 id="API编码规范迫在眉睫"><a href="#API编码规范迫在眉睫" class="headerlink" title="API编码规范迫在眉睫"></a><strong>API编码规范迫在眉睫</strong></h5><hr><h2 id="优秀API的特质"><a href="#优秀API的特质" class="headerlink" title="优秀API的特质"></a>优秀API的特质</h2><ol><li>自解释<ul><li>从API本身一眼就能看懂API是干什么的，支持的用法，适用的场景，异常的处理等</li></ul></li><li>易学习<ul><li>有完善的文档，以及提供尽可能多的示例和可copy－paste的代码。</li></ul></li><li>易使用<ul><li>功能强大，但使用简单。不增加调用方的使用成本（例如要求业务方用API时需要额外的配置和依赖），不暴露复杂的细节、冗长的使用流程给调用方感知。调用方只做最小的感知和最少的传参。</li></ul></li><li>难误用<ul><li>优秀的API可以使有经验的开发直接使用API而不需要阅读文档。</li><li>充分的静态检查、动态校验、显式的异常说明、有效的错误提示。</li></ul></li></ol><hr><h2 id="ZCY-API-设计原则"><a href="#ZCY-API-设计原则" class="headerlink" title="ZCY API 设计原则"></a>ZCY API 设计原则</h2><h3 id="1-充分原则"><a href="#1-充分原则" class="headerlink" title="1. 充分原则"></a>1. 充分原则</h3><p>不是随便一个功能就要有个接口，也不是随便一个需求就要加个接口。</p><p>每新建一个接口，要有充分的理由和考虑，即这个接口的存在是十分有意义和价值的。无意义的接口不仅增加了维护的难度，更重要是对于程序的可控性的大大降低，接口也会十分臃肿。</p><h3 id="2-单一视角原则"><a href="#2-单一视角原则" class="headerlink" title="2. 单一视角原则"></a>2. 单一视角原则</h3><p>设计接口时，分析的角度要统一。否则会造成接口结构的混乱。例如：不要一会以角色的角度设计，一会儿就要以功能的角度设计。</p><p>推荐：以”属性对象 + 行为”的视角定义API</p><h3 id="3-单一功能原则"><a href="#3-单一功能原则" class="headerlink" title="3. 单一功能原则"></a>3. 单一功能原则</h3><p>每个API接口应该只专注一件事，并做好。产品概念简单、关系清楚。功能模棱两可，诸多特殊逻辑的API肯定不是个优雅的API，且会造成功能类似重复的API。</p><p>注：如果API它很难命名，那么这或许是个不好的征兆，好的名称可以驱动开发、并且只需拆分与合并模块即可。</p><p>功能大而全的API在灵活性、简单性方面肯定捉襟见肘。定义API的粒度之前，建议先将业务分领域、划边界，以此来提取业务对象，然后再根据业务对象用例来设计单一功能的API。</p><p>比如：查询会员，可能除了查询会员表外还要获取该会员的其他必要信息，但不要在查询会员的同时还有修改权限等类似的其他业务功能，应该分成两个接口执行。</p><h3 id="4-简单原则"><a href="#4-简单原则" class="headerlink" title="4. 简单原则"></a>4. 简单原则</h3><p>接口设计简单、清晰。API执行的功能可以很丰富、很强大，但API声明和用法一定要尽量的简单，不能将功能的丰富通过复杂的用法来实现，这会导致API功能不单一，演进不可控。</p><p>最终的评审要看API的简单易用程度。</p><ul><li>你写的例子，能不能让你的代码看起来更简单？</li><li>你是不是强迫调用方关注/提供他们不在乎的选项/配置？</li><li>有没有毫无价值的额外步骤？</li></ul><p>编写的代码一定要易于读、易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</p><h3 id="5-抽象原则"><a href="#5-抽象原则" class="headerlink" title="5. 抽象原则"></a>5. 抽象原则</h3><p>API的入参、出参所述的对象、属性，一定是按业务特性进行抽象后的实体。误将底层数据模型概念如实的反应到API上。抽象API、抽象对象实体更宏观，具有更好的适用性、兼容性、扩展性。</p><h3 id="6-兼容扩展原则"><a href="#6-兼容扩展原则" class="headerlink" title="6. 兼容扩展原则"></a>6. 兼容扩展原则</h3><p>对扩展开放，对修改关闭。保证API的向后兼容。</p><p>扩展参数应当是便利的，保证后续类似的需求，可以在已有的API上通过兼容扩展的方式实现。</p><h3 id="7-最小惊讶原则"><a href="#7-最小惊讶原则" class="headerlink" title="7. 最小惊讶原则"></a>7. 最小惊讶原则</h3><p>代码应该尽可能减少让读者惊喜。业务API只需根据需求来设计即可，不需要刻意去设计一下复杂无用、华而不实的API，以免弄巧成拙。</p><h3 id="8-低耦合原则"><a href="#8-低耦合原则" class="headerlink" title="8. 低耦合原则"></a>8. 低耦合原则</h3><p>API应该减少对其他业务代码的依赖关系。低耦合往往是完美结构系统和优秀设计的标志。</p><p>耦合的种类：</p><ul><li>代码实现业务逆向调用。</li><li>条件逻辑依赖耦合。例如：此API在处理国税网超订单类型时，需要额外发送结算支付凭证上传的事件MQ出来。</li><li>耦合API无关的业务行为。例如：采购计划链路日志API被调用时，若是项目采购委托单的情况，需要额外调用公告的API拉取链路信息，新建成为一条此委托单的一条链路日志。</li></ul><h3 id="9-正交原则"><a href="#9-正交原则" class="headerlink" title="9. 正交原则"></a>9. 正交原则</h3><p>正交性是指改变某个特性而不会影响到其他的特性。</p><p>API之间的功能应该成正交性，无功能重合。API之间应该是互相补充的关系。</p><h3 id="10-易测试原则"><a href="#10-易测试原则" class="headerlink" title="10. 易测试原则"></a>10. 易测试原则</h3><p>对于API调用者而言，API应该是可被测试且易于被测试的。测试API不需要依赖额外的环境、容器、配置、公共服务等。</p><p>对可测试友好的API也是可被有效集成测试的前提。</p><h3 id="11-统一原则"><a href="#11-统一原则" class="headerlink" title="11. 统一原则"></a>11. 统一原则</h3><p>API要具备统一的命名、统一的入/出参规范、统一的异常规范、统一的错误码规范、统一的版本规范等。</p><p>统一规范的API优点：</p><ul><li>易于被框架集成、处理</li><li>有助于API调用方、API提供方开发经验复用</li><li>避免犯错，避免误用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;你是否也感同身受？&quot;&gt;&lt;a href=&quot;#你是否也感同身受？&quot; class=&quot;headerlink&quot; title=&quot;你是否也感同身受？&quot;&gt;&lt;/a&gt;你是否也感同身受？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;对接XX业务时，XX业务具备的功能和API全靠跑业务负责人那反复逐个询问、确认。用哪个API；怎么用；有没有限制；等等&lt;/li&gt;
&lt;li&gt;各个业务间，甚至同一业务内，API风格不统一。&lt;ul&gt;
&lt;li&gt;API命名：按自然语义全翻译的；按属性角度定义的；按操作角度定义的；动宾、非动宾的；复数、非复数的；等等&lt;/li&gt;
&lt;li&gt;API入参：带Map的；相同语义字段名称不一样；&lt;/li&gt;
&lt;li&gt;API出参：有包装Resoponse的；直接返回结果数据的；相同数据，返回格式和字段名称有差别的；&lt;/li&gt;
&lt;li&gt;错误信息：直接返回中文提示的；返回提示信息编码的；返回异常类型的；等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;XX业务API性能方面未知。&lt;/li&gt;
&lt;li&gt;随着业务的演进，开放的API持续在增加，但类同的很多&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="API设计原则" scheme="https://veryjj.github.io/tags/API%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JStorm-分享资料</title>
    <link href="https://veryjj.github.io/2018/09/16/JStorm-%E5%88%86%E4%BA%AB%E8%B5%84%E6%96%99/"/>
    <id>https://veryjj.github.io/2018/09/16/JStorm-分享资料/</id>
    <published>2018-09-16T04:34:33.000Z</published>
    <updated>2018-09-16T05:38:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JStorm分享-课件资料"><a href="#JStorm分享-课件资料" class="headerlink" title="JStorm分享-课件资料"></a>JStorm分享-课件资料</h2><p><img src="/2018/09/16/JStorm-分享资料/幻灯片01.png" alt="幻灯片01"></p><a id="more"></a><p><img src="/2018/09/16/JStorm-分享资料/幻灯片02.png" alt="幻灯片02"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片03.png" alt="幻灯片03"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片04.png" alt="幻灯片04"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片05.png" alt="幻灯片05"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片06.png" alt="幻灯片06"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片07.png" alt="幻灯片07"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片08.png" alt="幻灯片08"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片09.png" alt="幻灯片09"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片10.png" alt="幻灯片10"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片11.png" alt="幻灯片11"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片12.png" alt="幻灯片12"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片13.png" alt="幻灯片13"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片14.png" alt="幻灯片14"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片15.png" alt="幻灯片15"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片16.png" alt="幻灯片16"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片17.png" alt="幻灯片17"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片18.png" alt="幻灯片18"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片19.png" alt="幻灯片19"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片20.png" alt="幻灯片20"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片21.png" alt="幻灯片21"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片22.png" alt="幻灯片22"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片23.png" alt="幻灯片23"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片24.png" alt="幻灯片24"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片25.png" alt="幻灯片25"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片26.png" alt="幻灯片26"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片27.png" alt="幻灯片27"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片28.png" alt="幻灯片28"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片29.png" alt="幻灯片29"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片30.png" alt="幻灯片30"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片31.png" alt="幻灯片31"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片32.png" alt="幻灯片32"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片33.png" alt="幻灯片33"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片34.png" alt="幻灯片34"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片35.png" alt="幻灯片35"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片36.png" alt="幻灯片36"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JStorm分享-课件资料&quot;&gt;&lt;a href=&quot;#JStorm分享-课件资料&quot; class=&quot;headerlink&quot; title=&quot;JStorm分享-课件资料&quot;&gt;&lt;/a&gt;JStorm分享-课件资料&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/09/16/JStorm-分享资料/幻灯片01.png&quot; alt=&quot;幻灯片01&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大数据" scheme="https://veryjj.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="实时计算" scheme="https://veryjj.github.io/tags/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97/"/>
    
      <category term="JStorm" scheme="https://veryjj.github.io/tags/JStorm/"/>
    
      <category term="Storm" scheme="https://veryjj.github.io/tags/Storm/"/>
    
  </entry>
  
  <entry>
    <title>Spring数据库原理-事务管理</title>
    <link href="https://veryjj.github.io/2018/08/11/Spring%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>https://veryjj.github.io/2018/08/11/Spring数据库原理-事务管理/</id>
    <published>2018-08-11T08:33:54.000Z</published>
    <updated>2018-08-11T12:27:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点分解"><a href="#知识点分解" class="headerlink" title="知识点分解"></a>知识点分解</h1><h2 id="核心类对象"><a href="#核心类对象" class="headerlink" title="核心类对象"></a>核心类对象</h2><table><thead><tr><th style="text-align:left">对象</th><th style="text-align:left">一句话介绍</th></tr></thead><tbody><tr><td style="text-align:left">PlatformTransactionManager</td><td style="text-align:left">Spring事务的核心底层interface，定义了事务核心方法</td></tr><tr><td style="text-align:left">AbstractPlatformTransactionManager</td><td style="text-align:left">Spring标准事务处理流程的抽象基类，定义了Spring事务处理框架</td></tr><tr><td style="text-align:left">TransactionDefinition</td><td style="text-align:left">事务属性相关。事务隔离级别；超时；传播行为；等</td></tr><tr><td style="text-align:left">TransactionStatus</td><td style="text-align:left">事务实例状态对象，可供查询，用于回滚、SavePoint等场景</td></tr><tr><td style="text-align:left">DataSourceTransactionManager</td><td style="text-align:left">Spring框架TransactionManager的典型实现</td></tr><tr><td style="text-align:left">TransactionTemplate</td><td style="text-align:left">将编程式上下文多个步骤合并成一个核心的execute方法，方便事务编程</td></tr></tbody></table><p><img src="/2018/08/11/Spring数据库原理-事务管理/image-20180811172416549.png" alt="image-20180811172416549"></p><p><img src="/2018/08/11/Spring数据库原理-事务管理/image-20180811172628386.png" alt="image-20180811172628386"></p><a id="more"></a><h2 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h2><ul><li>jar包</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring事务的核心底层interface，定义了事务核心方法：getTransaction, commit, rollback。</p><h2 id="AbstractPlatformTransactionManager"><a href="#AbstractPlatformTransactionManager" class="headerlink" title="AbstractPlatformTransactionManager"></a>AbstractPlatformTransactionManager</h2><ul><li>jar包</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> Spring标准事务处理流程的抽象基类，定义了Spring事务处理框架。</p><ul><li>AbstractPlatformTransactionManager 利用模板方式定义了Spring标准事务的处理流程，并提供了必须的默认实现，且将doBengin, doSuspend, doResume, doCommit, doRollback等方法开放给继承类实现。</li></ul><p>AbstractPlatformTransactionManager 提供了如下事务流程功能</p><ol><li>确定是否已存在事务</li><li>处理事务传播行为</li><li>控制事务的暂停和恢复</li><li>检查commit上的rollback-only标记</li><li>在回滚时进行必要的处理</li><li>触发已注册的事务同步回调。trigger[Before/After][Begin/Commit/Rollback/…]系列，参见：TransactionSynchronizationUtils。</li></ol><h2 id="DataSourceTransactionManager"><a href="#DataSourceTransactionManager" class="headerlink" title="DataSourceTransactionManager"></a>DataSourceTransactionManager</h2><ul><li>jar包</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring TransactionManager的典型实现类。</p><p>继承了AbstractPlatformTransactionManager类，并做了完整的实现。可供编程式事务开发。也可作为TransactionManager的具体实现注入到如TransactionTemplate， Mybatis SqlSessionFactory中去。</p><h2 id="TransactionTemplate"><a href="#TransactionTemplate" class="headerlink" title="TransactionTemplate"></a>TransactionTemplate</h2><ul><li>jar包</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>TransactionTemplate 提供的是便捷的编程式事务的方法，将编程式上下文多个步骤合并成一个核心的execute方法。</p><p>其本身不具备事务管理的机制，需要通过注入PlatformTransactionManager的Bean实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTemplate</span> <span class="keyword">extends</span> <span class="title">DefaultTransactionDefinition</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">TransactionOperations</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TransactionTemplate</span><span class="params">(PlatformTransactionManager transactionManager)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.transactionManager = transactionManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(TransactionCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.transactionManager <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager) &#123;</span><br><span class="line"><span class="keyword">return</span> ((CallbackPreferringPlatformTransactionManager) <span class="keyword">this</span>.transactionManager).execute(<span class="keyword">this</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">TransactionStatus status = <span class="keyword">this</span>.transactionManager.getTransaction(<span class="keyword">this</span>);</span><br><span class="line">T result;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">result = action.doInTransaction(status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line"><span class="comment">// Transactional code threw application exception -&gt; rollback</span></span><br><span class="line">rollbackOnException(status, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line"><span class="comment">// Transactional code threw error -&gt; rollback</span></span><br><span class="line">rollbackOnException(status, err);</span><br><span class="line"><span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="comment">// Transactional code threw unexpected exception -&gt; rollback</span></span><br><span class="line">rollbackOnException(status, ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(ex, <span class="string">"TransactionCallback threw undeclared checked exception"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.transactionManager.commit(status);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rollbackOnException</span><span class="params">(TransactionStatus status, Throwable ex)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">logger.debug(<span class="string">"Initiating transaction rollback on application exception"</span>, ex);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.transactionManager.rollback(status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line">ex2.initApplicationException(ex);</span><br><span class="line"><span class="keyword">throw</span> ex2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException ex2) &#123;</span><br><span class="line">logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">logger.error(<span class="string">"Application exception overridden by rollback error"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Transactional-声明式事务"><a href="#Transactional-声明式事务" class="headerlink" title="@Transactional 声明式事务"></a>@Transactional 声明式事务</h1><p>理解Spring事务的核心对象和配合关系后，再来看Spring框架的声明式事务机制@Transactional就很简单了。</p><p><img src="/2018/08/11/Spring数据库原理-事务管理/image-20180811192914136.png" alt="image-20180811192914136"></p><p><img src="/2018/08/11/Spring数据库原理-事务管理/image-20180811192224441.png" alt="image-20180811192224441"></p><ol><li>sprint-tx包中的ProxyTransactionManagementConfiguration会去配置关于@Transactional注解的处理机制。其中核心的是注册了TransactionInterceptor作为切面事务处理类</li><li>当执行声明式事务的代码块之前，会优先被TransactionInterceptor拦截，先执行TransactionInterceptor#invoke进行事务包围。<ul><li>TransactionAspectSupport#invokeWithinTransaction</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionInterceptor</span> <span class="keyword">extends</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line"><span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line"><span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line">Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapt to TransactionAspectSupport's invokeWithinTransaction...</span></span><br><span class="line"><span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, <span class="keyword">new</span> InvocationCallback() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceedWithInvocation</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部其他方法详见TransactionAspectSupport源码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line"><span class="keyword">final</span> TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line"><span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line"><span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line"><span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">Object retVal = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line"><span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// target invocation exception</span></span><br><span class="line">completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line">commitTransactionAfterReturning(txInfo);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr,</span><br><span class="line"><span class="keyword">new</span> TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line"><span class="comment">// A RuntimeException: will lead to a rollback.</span></span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ThrowableHolderException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// A normal return value: will lead to a commit.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThrowableHolder(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check result: It might indicate a Throwable to rethrow.</span></span><br><span class="line"><span class="keyword">if</span> (result <span class="keyword">instanceof</span> ThrowableHolder) &#123;</span><br><span class="line"><span class="keyword">throw</span> ((ThrowableHolder) result).getThrowable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ThrowableHolderException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex.getCause();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;知识点分解&quot;&gt;&lt;a href=&quot;#知识点分解&quot; class=&quot;headerlink&quot; title=&quot;知识点分解&quot;&gt;&lt;/a&gt;知识点分解&lt;/h1&gt;&lt;h2 id=&quot;核心类对象&quot;&gt;&lt;a href=&quot;#核心类对象&quot; class=&quot;headerlink&quot; title=&quot;核心类对象&quot;&gt;&lt;/a&gt;核心类对象&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;对象&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;一句话介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;PlatformTransactionManager&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Spring事务的核心底层interface，定义了事务核心方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;AbstractPlatformTransactionManager&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Spring标准事务处理流程的抽象基类，定义了Spring事务处理框架&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;TransactionDefinition&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;事务属性相关。事务隔离级别；超时；传播行为；等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;TransactionStatus&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;事务实例状态对象，可供查询，用于回滚、SavePoint等场景&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;DataSourceTransactionManager&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Spring框架TransactionManager的典型实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;TransactionTemplate&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;将编程式上下文多个步骤合并成一个核心的execute方法，方便事务编程&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&quot;/2018/08/11/Spring数据库原理-事务管理/image-20180811172416549.png&quot; alt=&quot;image-20180811172416549&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/08/11/Spring数据库原理-事务管理/image-20180811172628386.png&quot; alt=&quot;image-20180811172628386&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="https://veryjj.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Spring" scheme="https://veryjj.github.io/tags/Spring/"/>
    
      <category term="数据库事务" scheme="https://veryjj.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring数据库原理-DataSource</title>
    <link href="https://veryjj.github.io/2018/08/11/Spring%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-DataSource/"/>
    <id>https://veryjj.github.io/2018/08/11/Spring数据库原理-DataSource/</id>
    <published>2018-08-11T06:57:39.000Z</published>
    <updated>2018-08-11T08:36:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>用Spring进行Web应用开发时，我们经常会做datasource的配置。而且datasource的配法风格各异。那么他们到底有哪些异同点呢？</p><p><img src="/2018/08/11/Spring数据库原理-DataSource/image-20180811151925263.png" alt="image-20180811151925263"></p><p><img src="/2018/08/11/Spring数据库原理-DataSource/image-20180811152018356.png" alt="image-20180811152018356"></p><p><img src="/2018/08/11/Spring数据库原理-DataSource/image-20180811152412438.png" alt="image-20180811152412438"></p><h2 id="DataSource作用"><a href="#DataSource作用" class="headerlink" title="DataSource作用"></a>DataSource作用</h2><p>DataSource是javax.sql包中的类，是Java原生rt.jar包中的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataSource</span>  <span class="keyword">extends</span> <span class="title">CommonDataSource</span>, <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>javax.sql.DataSource定义的是抽象方法，通过Java JNDI的方式将具体实现开放给各个厂商、组织自己、个人自己实现。</p><p>在Spring框架中，通过DataSource + 配置的方式，来定义具体的数据库源。并向Spring框架提供数据源的Connection服务。</p><p>在Spring中若想实现多数据源，那么就需要在DataSource下手。</p><h2 id="javax-sql-DataSource源码注释说明"><a href="#javax-sql-DataSource源码注释说明" class="headerlink" title="javax.sql.DataSource源码注释说明"></a>javax.sql.DataSource源码注释说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;p&gt;A factory for connections to the physical data source that this</span><br><span class="line"> * &#123;@code DataSource&#125; object represents.  An alternative to the</span><br><span class="line"> * &#123;@code DriverManager&#125; facility, a &#123;@code DataSource&#125; object</span><br><span class="line"> * is the preferred means of getting a connection. An object that implements</span><br><span class="line"> * the &#123;@code DataSource&#125; interface will typically be</span><br><span class="line"> * registered with a naming service based on the</span><br><span class="line"> * Java&amp;trade; Naming and Directory (JNDI) API.</span><br><span class="line"> * &lt;P&gt;</span><br><span class="line"> * The &#123;@code DataSource&#125; interface is implemented by a driver vendor.</span><br><span class="line"> * There are three types of implementations:</span><br><span class="line"> * &lt;OL&gt;</span><br><span class="line"> *   &lt;LI&gt;Basic implementation -- produces a standard &#123;@code Connection&#125;</span><br><span class="line"> *       object</span><br><span class="line"> *   &lt;LI&gt;Connection pooling implementation -- produces a &#123;@code Connection&#125;</span><br><span class="line"> *       object that will automatically participate in connection pooling.  This</span><br><span class="line"> *       implementation works with a middle-tier connection pooling manager.</span><br><span class="line"> *   &lt;LI&gt;Distributed transaction implementation -- produces a</span><br><span class="line"> *       &#123;@code Connection&#125; object that may be used for distributed</span><br><span class="line"> *       transactions and almost always participates in connection pooling.</span><br><span class="line"> *       This implementation works with a middle-tier</span><br><span class="line"> *       transaction manager and almost always with a connection</span><br><span class="line"> *       pooling manager.</span><br><span class="line"> * &lt;/OL&gt;</span><br><span class="line"> * &lt;P&gt;</span><br><span class="line"> * A &#123;@code DataSource&#125; object has properties that can be modified</span><br><span class="line"> * when necessary.  For example, if the data source is moved to a different</span><br><span class="line"> * server, the property for the server can be changed.  The benefit is that</span><br><span class="line"> * because the data source&apos;s properties can be changed, any code accessing</span><br><span class="line"> * that data source does not need to be changed.</span><br><span class="line"> * &lt;P&gt;</span><br><span class="line"> * A driver that is accessed via a &#123;@code DataSource&#125; object does not</span><br><span class="line"> * register itself with the &#123;@code DriverManager&#125;.  Rather, a</span><br><span class="line"> * &#123;@code DataSource&#125; object is retrieved though a lookup operation</span><br><span class="line"> * and then used to create a &#123;@code Connection&#125; object.  With a basic</span><br><span class="line"> * implementation, the connection obtained through a &#123;@code DataSource&#125;</span><br><span class="line"> * object is identical to a connection obtained through the</span><br><span class="line"> * &#123;@code DriverManager&#125; facility.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * An implementation of &#123;@code DataSource&#125; must include a public no-arg</span><br><span class="line"> * constructor.</span><br><span class="line"> *</span><br><span class="line"> * @since 1.4</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="概要翻译"><a href="#概要翻译" class="headerlink" title="概要翻译"></a>概要翻译</h3><ol><li>Part - 1:<ul><li>DataSource是获取物理数据源连接的工厂类。</li><li>作为DriverManager工具的替代方案，DataSource对象是获取连接的首选方法.</li><li>DataSource的实现类一般都通过JNDI的方式注册到框架中进行使用。</li></ul></li><li>Part - 2:<ul><li>DataSource一般由数据库厂商提供对应的实现类，DataSource有三种实现方式<ol><li>基本实现，生成标准连接对象。</li><li>连接池实现，适用于中间层连接池管理器。</li><li>分布式事务实现。此实现适用于中间层事务管理器，并且几乎总是使用连接池管理器。</li></ol></li></ul></li><li><p>Part - 3:</p><ul><li>DataSource向Spring框架屏蔽了具体数据源的差异，即当物理数据源切换时，只需要更新相关的DataSource配置值即可，不需要应用层修改代码。</li></ul></li><li><p>Part - 4:</p><ul><li>数据库Driver都是通过DataSource对象被注册到DriverManager中，而不是由Driver直接向DriverManager注册。</li><li>但是对于获取Connection，先通过检索先获得DataSource，再根据DataSource对象进行getConnection，而不是直接从DriverManager获取Connection。</li></ul></li></ol><h2 id="Spring-JDBC的DataSource实现案例"><a href="#Spring-JDBC的DataSource实现案例" class="headerlink" title="Spring-JDBC的DataSource实现案例"></a>Spring-JDBC的DataSource实现案例</h2><p><img src="/2018/08/11/Spring数据库原理-DataSource/img-1.png" alt="image"></p><p>在 Spring-jdbc 下，DataSource 最顶级的类是 AbstractDataSource ，对 DataSource 的所有父接口方法做了实现。但保留 getConnection() 方法由子类实现。</p><p>在 AbstractDriverBasedDataSource 中，定义了大量的参数，诸如 url, username 等，这些都被用来定位并定义与数据库实例的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.jdbc.datasource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.UsesJava7;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDriverBasedDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String catalog;</span><br><span class="line">    <span class="keyword">private</span> String schema;</span><br><span class="line">    <span class="keyword">private</span> Properties connectionProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDriverBasedDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......略</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getConnectionFromDriver(<span class="keyword">this</span>.getUsername(), <span class="keyword">this</span>.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getConnectionFromDriver(username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UsesJava</span>7</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Properties mergedProps = <span class="keyword">new</span> Properties();</span><br><span class="line">        Properties connProps = <span class="keyword">this</span>.getConnectionProperties();</span><br><span class="line">        <span class="keyword">if</span>(connProps != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mergedProps.putAll(connProps);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......略</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties var1)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合方案为将除 url 外的所有参数整合在同一个 Properties 对象中 (其中，Properties 可以被认为是一个线程安全的 Hash Map) 。最终调用 Connection getConnectionFromDriver(Properties props) 获取连接。</p><p>AbstractDriverBasedDataSource 抽象类的两个子类 DriverManagerDataSource 和 SimpleDriverDataSource 都以不同方式获得了连接(Connection)，但总结而言，获取连接(Connection) 的任务被委托给了 Driver 来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="comment">// SimpleDriverDataSource 的实现</span></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Driver driver = getDriver();</span><br><span class="line">    String url = getUrl();</span><br><span class="line">    Assert.notNull(driver, <span class="string">"Driver must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating new JDBC Driver Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> driver.connect(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="comment">// DriverManagerDataSource 的实现</span></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String url = getUrl();</span><br><span class="line">    Assert.state(url != <span class="keyword">null</span>, <span class="string">"'url' not set"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating new JDBC DriverManager Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调了个内部函数</span></span><br><span class="line">    <span class="keyword">return</span> getConnectionFromDriverManager(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriverManager</span><span class="params">(String url, Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 委托给 DriverManager 类来获取连接</span></span><br><span class="line">    <span class="comment">// DriverManager 的主要操作是遍历在该管理类中注册的 Driver</span></span><br><span class="line">    <span class="comment">// 每个 Driver 实例都去尝试一下，能不能获得一个连接</span></span><br><span class="line">    <span class="comment">// 第一次在某个 Driver 中拿到一个连接即返回连接 (Connection)</span></span><br><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(url, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DataSource&quot;&gt;&lt;a href=&quot;#DataSource&quot; class=&quot;headerlink&quot; title=&quot;DataSource&quot;&gt;&lt;/a&gt;DataSource&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;用Spring进行Web应用开发时，我们经常会做datasource的配置。而且datasource的配法风格各异。那么他们到底有哪些异同点呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/08/11/Spring数据库原理-DataSource/image-20180811151925263.png&quot; alt=&quot;image-20180811151925263&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/08/11/Spring数据库原理-DataSource/image-20180811152018356.png&quot; alt=&quot;image-20180811152018356&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/08/11/Spring数据库原理-DataSource/image-20180811152412438.png&quot; alt=&quot;image-20180811152412438&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;DataSource作用&quot;&gt;&lt;a href=&quot;#DataSource作用&quot; class=&quot;headerlink&quot; title=&quot;DataSource作用&quot;&gt;&lt;/a&gt;DataSource作用&lt;/h2&gt;&lt;p&gt;DataSource是javax.sql包中的类，是Java原生rt.jar包中的类。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataSource&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CommonDataSource&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Wrapper&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;Connection &lt;span class=&quot;title&quot;&gt;getConnection&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;Connection &lt;span class=&quot;title&quot;&gt;getConnection&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String username, String password)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="https://veryjj.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Spring" scheme="https://veryjj.github.io/tags/Spring/"/>
    
      <category term="DataSource" scheme="https://veryjj.github.io/tags/DataSource/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码解析-Consumer启动</title>
    <link href="https://veryjj.github.io/2018/06/02/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Consumer%E5%90%AF%E5%8A%A8/"/>
    <id>https://veryjj.github.io/2018/06/02/Dubbo源码解析-Consumer启动/</id>
    <published>2018-06-02T07:06:57.000Z</published>
    <updated>2018-06-02T08:14:24.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Dubbo Consumer的启动过程和Provider一样，以DubboNamespaceHandler为起点，去解析代码配置中的ReferenceBean。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>ReferenceBean同样既继承了ReferenceConfig，又实现了InitializingBean。也是在afterProperitesSet()中去执行服务引用<ul><li>ReferenceBean<ul><li>afterPropertiesSet<ul><li>ReferenceConfig<ul><li>init()<ul><li>完成service interface的class， methods解析</li><li>获取Service 注册中心registeries配置信息，用于向注册中西订阅service</li><li>检测是否配置有Dubbo Mock， Dubbo Stub</li><li>createProxy()完成ReferenceConfig + Registeries ——》 Dubbo Service Invoker的转化。createProxy()返回时，返回的是被Proxy后的Invoker，即外层加了Dubbo Filter Chain。<ul><li>DubboProtocol.refer(…)</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="DubboProtocol"><a href="#DubboProtocol" class="headerlink" title="DubboProtocol"></a>DubboProtocol</h3><p>DubboProtocol.class 作为Dubbo RPC层的具体实现协议，尤其完成Consumer中向注册中心真正订阅的动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        optimizeSerialization(url);</span><br><span class="line">        <span class="comment">// create rpc invoker with url.</span></span><br><span class="line">        DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">        invokers.add(invoker);</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class="line">        <span class="comment">// whether to share connection</span></span><br><span class="line">        <span class="keyword">boolean</span> service_share_connect = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> connections = url.getParameter(Constants.CONNECTIONS_KEY, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// if not configured, connection is shared, otherwise, one connection for one service</span></span><br><span class="line">        <span class="keyword">if</span> (connections == <span class="number">0</span>) &#123;</span><br><span class="line">            service_share_connect = <span class="keyword">true</span>;</span><br><span class="line">            connections = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExchangeClient[] clients = <span class="keyword">new</span> ExchangeClient[connections];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (service_share_connect) &#123;</span><br><span class="line">                clients[i] = getSharedClient(url);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                clients[i] = initClient(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get service interface.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> service interface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invoke.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与Service Provider端的连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeClient[] clients;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同一service的invokers集合，集群时用到。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Invoker&lt;?&gt;&gt; invokers;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboInvoker</span><span class="params">(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients, Set&lt;Invoker&lt;?&gt;&gt; invokers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(serviceType, url, <span class="keyword">new</span> String[]&#123;Constants.INTERFACE_KEY, Constants.GROUP_KEY, Constants.TOKEN_KEY, Constants.TIMEOUT_KEY&#125;);</span><br><span class="line">        <span class="keyword">this</span>.clients = clients;</span><br><span class="line">        <span class="comment">// get version.</span></span><br><span class="line">        <span class="keyword">this</span>.version = url.getParameter(Constants.VERSION_KEY, <span class="string">"0.0.0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.invokers = invokers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(Constants.VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="keyword">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">                currentClient.send(inv, isSent);</span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync) &#123;</span><br><span class="line">                ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReferenceConfig-核心数据"><a href="#ReferenceConfig-核心数据" class="headerlink" title="ReferenceConfig 核心数据"></a>ReferenceConfig 核心数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractReferenceConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//核心是DubboProtocol</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集群模式下使用，此处不解释</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册中心地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    <span class="comment">// interface name</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line">    <span class="comment">// client type</span></span><br><span class="line">    <span class="keyword">private</span> String client;</span><br><span class="line">    <span class="comment">// url for peer-to-peer invocation</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="comment">// Service的方法列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MethodConfig&gt; methods;</span><br><span class="line">    <span class="comment">// default config</span></span><br><span class="line">    <span class="keyword">private</span> ConsumerConfig consumer;</span><br><span class="line">    <span class="keyword">private</span> String protocol;</span><br><span class="line">    <span class="comment">// invoker 的代理类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> T ref;</span><br><span class="line">    <span class="comment">//原生的service invoker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Invoker&lt;?&gt; invoker;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> destroyed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConsumerModel"><a href="#ConsumerModel" class="headerlink" title="ConsumerModel"></a>ConsumerModel</h3><p>经过ReferenceConfig一番处理后，最终会得到：Reference Dubbo Service Name, InvokerRef, Service Methods, ReferenceConfig Instance。</p><p>这些信息会封装成ConsumerModel，放到ApplicationModel.class中去全局统一记录Consumer的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReferenceConfig metadata;</span><br><span class="line">    <span class="keyword">private</span> Object proxyObject;</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ConsumerMethodModel&gt; methodModels = <span class="keyword">new</span> IdentityHashMap&lt;Method, ConsumerMethodModel&gt;();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Dubbo Consumer的启动过程和Provider一样，以DubboNamespaceHandler为起点，去解析代码配置中的ReferenceBean。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReferenceBean&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReferenceConfig&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FactoryBean&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;ApplicationContextAware&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;InitializingBean&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;DisposableBean&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Dubbo" scheme="https://veryjj.github.io/tags/Dubbo/"/>
    
      <category term="RPC" scheme="https://veryjj.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] REST API必须是超文本驱动的</title>
    <link href="https://veryjj.github.io/2018/05/20/%E7%BF%BB%E8%AF%91-REST-API%E5%BF%85%E9%A1%BB%E6%98%AF%E8%B6%85%E6%96%87%E6%9C%AC%E9%A9%B1%E5%8A%A8%E7%9A%84/"/>
    <id>https://veryjj.github.io/2018/05/20/翻译-REST-API必须是超文本驱动的/</id>
    <published>2018-05-20T06:53:12.000Z</published>
    <updated>2018-05-20T06:55:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" target="_blank" rel="noopener">Roy T. Fielding: REST APIs must be hypertext-driven</a></p><blockquote><p>I am getting frustrated by the number of people calling any HTTP-based interface a REST API. Today’s example is the SocialSite REST API. That is RPC. It screams RPC. There is so much coupling on display that it should be given an X rating.</p></blockquote><p>我是越来越失望了，许多人把任何基于HTTP的接口叫做REST API，眼前的例子就是SocialSite REST API。那是RPC，实实在在的RPC。它与显示如此耦合，再差也莫过于此</p><a id="more"></a><blockquote><p>What needs to be done to make the REST architectural style clear on the notion that hypertext is a constraint? In other words, if the engine of application state (and hence the API) is not being driven by hypertext, then it cannot be RESTful and cannot be a REST API. Period. Is there some broken manual somewhere that needs to be fixed?</p></blockquote><p>基于超文本概念，如何才能确保清晰的REST架构风格呢？这样来说吧，如果应用程序状态引擎（即API）不是由超文本驱动的，那就不是RESTful也不是REST的API。就这么简单。某些REST方面的破手册是否该修正一下呢？</p><blockquote><p>API designers, please note the following rules before calling your creation a REST API:</p></blockquote><p>API的设计者们，把你们的那些东西叫做REST API前请注意以下的规则：</p><blockquote><p>A REST API should not be dependent on any single communication protocol, though its successful mapping to a given protocol may be dependent on the availability of metadata, choice of methods, etc. In general, any protocol element that uses a URI for identification must allow any URI scheme to be used for the sake of that identification. [Failure here implies that identification is not separated from interaction.]</p></blockquote><p>REST API不应依赖于任何特定的通讯协议，在采用某个具体协议时可能受限于元数据的有效性、方法的选择等。通常，协议元素使用URI作标识时，对该标识必须允许运用任何URI方案。[ 不符合这一点意味着标识与交互没有分离 ]</p><blockquote><p>A REST API should not contain any changes to the communication protocols aside from filling-out or fixing the details of underspecified bits of standard protocols, such as HTTP’s PATCH method or Link header field. Workarounds for broken implementations (such as those browsers stupid enough to believe that HTML defines HTTP’s method set) should be defined separately, or at least in appendices, with an expectation that the workaround will eventually be obsolete. [Failure here implies that the resource interfaces are object-specific, not generic.]</p></blockquote><p>REST API不应修改通讯协议中预留出来作为补充或修正标准协议用途的资源，例如HTTP的PATCH方法和Link head域。违背了这一原则的方案应当单独定义，或者至少在附录中标注出来这样的方案最终会废弃掉。[ 不符合这一点意味着资源接口是对象相关的，不通用 ]</p><blockquote><p>A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types. Any effort spent describing what methods to use on what URIs of interest should be entirely defined within the scope of the processing rules for a media type (and, in most cases, already defined by existing media types). [Failure here implies that out-of-band information is driving interaction instead of hypertext.]</p></blockquote><p>REST API应当将绝大部分精力放在媒体类型的定义上，或者是扩展关系名称的定义、已有超文本标记中的标准媒体类型等方面，以实现资源的表述、操作应用程序状态。任何类似于对某某URI应当使用什么样的方法等工作，都应当完全定义在特定媒体类型的处理规则范围中（绝大部分情况下已有媒体类型都已经定义好了这些规则）。[ 不符合这一点意味着交互是由其它信息驱动，而不是超文本 ]</p><blockquote><p>A REST API must not define fixed resource names or hierarchies (an obvious coupling of client and server). Servers must have the freedom to control their own namespace. Instead, allow servers to instruct clients on how to construct appropriate URIs, such as is done in HTML forms and URI templates, by defining those instructions within media types and link relations. [Failure here implies that clients are assuming a resource structure due to out-of band information, such as a domain-specific standard, which is the data-oriented equivalent to RPC’s functional coupling].</p></blockquote><p>REST API决不能定义固定的资源名称或者层次关系（这是明显的客户端、服务器端耦合），服务器必须可以自由控制自己的名称空间。应当像HTML forms和URI模板一样，通过媒体类型和链接关系指示客户端如何构造正确的URI。[ 不符合这一点意味着客户端在通过其它信息（例如领域相关标准）猜测资源结构，这是数据导向，类似于RPC的函数耦合 ]</p><blockquote><p>A REST API should never have “typed” resources that are significant to the client. Specification authors may use resource types for describing server implementation behind the interface, but those types must be irrelevant and invisible to the client. The only types that are significant to a client are the current representation’s media type and standardized relation names. [ditto]</p></blockquote><p>REST API决不能使用对客户端有重要意义的类型化资源。规范的作者可能使用资源类型描述接口背后的服务器端实现，但这些类型必须与客户端无关，对客户端不可见。对客户端唯一有意义的类型是当前的表述性媒体类型和标准的关系名称。[ 同上 ]</p><blockquote><p>A REST API should be entered with no prior knowledge beyond the initial URI (bookmark) and set of standardized media types that are appropriate for the intended audience (i.e., expected to be understood by any client that might use the API). From that point on, all application state transitions must be driven by client selection of server-provided choices that are present in the received representations or implied by the user’s manipulation of those representations. The transitions may be determined (or limited by) the client’s knowledge of media types and resource communication mechanisms, both of which may be improved on-the-fly (e.g., code-on-demand). [Failure here implies that out-of-band information is driving interaction instead of hypertext.]</p></blockquote><p>使用REST API应该只需要知道初始URI（书签）和一系列针对目标用户的标准媒体类型（任何客户端都了解用来操作该媒体类型的API）。这样所有的应用程序状态转换都通过这样的方式进行：服务器在返回的表述性消息中提供选项，由客户端进行选择，或者是伴随着用户对表述性内容的操作而进行。状态转换由客户端对媒体类型的了解程度和资源通讯机制决定，或者受限于这些因素，这些问题都可以根据实际情况得以改善的（例如使用javascript这种code-on-demand技术）。[ 不符合这一点意味着交互是由其它信息驱动，而不是超文本 ]</p><blockquote><p>There are probably other rules that I am forgetting, but the above are the rules related to the hypertext constraint that are most often violated within so-called REST APIs. Please try to adhere to them or choose some other buzzword for your API.</p></blockquote><p>也许还有其它一些规则我一时想不起来了，但在那些所谓的REST API中通常都违背了上面这些超文本约束相关的规则，请纠正这些错误或者改用其它称谓吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Roy T. Fielding: REST APIs must be hypertext-driven
&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I am getting frustrated by the number of people calling any HTTP-based interface a REST API. Today’s example is the SocialSite REST API. That is RPC. It screams RPC. There is so much coupling on display that it should be given an X rating.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我是越来越失望了，许多人把任何基于HTTP的接口叫做REST API，眼前的例子就是SocialSite REST API。那是RPC，实实在在的RPC。它与显示如此耦合，再差也莫过于此&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="REST" scheme="https://veryjj.github.io/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API命名实践</title>
    <link href="https://veryjj.github.io/2018/05/18/RESTful-API%E5%91%BD%E5%90%8D%E5%AE%9E%E8%B7%B5/"/>
    <id>https://veryjj.github.io/2018/05/18/RESTful-API命名实践/</id>
    <published>2018-05-18T02:29:30.000Z</published>
    <updated>2018-05-20T07:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在互联网高度普及的今天，作为一名Web开发者，如果你还没听说过“REST”这个技术名词，出门都不好意思跟人打招呼。尽管如此，对于REST这个泊来品的理解，大多数人仍然停留在“盲人摸象”的阶段。</p><p>有人认为，在Web Controller层写的API就是REST API。而且，从开发角度对于URI的命名、HTTP  Mehthod的选择没有建立起规范的意识。这样是不优雅的！（没有对错之分）</p><p>作为带着问题学习总结的我，未打算通过本篇文档全面的阐述清楚REST，而是尽量的总结一些理论和思考，一起探讨！</p><a id="more"></a><h1 id="REST-的诞生"><a href="#REST-的诞生" class="headerlink" title="REST 的诞生"></a>REST 的诞生</h1><h2 id="Web-技术发展"><a href="#Web-技术发展" class="headerlink" title="Web 技术发展"></a>Web 技术发展</h2><p>Web开发技术的发展可以粗略划分成以下几个阶段：</p><ol><li><p>静态内容阶段：在这个最初的阶段，使用Web的主要是一些研究机构。Web由大量的静态HTML文档组成，其中大多是一些学术论文。Web服务器可以被看作是支持超文本的共享文件服务器。</p><ul><li>可以想象下当时的HTTP请求只有“GET”，且MIME为“HTML或TEXT”</li></ul></li><li><p>CGI程序阶段：在这个阶段，Web服务器增加了一些编程API。通过这些API编写的应用程序，可以向客户端提供一些动态变化的内容。Web服务器与应用程序之间的通信，通过CGI（Common Gateway Interface）协议完成，应用程序被称作CGI程序。</p></li><li><p>脚本语言阶段：在这个阶段，服务器端出现了ASP、PHP、JSP、ColdFusion等支持session的脚本语言技术，浏览器端出现了Java Applet、JavaScript等技术。使用这些技术，可以提供更加丰富的动态内容。</p></li><li><p>瘦客户端应用阶段：在这个阶段，在服务器端出现了独立于Web服务器的应用服务器。同时出现了Web MVC开发模式，各种Web MVC开发框架逐渐流行，并且占据了统治地位。基于这些框架开发的Web应用，通常都是瘦客户端应用，因为它们是在服务器端生成全部的动态内容。</p></li><li><p>RIA应用阶段：在这个阶段，出现了多种RIA（Rich Internet Application）技术，大幅改善了Web应用的用户体验。应用最为广泛的RIA技术是DHTML+Ajax。Ajax技术支持在不刷新页面的情况下动态更新页面中的局部内容。同时诞生了大量的Web前端DHTML开发库，例如Prototype、Dojo、ExtJS、jQuery/jQuery UI等等，很多开发库都支持单页面应用（Single Page Application）的开发。其他的RIA技术还有Adobe公司的Flex、微软公司的Silverlight、Sun公司的JavaFX（现在为Oracle公司所有）等等。</p></li><li><p>移动Web应用阶段：在这个阶段，出现了大量面向移动设备的Web应用开发技术。除了Android、iOS、Windows Phone等操作系统平台原生的开发技术之外，基于HTML5的开发技术也变得非常流行。</p></li></ol><h2 id="REST-的诞生-1"><a href="#REST-的诞生-1" class="headerlink" title="REST 的诞生"></a>REST 的诞生</h2><p>从上述Web开发技术的发展过程看，Web从最初其设计者所构思的主要支持静态文档的阶段，逐渐变得越来越动态化。Web应用的交互模式，变得越来越复杂：从静态文档发展到以内容为主的门户网站、电子商务网站、搜索引擎、社交网站，再到以娱乐为主的大型多人在线游戏、手机游戏。</p><p>Web发展到了1995年，在CGI、ASP等技术出现之后，沿用了多年、主要面向静态文档的HTTP/1.0协议已经无法满足Web应用的开发需求，因此需要设计新版本的HTTP协议。在HTTP/1.0协议专家组之中，有一位年轻人脱颖而出，显示出了不凡的洞察力，后来他成为了HTTP/1.1协议专家组的负责人。这位年轻人就是Apache HTTP服务器的核心开发者Roy Fielding，他还是Apache软件基金会的合作创始人。</p><p>所以，REST 并不是在互联网诞生之初就有的，它是在HTTP/1.1协议中才出现的，由Roy Thomas Fielding这位大神对Web技术做了深入的总结和分析，提出的一套网络软件的架构风格理论框架，当时Fielding为这种架构风格取了一个轻松愉快的名字：“REST” ———— Representational State Transfer（表述性状态转移）</p><ul><li>Roy Thomas Fielding 关于REST的论文<ul><li><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf" target="_blank" rel="noopener">https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf</a></li></ul></li></ul><hr><h1 id="REST-详解"><a href="#REST-详解" class="headerlink" title="REST 详解"></a>REST 详解</h1><h2 id="REST-架构风格"><a href="#REST-架构风格" class="headerlink" title="REST 架构风格"></a>REST 架构风格</h2><pre><code>问题：REST 究竟是什么？是一种新的技术、一种新的架构、还是一种新的规范？</code></pre><p>首先，REST是Web自身的<code>架构风格</code>，也是世界上最成功的分布式应用架构风格。它是为运行在互联网环境的分布式超媒体系统量身定制的。</p><ul><li>REST是一种架构风格！</li><li>REST是一种架构风格！</li><li>REST是一种架构风格！</li></ul><p>所以，就会存在实际开发工作中即使没有正确的理解和应用REST，但也能顺利的完成开发工作。也正因为如此，给开发工作中推广正确实践和统一风格带来不小的困难。因为大多数程序员总是在寻找最快解决问题，最快完成需求的方式，怎么简单怎么来。</p><h2 id="解读-REST"><a href="#解读-REST" class="headerlink" title="解读 REST"></a>解读 REST</h2><pre><code>REST ———— Representational State Transfer (表现层状态转化)</code></pre><p>从“Representational State Transfer”这个定义去理解REST架构风格原则。</p><h3 id="1-资源（Resources）"><a href="#1-资源（Resources）" class="headerlink" title="1. 资源（Resources）"></a>1. 资源（Resources）</h3><p>REST 的名称“表现层状态转化”中，省略了主语。“表现层”其实指的是“资源（Resources）”的“表现层”</p><p>资源是一种看待服务器的方式，此处指的“资源”是一个抽象的概念，它不仅仅指服务器端真实存在的文件、数据库表，而是指任何可被名词表述的东西。所以在定义“资源”时可以要多抽象就多抽象。</p><p>对于客户端，可以将服务器端看作是由很多离散的资源组成。服务端可以用URI（统一资源定位符）指向资源，每种资源都对应一个特定的URI。要向获取这个资源，访问它的URI就可以了，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓“上网”，就是与互联网上一系列的“资源”互动，调用它的URI。</p><h3 id="2-表现层（Representation）"><a href="#2-表现层（Representation）" class="headerlink" title="2. 表现层（Representation）"></a>2. 表现层（Representation）</h3><p>“资源”是一种信息实体，它可以有多在的表现形式。我们把“资源”具体呈现出来的形式，叫做它的“表现层（Representation）”</p><p>比如，文本信息可以用txt格式表现，也可以用HTML格式 、XML格式、JSON格式表现，甚至可以用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的表现形式。资源的具体表现形式，应该在HTTP请求的的头部信息中用Accept和Content-Type字段指明，这两个字段才是对“表现层”的描述。  </p><ul><li>详见HTTP MIME明细</li></ul><h3 id="3-状态转化（State-Transfer）"><a href="#3-状态转化（State-Transfer）" class="headerlink" title="3. 状态转化（State Transfer）"></a>3. 状态转化（State Transfer）</h3><p>HTTP协议是一个无状态的协议，这意味着所有资源的状态都保存在服务器端。因为客户端想要操作服务器，必须通过某种手段，让服务器端资源发生“状态转化”。而这种转化是建立在表现层之上的，所以就是“表现层状态转化”。</p><p>客户端用到的手段，只能是HTTP协议。具体对应HTTP协议中的HTTP Method：GET、POST、PUT、PATCH、DELETE、HEAD、OPTIONS。每一种HTTP Method代表资源状态转化的一种<code>约定的</code>方式。</p><p><strong>HTTP 动词</strong></p><p>对于资源的具体操作类型，有HTTP动词表示。</p><p>常用的HTTP动词如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- GET : 从服务器取出资源（一个或多个）</span><br><span class="line"></span><br><span class="line">- POST : 在服务器新建一个资源，并返回创建后的完整资源到客户端</span><br><span class="line"></span><br><span class="line">- PUT : 在服务器以覆盖形式，全量更新资源，并返回更新后的完整资源到客户端</span><br><span class="line"></span><br><span class="line">- PATCH : 在服务器端更新资源，但只更新指定的内容</span><br><span class="line"></span><br><span class="line">- DELETE : 在服务器端删除资源</span><br></pre></td></tr></table></figure><p>其中，GET、PUT、PATCH、DELETE都应该是幂等的。</p><p>另外，HEAD、OPTIONS对于团队开发来说基本不用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- HEAD : 获取资源的元数据</span><br><span class="line"></span><br><span class="line">- OPTIONS : 获取信息，关于资源的哪些属性是客户端可以改变的</span><br></pre></td></tr></table></figure><h3 id="4-综述"><a href="#4-综述" class="headerlink" title="4. 综述"></a>4. 综述</h3><p>综合上面的解读，总结一下什么是REST架构风格：</p><p>(1) 服务器端的任何信息和数据都要被抽象资源化；<br>(2) 资源用URI进行表述，每一个URI代表一种资源；<br>(3) 客户端与服务器之间，基于某种表现层形式，互相传递资源；<br>(4) 客户端与服务器之间，基于HTTP Method对服务器端资源的操作，实现“表现层状态转化”；  </p><h2 id="REST-与-RESTful"><a href="#REST-与-RESTful" class="headerlink" title="REST 与 RESTful"></a>REST 与 RESTful</h2><p>定义：  </p><ul><li>如果一个架构符合REST原则，就称它为RESTful架构</li><li>如果HTTP API的设计符合REST原则，那么可称它为RESTful API</li></ul><p>所以，回到开篇讲的大多数人对于REST还是处于“盲人摸象”的阶段，回想下自己和身边的同事，在工作中经常交流到的REST API或RESTful API，其实只能算个HTTP API吧？</p><hr><h1 id="REST-风格优点"><a href="#REST-风格优点" class="headerlink" title="REST 风格优点"></a>REST 风格优点</h1><p>架构风格不是非此即彼的是非题，在实际开发中可以自主的选择是否应用REST风格。那么，如果应用REST风格会带来哪些优势呢？</p><ol><li>从面向操作编程，转变为面向资源编程。更面向对象，架构更清晰、松耦合。<ul><li>我们应该确定的认为系统由“资源+对资源的操作”组成，而不是由“操作”组成</li><li>面向操作编程会导致API膨胀，功能重复度高。</li></ul></li><li>统一URI命名风格，URI具备很强的可读性，具备自解释的能力。服务器资源层次目录清晰。</li><li>状态无关。确保系统横向扩展的能力。</li><li>超文本驱动。确保系统演化的能力。</li></ol><hr><h1 id="REST实践体会"><a href="#REST实践体会" class="headerlink" title="REST实践体会"></a>REST实践体会</h1><h2 id="1-URI命名难度变大"><a href="#1-URI命名难度变大" class="headerlink" title="1. URI命名难度变大"></a>1. URI命名难度变大</h2><p>在没有要求URI必须用资源名词来组成URI时，URI的命名从来不是什么难事，常见的命名风格有：</p><ul><li>动词+名词<ul><li>/deposit/getUsers: 获取某个项目保证金用户列表</li><li>/orders/submitAudit: 订单提交审核 </li><li>/cart/add: 商品加购物车</li></ul></li><li>URI全局唯一即可<ul><li>/finance/budget/getPurchaseplanNextAuditOrgList：我有点小无语…  </li></ul></li></ul><blockquote><p>为什么会这样：</p></blockquote><p>我们平时搞系统是这样的：</p><ol><li>有新建用户功能</li><li>新建用户需要一个URL</li><li>往这个URL发送的数据要定义好</li><li>开始写后端和前端</li></ol><p>这是以操作为第一位的设计方法，首先确认了一个操作，然后围绕这个操作把周边需要的东西建设好，这种方式当然可以架构出一个系统，甚至是一个好系统，但是偶尔会有些问题：</p><ol><li>操作之间是会有关联，你的设计容易变成“第2个操作要求第1个操作进行过”，这种关系多起来你的系统就乱了</li><li>你的URL设计会缺乏一致性</li><li>操作通常被认为是有副作用（Side Effect）的，所以很少有人基于操作去设计缓存之类的东西  </li></ol><blockquote><p>该怎么应对？</p></blockquote><p>确实，REST是高度抽象的理论和风格，在实际开发中会面对各种复杂的功能和场景，导致很难完全的应用REST风格。当我们在争论REST风格到底如何设计才是正宗时，发现心中的困惑不仅没有降低，反而增加了。</p><p>我的想法：仍以真正的系统需求为出发点，使用REST风格让系统的架构更清晰，让系统的开发协作更高效。部分不适合REST的场景应该灵活变通。</p><p>回到URI的命名：</p><ol><li>坚持URI仍以资源为导向，清晰的表述服务器端资源目录</li><li>保障URI资源层次清晰的情况下，只允许在URI最末一级添加动词，例如：/market/orders/1/audit</li><li>如果某些动作是HTTP动词表示不了的，考虑把动作抽象成一种资源</li></ol><p>比如：网上汇款，从账户1向账户2汇款100元，错误的URI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /accounts/1/transfer/500/to/2</span><br></pre></td></tr></table></figure><p>正确的写法是把动词transfer改成名词transaction</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /transaction?from=1&amp;to=2&amp;amount=100</span><br></pre></td></tr></table></figure><h2 id="2-用不用HTTP-PATCH"><a href="#2-用不用HTTP-PATCH" class="headerlink" title="2. 用不用HTTP PATCH"></a>2. 用不用HTTP PATCH</h2><p>PATCH 作为HTTP的Method之一，其实它是2010年3月份才正式成为HTTP Method的，详见：<a href="http://tools.ietf.org/html/rfc5789" target="_blank" rel="noopener">RFC 5789</a></p><p>也正因为PATCH出现的晚, 所以并不是所有Web容器都支持，反而目前实现了PATCH方法的Web容器很少</p><p>几个常见Web容器实现PATCH方法的情况，供参考：</p><ol><li>Apache HttpComponents HttpClient version 4.2 or later 支持了 PATCH</li><li>目前 JDK7 的 HttpURLConnection 未实现 PATCH</li><li>TOMCAT 7 也不行</li><li>PlayFramework 2 也不支持</li><li>Spring 3.2 开始支持 PATCH 方法，但要选对部署的容器</li><li>JBoss Netty 支持 PATCH，可见： <a href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/handler/codec/http/class-use/HttpMethod.html" target="_blank" rel="noopener">http://docs.jboss.org/netty/3.2/api/org/jboss/netty/handler/codec/http/class-use/HttpMethod.html</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在互联网高度普及的今天，作为一名Web开发者，如果你还没听说过“REST”这个技术名词，出门都不好意思跟人打招呼。尽管如此，对于REST这个泊来品的理解，大多数人仍然停留在“盲人摸象”的阶段。&lt;/p&gt;
&lt;p&gt;有人认为，在Web Controller层写的API就是REST API。而且，从开发角度对于URI的命名、HTTP  Mehthod的选择没有建立起规范的意识。这样是不优雅的！（没有对错之分）&lt;/p&gt;
&lt;p&gt;作为带着问题学习总结的我，未打算通过本篇文档全面的阐述清楚REST，而是尽量的总结一些理论和思考，一起探讨！&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="RESTful" scheme="https://veryjj.github.io/tags/RESTful/"/>
    
      <category term="Web" scheme="https://veryjj.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引合并</title>
    <link href="https://veryjj.github.io/2018/05/06/MySQL%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6/"/>
    <id>https://veryjj.github.io/2018/05/06/MySQL索引合并/</id>
    <published>2018-05-06T09:55:18.000Z</published>
    <updated>2018-05-07T00:57:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h2><p>MySQL 5.0版本之前，一个表一次只能选择并使用一个索引。</p><p>MySQL 5.1版本开始，引入了Index Merge Optimization技术，使得MySQL支持一个表一次查询同时使用多个索引。</p><p>官方文档：<a href="https://dev.mysql.com/doc/refman/5.5/en/index-merge-optimization.html" target="_blank" rel="noopener">MySQL Index Merge Optimization</a> </p><p>Index Merge Optimization支持三种合并算法</p><ul><li>The Index Merge Intersection Access Algorithm<ul><li>对应SQL 中的 AND 场景</li></ul></li><li>The Index Merge Union Access Algorithm<ul><li>对应SQL中的 OR 场景（where条件是等值判断）</li></ul></li><li>The Index Merge Sort-Union Access Algorithm<ul><li>对应SQL中的 OR 场景（where条件是范围查询）</li></ul></li></ul><a id="more"></a><blockquote><p>注：索引合并(Index Merge)的使用取决于optimizer_switch系统变量的index_merge，index_merge_intersection，index_merge_union和index_merge_sort_union标志的值。默认情况下，所有这些标志都打开。 要仅启用特定算法，请将index_merge设置为关闭，并仅启用其他应允许的其他算法。</p></blockquote><p>##关于”Index Merge Intersection Access Algorithm”的疑问</p><blockquote><p>针对 MySQL Index Merge Optimization Intersection Algorithm</p></blockquote><p>AND 场景的 index merge optimization为什么会比使用单个索引来的高效？</p><p>设想：</p><ul><li><p>使用单个索引的场景</p><ol><li>选中选择性高的索引先获得一份数据</li><li>在再mysql服务器端用using where的方式，按第二条件进行过滤，得到最终满足所有条件的数据行。</li></ol></li><li><p>同时使用表内多个索引的场景</p><ol><li>按每个索引，在索引树里拿只满足本索引条件的行数据</li><li>将两份行数据，放一块进行交集运算。</li><li>从索引的次数、磁盘IO、内存交接运算来看，事情没变少、反而变多了。</li></ol></li></ul><hr><h2 id="自我初版解释"><a href="#自我初版解释" class="headerlink" title="自我初版解释"></a>自我初版解释</h2><h4 id="合理的解释"><a href="#合理的解释" class="headerlink" title="合理的解释"></a>合理的解释</h4><p>样例SQL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_sample where column_1 = A AND column_2 = B;</span><br></pre></td></tr></table></figure></p><ol><li>前提条件，SQL中不能有范围查询，如果存在范围查询，数据库优化器默认使用单索引方式，不用index merge optimization</li><li>SQL的<code>WHERE从句中的所有条件字段都有对应的索引</code>，否则问题就来了，肯定会在内存中有次using_where的。</li><li>单表多Index并行检索时，拿到的是数据行地址，以上述SQL为例，即拿到了两份行数据地址：Index Column_1的行数据地址集，Index Column_2的行数据地址集</li><li>再在内存中完成两份行数据地址集的交集运算（只需要比地址）</li><li>此时，再决定是否回表拿更多的数据。<ul><li>如果字段中有primary key，就不用回表啦！</li></ul></li></ol><ul><li>如上的执行步骤，就会比较合理。有效率上的优势。</li></ul><h4 id="【更进一步】-explain-显示type-为-index-merge时，到底要不要引起关注？"><a href="#【更进一步】-explain-显示type-为-index-merge时，到底要不要引起关注？" class="headerlink" title="【更进一步】 explain 显示type 为 index_merge时，到底要不要引起关注？"></a>【更进一步】 explain 显示type 为 index_merge时，到底要不要引起关注？</h4><p><code>【需要引起注意】</code></p><p>拿着SQL琢磨下，是否还有优化的空间，例如：采用组合索引；强制走单索引（需要对比测试看效果，还要看业务数据场景和增长趋势）；</p><hr><p>注：</p><ol><li>当索引本身信息可以覆盖select的字段时（或是select count(*)）,效率会很高，因为内存索引里已经能提供返回的数据了，不用回表。</li><li>当索引本身信息不能覆盖select的字段时，就要回表查行数据了，性能差别很大。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;历史背景&quot;&gt;&lt;a href=&quot;#历史背景&quot; class=&quot;headerlink&quot; title=&quot;历史背景&quot;&gt;&lt;/a&gt;历史背景&lt;/h2&gt;&lt;p&gt;MySQL 5.0版本之前，一个表一次只能选择并使用一个索引。&lt;/p&gt;
&lt;p&gt;MySQL 5.1版本开始，引入了Index Merge Optimization技术，使得MySQL支持一个表一次查询同时使用多个索引。&lt;/p&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.5/en/index-merge-optimization.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL Index Merge Optimization&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;Index Merge Optimization支持三种合并算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Index Merge Intersection Access Algorithm&lt;ul&gt;
&lt;li&gt;对应SQL 中的 AND 场景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The Index Merge Union Access Algorithm&lt;ul&gt;
&lt;li&gt;对应SQL中的 OR 场景（where条件是等值判断）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The Index Merge Sort-Union Access Algorithm&lt;ul&gt;
&lt;li&gt;对应SQL中的 OR 场景（where条件是范围查询）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="https://veryjj.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://veryjj.github.io/tags/MySQL/"/>
    
      <category term="索引" scheme="https://veryjj.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL子查询很慢的问题分析</title>
    <link href="https://veryjj.github.io/2018/05/04/MySQL%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%BE%88%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>https://veryjj.github.io/2018/05/04/MySQL子查询很慢的问题分析/</id>
    <published>2018-05-04T07:29:46.000Z</published>
    <updated>2018-05-04T07:33:35.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="慢查询案例"><a href="#慢查询案例" class="headerlink" title="慢查询案例"></a>慢查询案例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> settlement_invoice_attachment g1 <span class="keyword">WHERE</span> demand_id <span class="keyword">in</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> settlement_invoice_demand g2 <span class="keyword">WHERE</span> statement_id = <span class="number">1802065000000074956</span>)</span><br></pre></td></tr></table></figure><p>乍眼一看，上述SQL如此简单，且demand_id和statement_id字段都是建了索引，即使是Review也会认为是OK没问题的。</p><p>然而，实际情况却是个慢查询，情况如下：</p><p><strong>explain明细</strong></p><p><img src="/2018/05/04/MySQL子查询很慢的问题分析/img-1.png" alt="image"></p><a id="more"></a><p>settlement_invoice_attachment是全表查</p><p>注：rows 2689 是因为用的测试环境，真线环境数据是几十万级别</p><hr><h4 id="子查询-原理分析-上述SQL子查询为什么这么慢"><a href="#子查询-原理分析-上述SQL子查询为什么这么慢" class="headerlink" title="子查询 原理分析(上述SQL子查询为什么这么慢)"></a>子查询 原理分析(上述SQL子查询为什么这么慢)</h4><h5 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a><code>经验之谈</code></h5><ul><li>当看到SQL执行计划中select_type字段出现“DEPENDENT SUBQUERY”的时候，要打起精神了！着重分析下潜在风险！</li></ul><h5 id="基础知识：Dependent-SubQuery意味着什么？"><a href="#基础知识：Dependent-SubQuery意味着什么？" class="headerlink" title="基础知识：Dependent SubQuery意味着什么？"></a>基础知识：Dependent SubQuery意味着什么？</h5><ul><li>官方含义为：<ol><li>SUBQUERY: 子查询中的第一个SELECT；</li><li>DEPENDENT SUBQUERY: 子查询中的第一个SELECT， 取决于外面的查询。</li></ol></li></ul><p>换句话说，就是<code>子查询的g2查询执行方式依赖于外层g1的查询结果</code><br>什么意思呢？它以为着两步走：</p><ul><li>第一步：【先执行外部SQL查询】MySQL根据”DELETE FROM settlement_invoice_attachment g1 WHERE” 得到一个大结果集t1，其数据量就是全表所有行了，假设是85万行。</li><li>第二步：【后执行内部SQL子查询】第一步的大结果集t1中的每一条记录，都将与子查询SQL组成新的查询语句：SELECT id FROM settlement_invoice_demand g2 WHERE statement_id = 1802065000000074956 AND id = %t1.demand_id%。等于说，子查询要执行85万次……即使这两部查询都用到了索引，也是巨慢的。</li></ul><h5 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h5><ul><li>改写SQL为JOIN的方式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> ah <span class="keyword">FROM</span> settlement_invoice_attachment ah <span class="keyword">INNER</span> <span class="keyword">JOIN</span> settlement_invoice_demand de </span><br><span class="line"><span class="keyword">ON</span> ah.demand_id = de.id <span class="keyword">WHERE</span> de.statement_id = <span class="number">1802065000000074956</span>;</span><br></pre></td></tr></table></figure><ul><li>拆成独立SQL多次执行</li></ul><hr><h4 id="平时怎么识别？"><a href="#平时怎么识别？" class="headerlink" title="平时怎么识别？"></a>平时怎么识别？</h4><ul><li>看子查询出现的位置<ul><li>若子查询出现在WHERE从句中，而且是出现在IN（）中，则需要引起注意，用Explain瞧瞧（并不是子查询放IN（）里就一定是全表扫，本案例用，将DELETE改成SELECT就不是DEPENDENT SUBQUERY）</li></ul></li></ul><h4 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h4><ol><li><p>MySQL处理子查询时，会(优化)改写子查询，但优化的不是很友好，一直受业界批评比较多</p><ul><li>有时候优化的挺糟糕的，特别是WHERE从句中的IN（）子查询</li></ul></li><li><p>MySQL 子查询的弱点</p><ul><li>mysql 在处理子查询时，会改写子查询。通常情况下，我们希望由内到外，先完成子查询的结果，然后再用子查询来驱动外查询的表，完成查询。</li></ul></li></ol><p>例如：select * from test where tid in(select fk_tid from sub_test where gid=10)<br>通常我们会感性地认为该 sql 的执行顺序是：</p><p>1、sub_test 表中根据 gid 取得 fk_tid(2,3,4,5,6)记录。<br>2、然后再到 test 中，带入 tid=2,3,4,5,6，取得查询数据。</p><p>但是实际mysql的处理方式为：<br>select <em> from test where exists (select </em> from sub_test where gid=10 and sub_test.fk_tid=test.tid)<br>mysql 将会扫描 test 中所有数据，每条数据都将会传到子查询中与 sub_test 关联，子查询不会先被执行，所以如果 test 表很大的话，那么性能上将会出现问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;慢查询案例&quot;&gt;&lt;a href=&quot;#慢查询案例&quot; class=&quot;headerlink&quot; title=&quot;慢查询案例&quot;&gt;&lt;/a&gt;慢查询案例&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; settlement_invoice_attachment g1 &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; demand_id &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; settlement_invoice_demand g2 &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; statement_id = &lt;span class=&quot;number&quot;&gt;1802065000000074956&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;乍眼一看，上述SQL如此简单，且demand_id和statement_id字段都是建了索引，即使是Review也会认为是OK没问题的。&lt;/p&gt;
&lt;p&gt;然而，实际情况却是个慢查询，情况如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;explain明细&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/05/04/MySQL子查询很慢的问题分析/img-1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SQL" scheme="https://veryjj.github.io/tags/SQL/"/>
    
      <category term="数据库" scheme="https://veryjj.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码解析-Provider暴露服务</title>
    <link href="https://veryjj.github.io/2018/05/02/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Provider%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1/"/>
    <id>https://veryjj.github.io/2018/05/02/Dubbo源码解析-Provider暴露服务/</id>
    <published>2018-05-02T13:20:44.000Z</published>
    <updated>2018-05-05T01:49:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Dubbo Provider暴露服务的流程中，需要掌握几个核心抽象对象</p><ul><li>过程中的重要类<ul><li>ServiceConfig：记录了Dubbo Service所有相关的配置信息。<a href="#ServiceConfig">ServiceConfig作用</a></li><li>DubboProtocol：以Dubbo协议的方式暴露服务，并以此为中心维护所有相关的动态服务数据。</li><li>RegisterProtocol: 内部会加载具体的注册中心Register,例如：ZookeeperRegister。完成服务向注册中心注册的动作。</li><li>ServiceConfig#loadRegistries：解析获得注册中心地址列表</li></ul></li></ul><ul><li>过程中的重要对象<ul><li>com.alibaba.dubbo.common.URL: 服务发布的地址</li><li>Invoker: 对原Service Interface进行了代理封装，屏蔽了具体Service Interface的差异，方便统一管理和调用。</li><li>Exporter： 一个ServiceBean每向一个注册中心Register注册一次，就会生成已各Exporter。Exporter用于连接暴露服务的Url与本地Invoker的对应关系。</li><li>ExporterMap: 记录着服务地址和Exporter的对应关系</li></ul></li></ul><a id="more"></a><ul><li>来自Dubbo官方的几个架构设计图，先感觉下</li></ul><p><img src="/2018/05/02/Dubbo源码解析-Provider暴露服务/img-2.png" alt="image"></p><p><img src="/2018/05/02/Dubbo源码解析-Provider暴露服务/img-1.png" alt="image"></p><h2 id="ServiceBean核心流程"><a href="#ServiceBean核心流程" class="headerlink" title="ServiceBean核心流程"></a>ServiceBean核心流程</h2><ol><li>Spring容器启动，带动Dubbo Bean配置解析以及Bean实例化。<ul><li><a href="#Dubbo 启动">Dubbo启动</a></li><li>关键类：<ul><li>DubboNamespaceHandler</li><li>ServiceBean</li><li><a href="#ServiceConfig">ServiceConfig作用</a></li></ul></li></ul></li><li>ServiceBean 继承了ServiceConfig，所有的Provider服务的Dubbo配置都在ServiceConfig中。<ul><li>Dubbo Service基本信息</li><li>Dubbo Service参数配置</li><li>注册中心地址信息。对应ServiceConfig中的loadRegistries().</li></ul></li><li>ServiceBean 实现了InitializingBean, 实现了afterPropertiesSet()方法，在每个Dubbo Service Bean实例化后，在afterPropertiesSet()方法中进行所有Dubbo服务注册需要的操作。</li><li>afterPropertiesSet()中前置代码都是在做一些配置校验和默认值设置，最后会执行export()方法注册暴露服务。</li><li>afterPropertiesSet()<ul><li>export()<ul><li>doExport()<ul><li>doExportUrls()<ul><li>doExportUrlsFor1Protocol(DubboProtocol, regitsryURLs)<ul><li>DubboProtocol.export(wrapperInvoker)</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<url> registryURLs) 是真正执行export暴露服务的代码区<ul><li></li></ul></url></li></ol><h2 id="DubboProtocol-Export核心流程"><a href="#DubboProtocol-Export核心流程" class="headerlink" title="DubboProtocol#Export核心流程"></a>DubboProtocol#Export核心流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// export service.</span></span><br><span class="line">    String key = serviceKey(url);</span><br><span class="line">    DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//export an stub service for dispatching event</span></span><br><span class="line">    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">        <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"consumer ["</span> + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">                        <span class="string">"], has set stubproxy support event ,but no stub methods founded."</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个服务端口，使用NettyServer绑定并监听，并设置Server监听事件处理回调为：DubboProtocol#requestHandler</span></span><br><span class="line">    <span class="comment">//Exchanger.bind的实际对象可配置，对应dubbo-remoting-api包</span></span><br><span class="line">    openServer(url);   </span><br><span class="line">    optimizeSerialization(url);</span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DubboProtocol核心数据"><a href="#DubboProtocol核心数据" class="headerlink" title="DubboProtocol核心数据"></a>DubboProtocol核心数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DubboProtocol INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//本地启动Server监听服务的Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ExchangeServer&gt; serverMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ExchangeServer&gt;(); <span class="comment">// &lt;host:port,Exchanger&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录消费端的Exchanger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ReferenceCountExchangeClient&gt; referenceClientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ReferenceCountExchangeClient&gt;(); <span class="comment">// &lt;host:port,Exchanger&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, LazyConnectExchangeClient&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; optimizers = <span class="keyword">new</span> ConcurrentHashSet&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//consumer side export a stub service for dispatching event</span></span><br><span class="line">    <span class="comment">//servicekey-stubmethods</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, String&gt; stubServiceMethodsMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> ExchangeHandler requestHandler = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ExporterMap</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Exporter&lt;?&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dubbo-Service是哪个时机注册到注册中心的？"><a href="#Dubbo-Service是哪个时机注册到注册中心的？" class="headerlink" title="Dubbo Service是哪个时机注册到注册中心的？"></a>Dubbo Service是哪个时机注册到注册中心的？</h3><blockquote><p>有关注到这个章节内容的小伙伴，说明你此时可能也还没想通吧，请听我道来。</p></blockquote><p>这里会涉及到Dubbo的SPI机制，Dubbo 有好几个利用SPI+动态代理+Filter的处理责任链模式，ProtocolFilterWrapper.java算一个。  </p><pre><code>- Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</code></pre><p>在Dubbo源码中，Dubbo有自行注册几个protocol SPI （这里只列举Dubbo服务注册相关的） </p><ul><li><a href="http://dubbo.apache.org/books/dubbo-dev-book/SPI.html" target="_blank" rel="noopener">SPI机制用法详见</a></li><li><a href="http://dubbo.apache.org/books/dubbo-dev-book/impls/protocol.html" target="_blank" rel="noopener">Dubbo Protocol SPI扩展详见</a></li><li>RegistryProtocol SPI: <ul><li>注册位置：dubbo-registry-api包,resources下的com.alibaba.dubbo.rpc.Protocol</li><li>注册位置：dubbo-registry-zookeeper包,resources下的com.alibaba.dubbo.register.RegistryFactory</li></ul></li></ul><p>其实，在ServiceConfig中拿到的全局protocol并不直接是DubboProtocol，而是一串Protocol，DubboProtocol只是其中之一，这些Protocol会以责任链的方式逐一被调用</p><p>所以，在doExportUrlsFor1Protocol中protocol.export(…)时，会先执行DubboProtocol#export,再执行RegisterProtocol#export,各司其职。</p><p>RegisterProtocol中会根据Dubbo Service配置的register地址类型来决定加载哪个具体的RegisterFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registedProviderUrl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//RegisterFactory根据注册中心类型，获取到注册实例，例如ZookeeperRegistry</span></span><br><span class="line">        Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行注册，实际对应ZookeeperRegistry#register</span></span><br><span class="line">        registry.register(registedProviderUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (register) &#123;</span><br><span class="line">            register(registryUrl, registedProviderUrl);</span><br><span class="line">            ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Netty-Server"><a href="#Netty-Server" class="headerlink" title="Netty Server"></a>Netty Server</h3><p>当DubboProtocol.export.openServer()时，就是在本地启动Dubbo Service的Server服务并启动监听。</p><p>实现上是通过Exchanger拿到被配置的信息交换层的实现套件（一般是Netty）。  </p><pre><code>- 获取一个服务端口，使用NettyServer绑定并监听，并设置Server监听事件处理回调为：DubboProtocol#requestHandler- Exchanger.bind的实际对象可配置，对应dubbo-remoting-api包</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Channel&gt; channels; <span class="comment">// &lt;ip:port, channel&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerBootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> org.jboss.netty.channel.Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        NettyHelper.setNettyLoggerFactory();</span><br><span class="line">        ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br><span class="line">        ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line">        ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">        channels = nettyHandler.getChannels();</span><br><span class="line">        <span class="comment">// https://issues.jboss.org/browse/NETTY-365</span></span><br><span class="line">        <span class="comment">// https://issues.jboss.org/browse/NETTY-379</span></span><br><span class="line">        <span class="comment">// final Timer timer = new HashedWheelTimer(new NamedThreadFactory("NettyIdleTimer", true));</span></span><br><span class="line">        bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">                ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">                <span class="comment">/*int idleTimeout = getIdleTimeout();</span></span><br><span class="line"><span class="comment">                if (idleTimeout &gt; 10000) &#123;</span></span><br><span class="line"><span class="comment">                    pipeline.addLast("timer", new IdleStateHandler(timer, idleTimeout / 1000, 0, 0));</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">                pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">                pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">                pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">                <span class="keyword">return</span> pipeline;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// bind</span></span><br><span class="line">        channel = bootstrap.bind(getBindAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Channel <span class="title">getChannel</span><span class="params">(InetSocketAddress remoteAddress)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBound</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ServiceConfig作用-见代码注释"><a href="#ServiceConfig作用-见代码注释" class="headerlink" title="ServiceConfig作用(见代码注释)"></a><span id="ServiceConfig">ServiceConfig作用(见代码注释)</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用的protocol远程调用层实现，用于封装RPC调用，默认是DubboProtocol，其余可选还有HttpProtocol,HessianProtocol,InjvmProtocol,RedisProtocol等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对ServiceBean进行代理，包装成Dubbo内部通用的Invoker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ServiceBean作为Dubbo Provider启动时，会在本地起server服务，每个server服务都会绑定并监听端口。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; RANDOM_PORT_MAP = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录已暴露服务的服务地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个ServiceBean每向一个注册中心Register注册一次，就会生成已各Exporter。Exporter用于连接暴露服务的Url与本地Invoker的对应关系。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Exporter&lt;?&gt;&gt; exporters = <span class="keyword">new</span> ArrayList&lt;Exporter&lt;?&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关于本ServiceBean的Java Class信息</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line">    <span class="comment">// reference to interface impl</span></span><br><span class="line">    <span class="keyword">private</span> T ref;</span><br><span class="line">    <span class="comment">// service name</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">// method configuration</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MethodConfig&gt; methods;</span><br><span class="line">    <span class="keyword">private</span> ProviderConfig provider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exported;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> unexported;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String generic;</span><br></pre></td></tr></table></figure><h3 id="Dubbo-启动"><a href="#Dubbo-启动" class="headerlink" title="Dubbo 启动"></a><span id="Dubbo 启动">Dubbo 启动</span></h3><p>Spring容器启动，带动Dubbo Bean配置实例化。Dubbo Bean配置来自于Dubbo Provider XML 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"application"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"module"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"registry"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"monitor"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"protocol"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"service"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class="keyword">true</span>));  <span class="comment">//dubbo provider bean配置解析</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"reference"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class="keyword">false</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation"</span>, <span class="keyword">new</span> AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体详见笔记：<a href="/2018/04/22/Dubbo源码解析-Spring-Bean注册/">Dubbo源码解析-Spring Bean注册</a></li></ul><h3 id="ServiceBean实例化"><a href="#ServiceBean实例化" class="headerlink" title="ServiceBean实例化"></a>ServiceBean实例化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean 继承了ServiceConfig，所有的Provider服务的Dubbo配置都在ServiceConfig中。</p><p>ServiceBean 实现了InitializingBean, 实现了afterPropertiesSet()方法，在每个Dubbo Service Bean实例化后，进行暴露服务的相关操作。</p><p>afterPropertiesSet()中前置代码都是在做一些配置校验和默认值设置，最后会执行export()方法注册暴露服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">//如果没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> (getProvider() == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">//获取IOC容器里的所有provider  </span></span><br><span class="line">            Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span>  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (providerConfigMap != <span class="keyword">null</span> &amp;&amp; providerConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span>  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">                <span class="keyword">if</span> ((protocolConfigMap == <span class="keyword">null</span> || protocolConfigMap.size() == <span class="number">0</span>)  </span><br><span class="line">                        &amp;&amp; providerConfigMap.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// 兼容旧版本  </span></span><br><span class="line">                    List&lt;ProviderConfig&gt; providerConfigs = <span class="keyword">new</span> ArrayList&lt;ProviderConfig&gt;();  </span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() != <span class="keyword">null</span> &amp;&amp; config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                            providerConfigs.add(config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="comment">//关联所有providers  </span></span><br><span class="line">                    <span class="keyword">if</span> (providerConfigs.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                        setProviders(providerConfigs);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    ProviderConfig providerConfig = <span class="keyword">null</span>;  </span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                            <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate provider configs: "</span> + providerConfig + <span class="string">" and "</span> + config);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            providerConfig = config;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                        setProvider(providerConfig);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置application，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span>  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getApplication() == <span class="keyword">null</span>)) &#123;  </span><br><span class="line">            <span class="comment">//获取所有applications  </span></span><br><span class="line">            Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (applicationConfigMap != <span class="keyword">null</span> &amp;&amp; applicationConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                ApplicationConfig applicationConfig = <span class="keyword">null</span>;  </span><br><span class="line">                <span class="keyword">for</span> (ApplicationConfig config : applicationConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate application configs: "</span> + applicationConfig + <span class="string">" and "</span> + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        applicationConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联application  </span></span><br><span class="line">                <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    setApplication(applicationConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置module，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> (getModule() == <span class="keyword">null</span>  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getModule() == <span class="keyword">null</span>)) &#123;  </span><br><span class="line">            Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (moduleConfigMap != <span class="keyword">null</span> &amp;&amp; moduleConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                ModuleConfig moduleConfig = <span class="keyword">null</span>;  </span><br><span class="line">                <span class="keyword">for</span> (ModuleConfig config : moduleConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate module configs: "</span> + moduleConfig + <span class="string">" and "</span> + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        moduleConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联module  </span></span><br><span class="line">                <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    setModule(moduleConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置registries，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> ((getRegistries() == <span class="keyword">null</span> || getRegistries().size() == <span class="number">0</span>)  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getRegistries() == <span class="keyword">null</span> || getProvider().getRegistries().size() == <span class="number">0</span>)  </span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getRegistries() == <span class="keyword">null</span> || getApplication().getRegistries().size() == <span class="number">0</span>)) &#123;  </span><br><span class="line">            Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (registryConfigMap != <span class="keyword">null</span> &amp;&amp; registryConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                List&lt;RegistryConfig&gt; registryConfigs = <span class="keyword">new</span> ArrayList&lt;RegistryConfig&gt;();  </span><br><span class="line">                <span class="keyword">for</span> (RegistryConfig config : registryConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        registryConfigs.add(config);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联registries  </span></span><br><span class="line">                <span class="keyword">if</span> (registryConfigs != <span class="keyword">null</span> &amp;&amp; registryConfigs.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="keyword">super</span>.setRegistries(registryConfigs);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置monitor，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> (getMonitor() == <span class="keyword">null</span>  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getMonitor() == <span class="keyword">null</span>)  </span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getMonitor() == <span class="keyword">null</span>)) &#123;  </span><br><span class="line">            Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (monitorConfigMap != <span class="keyword">null</span> &amp;&amp; monitorConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                MonitorConfig monitorConfig = <span class="keyword">null</span>;  </span><br><span class="line">                <span class="keyword">for</span> (MonitorConfig config : monitorConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate monitor configs: "</span> + monitorConfig + <span class="string">" and "</span> + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        monitorConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联monitor  </span></span><br><span class="line">                <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    setMonitor(monitorConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置protocol，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> ((getProtocols() == <span class="keyword">null</span> || getProtocols().size() == <span class="number">0</span>)  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getProtocols() == <span class="keyword">null</span> || getProvider().getProtocols().size() == <span class="number">0</span>)) &#123;  </span><br><span class="line">            Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span>  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (protocolConfigMap != <span class="keyword">null</span> &amp;&amp; protocolConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                List&lt;ProtocolConfig&gt; protocolConfigs = <span class="keyword">new</span> ArrayList&lt;ProtocolConfig&gt;();  </span><br><span class="line">                <span class="keyword">for</span> (ProtocolConfig config : protocolConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        protocolConfigs.add(config);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联protocol  </span></span><br><span class="line">                <span class="keyword">if</span> (protocolConfigs != <span class="keyword">null</span> &amp;&amp; protocolConfigs.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="keyword">super</span>.setProtocols(protocolConfigs);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置path  </span></span><br><span class="line">        <span class="keyword">if</span> (getPath() == <span class="keyword">null</span> || getPath().length() == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; beanName.length() &gt; <span class="number">0</span>   </span><br><span class="line">                    &amp;&amp; getInterface() != <span class="keyword">null</span> &amp;&amp; getInterface().length() &gt; <span class="number">0</span>  </span><br><span class="line">                    &amp;&amp; beanName.startsWith(getInterface())) &#123;  </span><br><span class="line">                setPath(beanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//暴露provider,重点！！！</span></span><br><span class="line">        <span class="keyword">if</span> (! isDelay()) &#123;  </span><br><span class="line">            export();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Export暴露服务"><a href="#Export暴露服务" class="headerlink" title="Export暴露服务"></a>Export暴露服务</h3><ul><li>export()方法会完成后续服务注册的所有流程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//如果provider没有配置  </span></span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">//如果exporter没有配置使用provider所关联的exporter  </span></span><br><span class="line">            <span class="keyword">if</span> (export == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                export = provider.getExport();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//如果delay（延迟暴露）没有配置，获取provider的delay  </span></span><br><span class="line">            <span class="keyword">if</span> (delay == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                delay = provider.getDelay();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果不需要暴露接口则直接返回  </span></span><br><span class="line">        <span class="keyword">if</span> (export != <span class="keyword">null</span> &amp;&amp; ! export.booleanValue()) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果延迟暴露的时间（毫秒级）是存在的，开启线程并等待delay毫秒后开始暴露接口，否则直接执行暴露接口过程  </span></span><br><span class="line">        <span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        Thread.sleep(delay);  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    doExport();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">            thread.setDaemon(<span class="keyword">true</span>);  </span><br><span class="line">            thread.setName(<span class="string">"DelayExportServiceThread"</span>);  </span><br><span class="line">            thread.start();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            doExport();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Dubbo Provider暴露服务的流程中，需要掌握几个核心抽象对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过程中的重要类&lt;ul&gt;
&lt;li&gt;ServiceConfig：记录了Dubbo Service所有相关的配置信息。&lt;a href=&quot;#ServiceConfig&quot;&gt;ServiceConfig作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;DubboProtocol：以Dubbo协议的方式暴露服务，并以此为中心维护所有相关的动态服务数据。&lt;/li&gt;
&lt;li&gt;RegisterProtocol: 内部会加载具体的注册中心Register,例如：ZookeeperRegister。完成服务向注册中心注册的动作。&lt;/li&gt;
&lt;li&gt;ServiceConfig#loadRegistries：解析获得注册中心地址列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;过程中的重要对象&lt;ul&gt;
&lt;li&gt;com.alibaba.dubbo.common.URL: 服务发布的地址&lt;/li&gt;
&lt;li&gt;Invoker: 对原Service Interface进行了代理封装，屏蔽了具体Service Interface的差异，方便统一管理和调用。&lt;/li&gt;
&lt;li&gt;Exporter： 一个ServiceBean每向一个注册中心Register注册一次，就会生成已各Exporter。Exporter用于连接暴露服务的Url与本地Invoker的对应关系。&lt;/li&gt;
&lt;li&gt;ExporterMap: 记录着服务地址和Exporter的对应关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Dubbo" scheme="https://veryjj.github.io/tags/Dubbo/"/>
    
      <category term="RPC" scheme="https://veryjj.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>服务端业务处理不成功，应该返回HTTP 200 还是 HTTP 4XXX系列？</title>
    <link href="https://veryjj.github.io/2018/04/23/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E4%B8%8D%E6%88%90%E5%8A%9F%EF%BC%8C%E5%BA%94%E8%AF%A5%E8%BF%94%E5%9B%9EHTTP-200-%E8%BF%98%E6%98%AF-HTTP-4XXX%E7%B3%BB%E5%88%97%EF%BC%9F/"/>
    <id>https://veryjj.github.io/2018/04/23/服务端业务处理不成功，应该返回HTTP-200-还是-HTTP-4XXX系列？/</id>
    <published>2018-04-23T06:27:23.000Z</published>
    <updated>2018-04-23T06:29:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>其实，纠结只出现在例如保存表单的场景，如果服务端因各种业务上的原因（校验不通过，状态不满足等）导致保存未成功，并要返回对应的提示信息，此时服务端回应此HTTP 请求时，是用 “200 + json” 还是用“400 + 错误信息”？</p><p>在公司内不同项目间，两种风格都有，且小伙伴们各执己见。</p><a id="more"></a><h2 id="我这么看"><a href="#我这么看" class="headerlink" title="我这么看"></a>我这么看</h2><p>首先，我先表达我赞同“200 + json”的方式。</p><p>更具体些，服务端所有的Controller Method对返回值做统一的Response包装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">样例<span class="number">1</span>：</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"code"</span>: <span class="number">200</span>,</span><br><span class="line">   <span class="string">"data"</span>: &#123;...&#125;,</span><br><span class="line">   <span class="string">"message"</span>:<span class="string">"操作成功"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">样例<span class="number">2</span>：</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"success"</span>: <span class="keyword">false</span></span><br><span class="line">   <span class="string">"data"</span>: &#123;...&#125;,</span><br><span class="line">   <span class="string">"code"</span>: <span class="number">100409</span>,</span><br><span class="line">   <span class="string">"message"</span>:<span class="string">"数据已存在"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我的观点"><a href="#我的观点" class="headerlink" title="我的观点"></a>我的观点</h3><h4 id="1-协议分层"><a href="#1-协议分层" class="headerlink" title="1. 协议分层"></a>1. 协议分层</h4><p>对于RPC请求，存在两个层面的操作结果</p><p>[1] HTTP请求本身的结果 ———— 业务无关性，与网络、框架层面相关<br>[2] 业务处理的结果 ———— 强业务逻辑相关性，与网络、框架层面无关</p><p>为什么我们会有本贴讨论的话题与分歧，或者说为什么大部分人觉得http code不够试用，是因为实际开发应用场景中，尝试着只用http code 去表达上述两个层面的结果。</p><p>分层表示的优点：</p><ol><li>RPC请求， 是可以基于不同的底层协议的， 比如我们用的HTTP协议，很容易替换成ZeroMQ, RabbitMQ,  UDP， 基于TCP的自定义协议…… 只要能实现一问一答模型的协议，都是可以用的。这个时候， HTTP协议只是一种底层协议， 底层协议的错误号，并不应该被上层协议使用。</li></ol><h4 id="2-HTTP-Code-表达能力局限性"><a href="#2-HTTP-Code-表达能力局限性" class="headerlink" title="2. HTTP Code 表达能力局限性"></a>2. HTTP Code 表达能力局限性</h4><p>虽然HTTP协议非常友好的定义了诸多的HTTP Code码，但在实际开发应用中，对于繁多的应用场景，HTTP Code的表达能力显得力不从心，部分场景仍旧不能避免的辅以Response Body信息。加之这些HTTP Code并不是应用开发中的绝对标准。</p><h4 id="3-HTTP-Code-语义表达的不统一性"><a href="#3-HTTP-Code-语义表达的不统一性" class="headerlink" title="3. HTTP Code 语义表达的不统一性"></a>3. HTTP Code 语义表达的不统一性</h4><p>[1] 同样是HTTP 4XX系列，不同系统的解释也是不一样的<br>[2] 同样是”参数校验不通过”的业务问题，不同系统使用的HTTP码也是不一样的</p><h4 id="4-Http-Code数量有限，表达能力有限"><a href="#4-Http-Code数量有限，表达能力有限" class="headerlink" title="4. Http Code数量有限，表达能力有限"></a>4. Http Code数量有限，表达能力有限</h4><p>这个应该很好理解，大家应该也有体会。</p><h4 id="5-系统集成友好性"><a href="#5-系统集成友好性" class="headerlink" title="5. 系统集成友好性"></a>5. 系统集成友好性</h4><p>如果我们把HTTP协议当作一种传输层协议看待，200 可以很好表达， 整个底层传输都是没有问题， 包括负载均衡系统， nginx， 反向代理， fast cgi守护程序都是工作正常的。</p><p>而返回各种HTTP Status Code经常会让外部使用者非常的困惑，特别是他们对HTTP Status Code有一定了解，却对你的系统不甚了解的情况下。</p><p>所以，除了考虑ajax请求的处理，还要考虑整个调用的中间链路以及框架集成方面的因素</p><ul><li>返回200能避免CDN等中间商替换或缓存<ul><li>国内的通信运营商画蛇添足根据HTTP状态码给替换成导航页或广告推广页面</li></ul></li><li>对于系统审计程序不友好，例如 HTTP Response Code = 4XX的请求算请求成功？请求失败？请求异常？————无法区分！</li></ul><h4 id="6-扩展性"><a href="#6-扩展性" class="headerlink" title="6. 扩展性"></a>6. 扩展性</h4><ul><li>返回200OK，扩展性更强，修改的时候只需要修改字段而不需要特别处理Status Code</li><li>易于与真正的400错误区分，方便审计和分析。而实际上，当服务器能够正常返回，证明服务器已经正确的理解并得出相应的结果（并且这个结果也是预定义的，并非未知），这显然与400的定义不符。</li><li>返回200更优。保不准哪天某种状态是HTTP协议不支持的，保不准哪个需要新增的字段是HTTP协议没有的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;其实，纠结只出现在例如保存表单的场景，如果服务端因各种业务上的原因（校验不通过，状态不满足等）导致保存未成功，并要返回对应的提示信息，此时服务端回应此HTTP 请求时，是用 “200 + json” 还是用“400 + 错误信息”？&lt;/p&gt;
&lt;p&gt;在公司内不同项目间，两种风格都有，且小伙伴们各执己见。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HTTP" scheme="https://veryjj.github.io/tags/HTTP/"/>
    
      <category term="WEB" scheme="https://veryjj.github.io/tags/WEB/"/>
    
      <category term="REST" scheme="https://veryjj.github.io/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码解析-Spring Bean注册</title>
    <link href="https://veryjj.github.io/2018/04/22/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring-Bean%E6%B3%A8%E5%86%8C/"/>
    <id>https://veryjj.github.io/2018/04/22/Dubbo源码解析-Spring-Bean注册/</id>
    <published>2018-04-22T11:34:18.000Z</published>
    <updated>2018-04-23T06:29:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家对于Dubbo Provider/Consumer的配置非常熟练，但这背后的实现原理清楚吗？如果有不太清楚的朋友，可以再往下阅读下。</p><a id="more"></a><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>自定义 Spring XML Bean机制</li></ul><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>据我们所知</p><p>Spring 注解方式声明Bean的方式是在Class上打上@Component注解（@Component的扩展注解也可），当Spring容器启动时，Spring会自动扫面所有带有@Component注解的Class，自动注册到Bean容器中。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过XML文件配置的方式声明Bean</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Student"</span> <span class="attr">class</span>=<span class="string">"com.test.spring.beans.Student"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但，回过头来看Dubbo，我们并没有通过上述的方式去声明Dubbo配置中的Bean，却也能像使用Spring Bean一样用@Autowire去注入Dubbo服务的Bean，这其中的原理是什么呢？让我们从源码中找答案。</p><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="启动Spring容器"><a href="#启动Spring容器" class="headerlink" title="启动Spring容器"></a>启动Spring容器</h3><p>在SpringBoot+Dubbo的搭配中，Java应用的启动入口main方法一般会这么写。通过此步骤去启动Java程序并将Dubbo Bean注册Spring容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sample;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;</span><br><span class="line">        <span class="string">"com.sample.myapp"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//启动Spring容器</span></span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(MyApplication.class,  </span><br><span class="line">                <span class="string">"classpath:/spring/dubbo-config.xml"</span>);  <span class="comment">//指定Dubbo配置文件</span></span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring如何识别Dubbo-自定义Bean标签"><a href="#Spring如何识别Dubbo-自定义Bean标签" class="headerlink" title="Spring如何识别Dubbo 自定义Bean标签"></a>Spring如何识别Dubbo 自定义Bean标签</h3><p>Spring为了支持用户自定义类加载到Spring容器，提供了org.springframework.beans.factory.xml.NamespaceHandler接口和org.springframework.beans.factory.xml.NamespaceHandlerSupport抽象类，NamespaceHandler#init方法会在对象的构造函数调用之后、属性初始化之前被DefaultNamespaceHandlerResolver调用。dubbo的DubboNamespaceHandler类正是继承了NamespaceHandlerSupport，其代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"application"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"module"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"registry"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"monitor"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"protocol"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"service"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"reference"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class="keyword">false</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation"</span>, <span class="keyword">new</span> AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerBeanDefinitionParser方法使用的是父抽象类NamespaceHandlerSupport的默认实现，第一个参数是elementName，即元素名称，即告诉Spring你要解析哪个标签，第二个参数是BeanDefinitionParser的实现类，BeanDefinitionParser是Spring用来将xml元素转换成BeanDefinition对象的接口。dubbo的DubboBeanDefinitionParser类就实现了这个接口，负责将标签转换成bean定义对象BeanDefinition。</p><p>所以，以后想要了解Dubbo Bean初始化相关细节，可以查看DubboBeanDefinitionParser#parse的代码实现。</p><p>例如：</p><ul><li>Dubbo Bean 会有哪些默认设置<ul><li>dubbo服务提供者使用dubbo:service标签时，如果既不设置id，也不设置name，则dubbo给ServiceBean在Spring容器中定义的ID是什么？</li></ul></li><li>Dubbo xml文件中的配置是怎么作用到Dubbo Bean中去的</li></ul><h4 id="关于NamespaceHandlerSupport"><a href="#关于NamespaceHandlerSupport" class="headerlink" title="关于NamespaceHandlerSupport"></a>关于NamespaceHandlerSupport</h4><ul><li>spring.handlers           # 指定xml namespace的解析handler类</li><li>spring.schemas            # 指定xml xsd文件位置</li><li>dubbo.xsd                 # 设计你要的xml配置格式</li><li>DubboNamespaceHandler     # 自定义NamespaceHandler,完成从xml中读取配置内容，并转换成Spring Bean进行注册</li></ul><p>Spring容器会默认加载classpath/META-INF下的spring.handlers和spring.schemas两个文件，来加载xsd和对应的NamespaceHandler,所以dubbo-config-spring包下的META-INF目录下也有这两个文件</p><hr><h2 id="练习DEMO"><a href="#练习DEMO" class="headerlink" title="练习DEMO"></a>练习DEMO</h2><p><strong>1. 设计配置属性和JavaBean</strong></p><p>设计好配置项，并通过JavaBean来建模，本例中需要配置People实体，配置属性name和age（id是默认需要的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String id;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> Integer age;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 编写XSD文件</strong></p><p>为上一步设计好的配置项编写XSD文件，XSD是schema的定义文件，配置的输入和解析输出都是以XSD为契约，本例中XSD如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;  </span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://veryjj/cutesource/schema/people"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:beans</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">targetNamespace</span>=<span class="string">"http://veryjj/cutesource/schema/people"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">elementFormDefault</span>=<span class="string">"qualified"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">attributeFormDefault</span>=<span class="string">"unqualified"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"people"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:complexType</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:complexContent</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">xsd:extension</span> <span class="attr">base</span>=<span class="string">"beans:identifiedType"</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span> /&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"xsd:int"</span> /&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">xsd:extension</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">xsd:complexContent</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于xsd:schema的各个属性具体含义就不作过多解释，可以参见<a href="http://www.w3school.com.cn/schema/schema_schema.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/schema/schema_schema.asp</a></p><p>&lt;xsd:element name=”people”&gt;对应着配置项节点的名称，因此在应用中会用people作为节点名来引用这个配置</p><p>&lt;xsd:attribute name=”name” type=”xsd:string” /&gt;和&lt;xsd:attribute name=”age” type=”xsd:int” /&gt;对应着配置项people的两个属性名，因此在应用中可以配置name和age两个属性，分别是string和int类型</p><p>完成后需把xsd存放在classpath下，一般都放在META-INF目录下（本例就放在这个目录下）</p><p><strong>3. 编写NamespaceHandler和BeanDefinitionParser完成解析工作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"people"</span>, <span class="keyword">new</span> PeopleBeanDefinitionParser());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Class <span class="title">getBeanClass</span><span class="params">(Element element)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> People.class;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder bean)</span> </span>&#123;  </span><br><span class="line">        String name = element.getAttribute(<span class="string">"name"</span>);  </span><br><span class="line">        String age = element.getAttribute(<span class="string">"age"</span>);  </span><br><span class="line">        String id = element.getAttribute(<span class="string">"id"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(id)) &#123;  </span><br><span class="line">            bean.addPropertyValue(<span class="string">"id"</span>, id);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(name)) &#123;  </span><br><span class="line">            bean.addPropertyValue(<span class="string">"name"</span>, name);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(age)) &#123;  </span><br><span class="line">            bean.addPropertyValue(<span class="string">"age"</span>, Integer.valueOf(age));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 编写spring.handlers和spring.schemas串联起所有部件</strong></p><p>spring提供了 spring.handlers和spring.schemas这两个配置文件来完成这项工作，这两个文件需要我们自己编写并放入META-INF文件夹 中，这两个文件的地址必须是META-INF/spring.handlers和META-INF/spring.schemas，spring会默认去 载入它们，本例中spring.handlers如下所示：</p><p>spring.handlers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://veryjj/cutesource/schema/people=study.schemaExt.MyNamespaceHandler</span><br></pre></td></tr></table></figure><p>spring.schemas</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://veryjj/cutesource/schema/people.xsd=META-INF/people.xsd</span><br></pre></td></tr></table></figure><p>以上就是载入xsd文件</p><p><strong>5. 使用自定义schema定义Spring Bean</strong></p><p>到此为止一个简单的自定义配置以完成，可以在具体应用中使用了。使用方法很简单，和配置一个普通的spring bean类似，只不过需要基于我们自定义schema，本例中引用方式如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:cutesource</span>=<span class="string">"http://veryjj/cutesource/schema/people"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://veryjj/cutesource/schema/people http://veryjj/cutesource/schema/people.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">cutesource:people</span> <span class="attr">id</span>=<span class="string">"cutesource"</span> <span class="attr">name</span>=<span class="string">"黄老师"</span> <span class="attr">age</span>=<span class="string">"27"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中xmlns:cutesource=”<a href="http://veryjj/cutesource/schema/people&quot;" target="_blank" rel="noopener">http://veryjj/cutesource/schema/people&quot;</a> 是用来指定自定义schema，xsi:schemaLocation用来指定xsd文件。&lt;cutesource:people id=”cutesource” name=”黄老师” age=”27”/&gt;是一个具体的自定义配置使用实例。</p><p><strong>6. 注入自定义schema定义的Spring Bean</strong></p><p>跟Spring Bean的注入方式完全一样，按你喜欢的方式来。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信大家对于Dubbo Provider/Consumer的配置非常熟练，但这背后的实现原理清楚吗？如果有不太清楚的朋友，可以再往下阅读下。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Dubbo" scheme="https://veryjj.github.io/tags/Dubbo/"/>
    
      <category term="RPC" scheme="https://veryjj.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码解析-Dubbo可以这么学</title>
    <link href="https://veryjj.github.io/2018/04/22/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Dubbo%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E5%AD%A6/"/>
    <id>https://veryjj.github.io/2018/04/22/Dubbo源码解析-Dubbo可以这么学/</id>
    <published>2018-04-22T08:23:17.000Z</published>
    <updated>2018-04-23T06:29:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近面试工作颇多，Dubbo作为的微服务主流技术架构，也是分布式系统中面试的高频考题之一。但从面试的过程中得到的反馈，大家对于Dubbo的关注以及掌握程度基本都处于会基本使用的程度，基本没遇到有对Dubbo框架做学习研究的求职者。</p><p>求职者一般只会聊下面两个话题：</p><ol><li>Dubbo 是什么东西？<ul><li>答：RPC框架/微服务框架，在实际工作中用Dubbo做业务功能服务化。</li></ul></li><li>Dubbo的工作原理是什么样的？<ul><li>答：Provider端将服务注册到Zookeeper中，Consumer端从Zookeeper获取Provider，然后就可以调用API了。</li></ul></li></ol><a id="more"></a><p>一般情况下关于Dubbo的基本都聊到此结束了，虽然说没回答错，但也忒简洁了吧，连Dubbo架构图中（下图）的内容都没说完整，而这并不是面试官想得到的讯息。</p><p><img src="/2018/04/22/Dubbo源码解析-Dubbo可以这么学/img-1.png" alt="image"></p><hr><p>Dubbo作为主流的微服务技术框架，必然有其优秀的一面，也是学习RPC框架思想很好的素材</p><p>Dubbo 应该掌握哪些内容？（个人思路）</p><ol><li>阅读Dubbo的用户手册以及开发手册。<a href="http://dubbo.apache.org" target="_blank" rel="noopener">Dubbo.io</a><ul><li>知晓Dubbo支持的功能</li><li>知晓Dubbo的各种扩展点</li><li>知晓Dubbo的设计思想（这里不得不说Dubbo.io的文档说明写的非常详细、到位，甚至一度让我觉得没有写Blog的必要）</li></ul></li><li>Dubbo 核心流程源码实现<ol><li>Dubbo Bean的集成</li><li>Provider 注册、暴露服务</li><li>Consumer 注册、订阅服务</li><li>Consumer 调用实现</li><li>Provider 处理请求</li><li>Dubbo SPI机制</li><li>Dubbo Filter机制</li></ol></li><li>思考些高级的<ol><li>Dubbo各可配机制主流选择的优缺点<ul><li>register</li><li>remoting</li><li>rpc</li></ul></li><li>Dubbo Cluster</li><li>Dubbo 怎么做服务治理<ul><li>策略路由</li><li>降级</li><li>熔断</li></ul></li><li>Dubbo 性能基线&amp;性能调优</li><li>框架扩展<ul><li>服务监控</li><li>流量分析</li></ul></li></ol></li></ol><p>那么，逐步的去落实吧！如果开始、请务必坚持！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近面试工作颇多，Dubbo作为的微服务主流技术架构，也是分布式系统中面试的高频考题之一。但从面试的过程中得到的反馈，大家对于Dubbo的关注以及掌握程度基本都处于会基本使用的程度，基本没遇到有对Dubbo框架做学习研究的求职者。&lt;/p&gt;
&lt;p&gt;求职者一般只会聊下面两个话题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dubbo 是什么东西？&lt;ul&gt;
&lt;li&gt;答：RPC框架/微服务框架，在实际工作中用Dubbo做业务功能服务化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dubbo的工作原理是什么样的？&lt;ul&gt;
&lt;li&gt;答：Provider端将服务注册到Zookeeper中，Consumer端从Zookeeper获取Provider，然后就可以调用API了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Dubbo" scheme="https://veryjj.github.io/tags/Dubbo/"/>
    
      <category term="RPC" scheme="https://veryjj.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Netty 核心对象梳理-1</title>
    <link href="https://veryjj.github.io/2018/04/08/Netty-%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86-1/"/>
    <id>https://veryjj.github.io/2018/04/08/Netty-核心对象梳理-1/</id>
    <published>2018-04-08T13:14:56.000Z</published>
    <updated>2018-04-11T08:30:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>《Netty In Action》阅读笔记摘要</p><p><img src="/2018/04/08/Netty-核心对象梳理-1/img-1.png" alt="image"></p><a id="more"></a><h2 id="What-is-Netty"><a href="#What-is-Netty" class="headerlink" title="What is Netty"></a>What is Netty</h2><p>Netty是一款用于快速<code>开发高性能的网络应用程序的Java框架</code> </p><ul><li>它封装了网络编程的复杂性</li></ul><p><strong>Key words:</strong>  </p><ol><li>是一款Java语言的开发框架</li><li>封装、提供程序快速网络编程的能力</li><li>高性能</li></ol><h5 id="Netty是完全异步和事件驱动的"><a href="#Netty是完全异步和事件驱动的" class="headerlink" title="Netty是完全异步和事件驱动的"></a>Netty是完全异步和事件驱动的</h5><hr><h2 id="Netty-核心组件"><a href="#Netty-核心组件" class="headerlink" title="Netty 核心组件"></a>Netty 核心组件</h2><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 是Java NIO的一个基本构造  </p><p>可以将Channel 看作是连接的载体。因此，它可以被打开、被关闭、连接、断开连接。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Channel连接上发生的事件。可以等价的理解为 epoll 中关于每个Socket事件，例如：EPOLLIN, EPOLLOUT, EPOLLHUP的回调    </p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>类似于常见的回调，Netty内部用回调来处理事件；  </p><p>可理解为 epoll 中关于每个Socket事件的回调，例如：EPOLLIN, EPOLLOUT, EPOLLHUP的回调。</p><p>应用程序可以自定义回调，感知Netty网络通信的事件。</p><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>Future提供了另一种在操作完成时通知应用程序的方式。</p><p>JDK中的java.util.concurrent.Future 在使用上是阻塞调用的，不优雅。Netty 提供了另一种实现：ChannelFuture，用于在执行异步操作的时候使用。  </p><p>Netty的每个出站I/O都将返回一个ChannelFuture。  </p><p>使用ChannelFuture时，可以配合使用ChannelFutureListener。只要实现operationComplete() 回调即可，非常方便。且支持多ChannelFuture。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line"><span class="comment">//Does not block </span></span><br><span class="line">ChannelFuture future = channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"192.168.0.1"</span>, <span class="number">25</span>));</span><br><span class="line">​</span><br><span class="line">future.addListener(<span class="keyword">new</span> ChannelFuturelistener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess())&#123;</span><br><span class="line">            ByteBuf buffer = Unpooled.copiedBuffer(<span class="string">"Hello"</span>, Charset.defaultCharset());</span><br><span class="line">            ChannelFuture wf = future.channel().writeAndFlush(buffer);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Throwable cause = future.cause();</span><br><span class="line">            cause.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><pre><code>可以初步理解为每个ChannelHandler实例都类似于一种为了响应特定事件而被执行的回调。</code></pre><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a><code>PS</code></h3><p>Netty 的内部实现细节跟Linux epoll的用法很相似，熟悉Linux Epoll以及编程模型的朋友来说可以对比着来学习，寻找类同点、差异点以及差异的原因。  </p><p>Netty 同时支持OIO, NIO, EPOLL等多路复用模式，我是以熟悉的epoll作为切入熟悉的内部流程原理。</p><hr><h2 id="Netty的组件和设计"><a href="#Netty的组件和设计" class="headerlink" title="Netty的组件和设计"></a>Netty的组件和设计</h2><ul><li>Channel  ———— Socket；</li><li>EventLoop ———— 控制流、多线程处理、并发；</li><li>ChannelFuture ———— 异步通知；</li></ul><h3 id="Channel-接口"><a href="#Channel-接口" class="headerlink" title="Channel 接口"></a>Channel 接口</h3><p>Netty的Channel接口所提供的API，大大地降低了使用Socket类的复杂性。</p><h3 id="EventLoopGroup-接口"><a href="#EventLoopGroup-接口" class="headerlink" title="EventLoopGroup 接口"></a>EventLoopGroup 接口</h3><p>主要作用</p><ol><li>用于注册Channel</li><li>执行部分Runnable任务</li></ol><p>这里重点讲下“注册Channel”，在实际编程或应用时，每个Channel都是向EventLoopGroup注册的，由EventLoopGroup按照指定的策略方法，将Channel注册到EventLoopGroup下某个具体的EventLoop当中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventLoopGroup</span> <span class="keyword">extends</span> <span class="title">EventExecutorGroup</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register a &#123;<span class="doctag">@link</span> Channel&#125; with this &#123;<span class="doctag">@link</span> EventLoop&#125;. The returned &#123;<span class="doctag">@link</span> ChannelFuture&#125;</span></span><br><span class="line"><span class="comment">     * will get notified once the registration was complete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">MultithreadEventExecutorGroup</span> <span class="keyword">implements</span> <span class="title">EventLoopGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next().register(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadEventExecutorGroup</span> <span class="keyword">extends</span> <span class="title">AbstractEventExecutorGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> chooser.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="EventLoop-接口"><a href="#EventLoop-接口" class="headerlink" title="EventLoop 接口"></a>EventLoop 接口</h3><p>EventLoop定义了Netty的核心抽象，用于处理连接的生命周期中所发生的事件。</p><p><img src="/2018/04/08/Netty-核心对象梳理-1/img-3.png" alt="image"></p><ul><li>一个EventLoopGroup包含一个或者多个EventLoop；</li><li>一个EventLoop在它的生命周期内只和一个Thread绑定；</li><li>所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理；</li><li>一个Channel在它的生命周期内只注册于一个EventLoop；</li><li>一个EventLoop可能会被分配给一个或多个Channel；</li></ul><p>在这种设计中，一个给定的Channel的I/O操作都是由相同的Thread执行的，实际上消除了对于同步的需要。</p><h3 id="ChannelFuture-接口"><a href="#ChannelFuture-接口" class="headerlink" title="ChannelFuture 接口"></a>ChannelFuture 接口</h3><p>Netty中所有的I/O操作都是异步的。所有我们需要一种用于在之后的某个时间点确定其结果的方法。</p><p>为此，Netty提供了ChannelFuture接口，其addListener()方法注册了一个ChannelFutureListener，以便在某个操作完成时得到通知。</p><h3 id="ChannelHandler-接口"><a href="#ChannelHandler-接口" class="headerlink" title="ChannelHandler 接口"></a>ChannelHandler 接口</h3><p>顾名思义，Channel的Handler，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler的方法是由网络事件触发的。</p><h3 id="ChannelPipeline-接口"><a href="#ChannelPipeline-接口" class="headerlink" title="ChannelPipeline 接口"></a>ChannelPipeline 接口</h3><p>ChannelPipeline为ChannelHandler链提供了容器，并定义了用于在该链上传播入站和出站事件流的API。当Channel被创建时，它会被自动的分配到它专属的ChannelPipeline。</p><ul><li>ChannelPipleline中的ChannelHandler的执行顺序是由它们被添加的顺序所决定的。</li></ul><h3 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h3><p>Netty用于网络通信，天然需要编码和解码。也是用ChannelPipeline + ChannelHandler的机制实现的。  </p><ul><li>所有由Netty提供的编码器/解码器适配器类都实现了ChannelOutboundHandler或者ChannelInboundHandler接口。</li></ul><h3 id="引导（Bootstrap）"><a href="#引导（Bootstrap）" class="headerlink" title="引导（Bootstrap）"></a>引导（Bootstrap）</h3><p>Netty的引导类为应用程序的网络层配置提供了容器。</p><table><thead><tr><th>类别</th><th>Bootstrap</th><th>ServerBootstrap</th></tr></thead><tbody><tr><td>网络编程中的作用</td><td>连接到远程主机和端口</td><td>绑定到一个本地端口</td></tr><tr><td>EventLoopGroup的数目</td><td>1</td><td>2</td></tr></tbody></table><ul><li><p>使用Netty的ChannelOption和属性</p><p>  在每个Channel创建时都手动配置它可能会变得相当乏味。幸运的是，你不必这样做。相反，你可以使用option()方法来将ChannelOption应用到Bootstrap上。你所提供的值将会被自动应用到Bootstrap所创建的所有Channel。</p></li></ul><p><strong>引导DatagramChannel</strong></p><p>Bootstrap除了引导基于TCP协议的SocketChannel，也可以用于引导无连接的协议。Netty提供了各种DatagramChannel的实现。与面向连接的TCP相比，唯一区别是不再调用connect()方法，而是只调用bind()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用Bootstrap和DatagramChannel</span></span><br><span class="line">Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">bootstap.group(<span class="keyword">new</span> OioEventLoopGroup())</span><br><span class="line">    .channel(OioDatagramChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;DatagramPacket&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, DatagramPacket msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//Do something with the packet</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">ChannelFuture future = bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>));</span><br><span class="line">future.addListener(<span class="keyword">new</span> ChannelFutureListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channelFuture.isSuccess())&#123;</span><br><span class="line">            System.out.println(<span class="string">"Channel bound"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Bind attempt failed"</span>);</span><br><span class="line">            channelFuture.cause().printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a><code>我的理解</code></h3><ol><li><p>引导的根对象是 EventLoopGroup，间接的负责监听、处理所有Channel的网络事件。</p></li><li><p>EventLoop是EventLoopGroup内的成员，每个EventLoop与具体的线程绑定。也可以理解一个线程，一个EventLoop。<br> EventLoop直接负责处理其下所有Channel的网络事件。</p></li><li><p>ChannelHadler是Channel网络事件逻辑处理的容器，应用逻辑开发的重点就在此。</p></li><li><p>当一个Channel上来一个网络事件时，对应的EventLoop首先进行响应，并找到Channel所属的ChannelPipeline，Channel作为输入驱动一次ChannelPipeline。</p></li><li><p>ChannelPipeline 遍历其下ChannelHandler，逐个处理Channel的网络事件。</p></li></ol><ul><li>ChannelFuture可以同步等结果，也可以异步通知结果，都支持，自己选！</li></ul><p><img src="/2018/04/08/Netty-核心对象梳理-1/img-2.png" alt="image"></p><hr><h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><p>网络数据的基本单位是字节。Java NIO提供了ByteBuffer作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。  </p><p>Netty的ByteBuffer替代品是ByteBuf，一个强大的实现，既解决了JDK API的局限性，又为网络应用程序的开发者提供了更好的API。</p><ul><li><p>ByteBuf优点：  </p><ol><li>对于同一个数据buffer，维护readIndex, writeIndex两份索引</li></ol></li><li><p>ByteBuf模式</p><ol><li>堆缓冲区模式：<ul><li>将数据存储在JVM的堆空间中，应用代码可直接访问缓冲区中的数据。</li></ul></li><li>直接缓冲区模式：<ul><li>JDK 1.4引入的ByteBuffer类允许JVM实现直接使用操作系统的本地内容，这就避免了JAVA 应用在每次调用本地I/O操作前/后 需要将缓冲区的内容复制到一个与操作系统结合的中间缓冲区中。</li><li>缺点：因为数据不是在堆上，所以业务代码处理时不得不经过一次复制。</li></ul></li><li>复合缓冲区：<ul><li>为多个ByteBuf提供一个统一的聚合视图，可以根据需要向复合缓冲区中添加或者删除ByteBuf实例。</li></ul></li></ol></li><li><p>字节级操作</p><p>  可以以字节的操作方式使用ByteBuf</p></li></ul><ol><li>随机访问索引</li><li>顺序访问索引</li><li>可丢弃字节</li><li>可读字节</li><li>可写字节</li><li>索引管理</li><li>indexOf / ByteBufProcessor</li><li>派生缓冲区</li><li>读/写操作</li></ol><ul><li><p>ByteBuf池化分配</p><p>  为了降低分配和释放内存的开销，Netty通过interface ByteBufAllocator实现了ByteBuf的池化。</p></li><li><p>Unpooled 缓冲区</p><p>  如果未能获取到一个ByteBufAllocator的引用，Netty提供一个简单的Unpooled工具类，它提供创建未池化的ByteBuf实例。</p></li></ul><hr><h2 id="关于-ChannelFuture-和-ChannelPromise"><a href="#关于-ChannelFuture-和-ChannelPromise" class="headerlink" title="关于 ChannelFuture 和 ChannelPromise"></a>关于 ChannelFuture 和 ChannelPromise</h2><ul><li><p>ChannelFuture</p><ul><li>read-only</li><li>没有返回值的异步通知、调用</li><li>DefaultFutureListeners -&gt; listeners[N]</li></ul></li><li><p>ChannelPromise</p><ul><li>writeable</li><li>可写异步执行结果的通知、调用</li><li>notifyListenerNow -&gt; 回到Listeners -&gt; 取出对应的Channel进行回调操作</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Netty In Action》阅读笔记摘要&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/04/08/Netty-核心对象梳理-1/img-1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Netty" scheme="https://veryjj.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>浅聊分布式事务</title>
    <link href="https://veryjj.github.io/2018/03/30/%E6%B5%85%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>https://veryjj.github.io/2018/03/30/浅聊分布式事务/</id>
    <published>2018-03-30T06:37:05.000Z</published>
    <updated>2018-03-30T07:16:12.000Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>前言</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>最近很久没有写博客了，一方面是因为公司事情最近比较忙，另外一方面是因为在进行 CAP 的下一阶段的开发工作，不过目前已经告一段落了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>接下来还是开始我们今天的话题，说说分布式事务，或者说是我眼中的分布式事务，因为每个人可能对其的理解都不一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免，本文就分布式事务来简单聊一下。</p><a id="more"></a><hr><blockquote><p>数据库事务</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>在说分布式事务之前，我们先从数据库事务说起。 数据库事务可能大家都很熟悉，在开发过程中也会经常使用到。但是即使如此，可能对于一些细节问题，很多人仍然不清楚。比如很多人都知道数据库事务的几个特性：原子性(Atomicity )、一致性( Consistency )、隔离性或独立性( Isolation)和持久性(Durabilily)，简称就是ACID。但是再往下比如问到隔离性指的是什么的时候可能就不知道了，或者是知道隔离性是什么但是再问到数据库实现隔离的都有哪些级别，或者是每个级别他们有什么区别的时候可能就不知道了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>本文并不打算介绍这些数据库事务的这些东西，有兴趣可以搜索一下相关资料。不过有一个知识点我们需要了解，就是假如数据库在提交事务的时候突然断电，那么它是怎么样恢复的呢？ 为什么要提到这个知识点呢？ 因为分布式系统的核心就是处理各种异常情况，这也是分布式系统复杂的地方，因为分布式的网络环境很复杂，这种“断电”故障要比单机多很多，所以我们在做分布式系统的时候，最先考虑的就是这种情况。这些异常可能有 机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的TCP、存储数据丢失、其他异常等等…</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>我们接着说本地事务数据库断电的这种情况，它是怎么保证数据一致性的呢？我们使用SQL Server来举例，我们知道我们在使用 SQL Server 数据库是由两个文件组成的，一个数据库文件和一个日志文件，通常情况下，日志文件都要比数据库文件大很多。数据库进行任何写入操作的时候都是要先写日志的，同样的道理，我们在执行事务的时候数据库首先会记录下这个事务的redo操作日志，然后才开始真正操作数据库，在操作之前首先会把日志文件写入磁盘，那么当突然断电的时候，即使操作没有完成，在重新启动数据库时候，数据库会根据当前数据的情况进行undo回滚或者是redo前滚，这样就保证了数据的强一致性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>接着，我们就说一下分布式事务。</p><hr><blockquote><p>分布式理论</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>当我们的单个数据库的性能产生瓶颈的时候，我们可能会对数据库进行分区，这里所说的分区指的是物理分区，分区之后可能不同的库就处于不同的服务器上了，这个时候单个数据库的ACID已经不能适应这种情况了，而在这种ACID的集群环境下，再想保证集群的ACID几乎是很难达到，或者即使能达到那么效率和性能会大幅下降，最为关键的是再很难扩展新的分区了，这个时候如果再追求集群的ACID会导致我们的系统变得很差，这时我们就需要引入一个新的理论原则来适应这种集群的情况，就是 CAP 原则或者叫CAP定理，那么CAP定理指的是什么呢？</p><h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足一下3个属性：</p><ul><li>一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效)</li><li>可用性(Availability) ： 每个操作都必须以可预期的响应结束</li><li>分区容错性(Partition tolerance) ： 即使出现单个组件无法可用,操作依然可以完成</li></ul><p>具体地讲在分布式系统中，在任何数据库设计中，一个Web应用至多只能同时支持上面的两个属性。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在一致性与可用性之间做出选择。</p><p><strong>这个定理在迄今为止的分布式系统中都是适用的！ </strong>为什么这么说呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>这个时候有同学可能会把数据库的2PC（两阶段提交）搬出来说话了。OK，我们就来看一下数据库的两阶段提交。</p><p>对数据库分布式事务有了解的同学一定知道数据库支持的2PC，又叫做 XA Transactions。</p><pre><code>MySQL从5.5版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段：</p><ul><li>第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.</li><li>第二阶段：事务协调器要求每个数据库提交数据。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。这样做的缺陷是什么呢? 咋看之下我们可以在数据库分区之间获得一致性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>如果CAP 定理是对的，那么它一定会影响到可用性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>如果说系统的可用性代表的是执行某项操作相关所有组件的可用性的和。那么在两阶段提交的过程中，可用性就代表了涉及到的每一个数据库中可用性的和。我们假设两阶段提交的过程中每一个数据库都具有99.9%的可用性，那么如果两阶段提交涉及到两个数据库，这个结果就是99.8%。根据系统可用性计算公式，假设每个月43200分钟，99.9%的可用性就是43157分钟, 99.8%的可用性就是43114分钟，相当于每个月的宕机时间增加了43分钟。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>以上，可以验证出来，CAP定理从理论上来讲是正确的，CAP我们先看到这里，等会再接着说。</p><h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>在分布式系统中，我们往往追求的是可用性，它的重要程序比一致性要高，那么如何实现高可用性呢？ 前人已经给我们提出来了另外一个理论，就是BASE理论，它是用来对CAP定理进行进一步扩充的。BASE理论指的是：</p><ul><li>Basically Available（基本可用）</li><li>Soft state（软状态）</li><li>Eventually consistent（最终一致性）</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：<strong>我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>有了以上理论之后，我们来看一下分布式事务的问题。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>在分布式系统中，要实现分布式事务，无外乎那几种解决方案。</p><h4 id="一、两阶段提交（2PC）"><a href="#一、两阶段提交（2PC）" class="headerlink" title="一、两阶段提交（2PC）"></a>一、两阶段提交（2PC）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>和上一节中提到的数据库XA事务一样，两阶段提交就是使用XA协议的原理，我们可以从下面这个图的流程来很容易的看出中间的一些比如commit和abort的细节。</p><p><img src="/2018/03/30/浅聊分布式事务/img-1.png" alt="image"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>两阶段提交这种解决方案属于牺牲了一部分可用性来换取的一致性。在实现方面，在 .NET 中，可以借助 TransactionScop 提供的 API 来编程实现分布式系统中的两阶段提交，比如WCF中就有实现这部分功能。不过在多服务器之间，需要依赖于DTC来完成事务一致性，Windows下微软搞的有MSDTC服务，Linux下就比较悲剧了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>另外说一句，TransactionScop 默认不能用于异步方法之间事务一致，因为事务上下文是存储于当前线程中的，所以如果是在异步方法，需要显式的传递事务上下文。</p><ul><li><strong>优点：</strong> 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）  </li><li><strong>缺点：</strong> 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景，如果分布式系统跨接口调用，目前 .NET 界还没有实现方案。</li></ul><h4 id="二、补偿事务（TCC）"><a href="#二、补偿事务（TCC）" class="headerlink" title="二、补偿事务（TCC）"></a>二、补偿事务（TCC）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><ol><li><p>Try 阶段主要是对业务系统做检测及资源预留</p></li><li><p>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</p></li><li><p>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</p></li></ol><p>举个例子，假入 Bob 要向 Smith 转账，思路大概是：<br>我们有一个本地方法，里面依次调用<br>1、首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。<br>2、在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。<br>3、如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。  </p><ul><li><strong>优点：</strong> 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些</li><li><strong>缺点：</strong> 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。</li></ul><h4 id="三、本地消息表（异步确保）"><a href="#三、本地消息表（异步确保）" class="headerlink" title="三、本地消息表（异步确保）"></a>三、本地消息表（异步确保）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理，这种思路是来源于ebay。我们可以从下面的流程图中看出其中的一些细节：</p><p><img src="/2018/03/30/浅聊分布式事务/img-2.png" alt="image"></p><p><strong>基本思路就是：</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>这种方案遵循BASE理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的，即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。</p><ul><li><strong>优点：</strong> 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。</li><li><strong>缺点：</strong> 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</li></ul><h4 id="四、MQ-事务消息"><a href="#四、MQ-事务消息" class="headerlink" title="四、MQ 事务消息"></a>四、MQ 事务消息</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p><p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p><ul><li>第一阶段Prepared消息，会拿到消息的地址。</li><li>第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。</li></ul><p>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p><p><img src="/2018/03/30/浅聊分布式事务/img-3.png" alt="image"></p><ul><li><strong>优点：</strong> 实现了最终一致性，不需要依赖本地数据库事务。</li><li><strong>缺点：</strong> 实现难度大，主流MQ不支持，没有.NET客户端，RocketMQ事务消息部分代码也未开源。</li></ul><h4 id="五、Sagas-事务模型"><a href="#五、Sagas-事务模型" class="headerlink" title="五、Sagas 事务模型"></a>五、Sagas 事务模型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>Saga事务模型又叫做长时间运行的事务（Long-running-transaction）, 它是由普林斯顿大学的H.Garcia-Molina等人提出，它描述的是另外一种在没有两阶段提交的的情况下解决分布式系统中复杂的业务事务问题。你可以在这里看到 Sagas 相关论文。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>我们这里说的是一种基于 Sagas 机制的工作流事务模型，这个模型的相关理论目前来说还是比较新的，以至于百度上几乎没有什么相关资料。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Sagas 工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Sagas工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>比如我们一次关于购买旅游套餐业务操作涉及到三个操作，他们分别是预定车辆，预定宾馆，预定机票，他们分别属于三个不同的远程接口。可能从我们程序的角度来说他们不属于一个事务，但是从业务角度来说是属于同一个事务的。</p><p><img src="/2018/03/30/浅聊分布式事务/img-4.png" alt="image"></p><p>他们的执行顺序如上图所示，所以当发生失败时，会依次进行取消的补偿操作。</p><p>因为长事务被拆分了很多个业务流，所以 Sagas 事务模型最重要的一个部件就是工作流或者你也可以叫流程管理器（Process Manager），工作流引擎和Process Manager虽然不是同一个东西，但是在这里，他们的职责是相同的。在选择工作流引擎之后，最终的代码也许看起来是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SagaBuilder saga = SagaBuilder.newSaga(&quot;trip&quot;)</span><br><span class="line">        .activity(&quot;Reserve car&quot;, ReserveCarAdapter.class) </span><br><span class="line">        .compensationActivity(&quot;Cancel car&quot;, CancelCarAdapter.class) </span><br><span class="line">        .activity(&quot;Book hotel&quot;, BookHotelAdapter.class) </span><br><span class="line">        .compensationActivity(&quot;Cancel hotel&quot;, CancelHotelAdapter.class) </span><br><span class="line">        .activity(&quot;Book flight&quot;, BookFlightAdapter.class) </span><br><span class="line">        .compensationActivity(&quot;Cancel flight&quot;, CancelFlightAdapter.class) </span><br><span class="line">        .end()</span><br><span class="line">        .triggerCompensationOnAnyError();</span><br><span class="line"></span><br><span class="line">camunda.getRepositoryService().createDeployment() </span><br><span class="line">        .addModelInstance(saga.getModel()) </span><br><span class="line">        .deploy();</span><br></pre></td></tr></table></figure><p>这里有一个 C# 相关示例，有兴趣的同学可以看一下。</p><ul><li><strong>优缺点</strong> 这里我们就不说了，因为这个理论比较新，目前市面上还没有什么解决方案，即使是 Java 领域，我也没有搜索的太多有用的信息。</li></ul><hr><p>转自：<a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;前言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;最近很久没有写博客了，一方面是因为公司事情最近比较忙，另外一方面是因为在进行 CAP 的下一阶段的开发工作，不过目前已经告一段落了。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;接下来还是开始我们今天的话题，说说分布式事务，或者说是我眼中的分布式事务，因为每个人可能对其的理解都不一样。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免，本文就分布式事务来简单聊一下。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式事务" scheme="https://veryjj.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>认识鱼骨图</title>
    <link href="https://veryjj.github.io/2018/03/29/%E8%AE%A4%E8%AF%86%E9%B1%BC%E9%AA%A8%E5%9B%BE/"/>
    <id>https://veryjj.github.io/2018/03/29/认识鱼骨图/</id>
    <published>2018-03-29T11:41:23.000Z</published>
    <updated>2018-03-29T13:10:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/03/29/认识鱼骨图/img-2.png" alt="image"></p><a id="more"></a><p>今天，偶然的机会在同事电脑上漂见“鱼骨图”。晚上吃完饭就在思考这个问题：“为什么我从来没用过鱼骨图分析问题？鱼骨图适用于什么类型的分析？”</p><p>查了些资料追求普及，介绍的内容大同小异</p><h3 id="概念摘要"><a href="#概念摘要" class="headerlink" title="概念摘要"></a>概念摘要</h3><p>鱼骨分析法，又名 因果分析法，是一种发现问题”根本原因”的分析方法。</p><p>鱼骨图可以进一步被划分为：</p><ol><li><p>整理问题型鱼骨图（各要素与特性值间不存在原因关系，而是结构构成关系）</p></li><li><p>原因型鱼骨图（鱼头在右，特性值通常以“为什么……”来写）</p></li><li><p>对策型鱼骨图（鱼头在左，特性值通常以“如何提高/改善……”来写）</p></li></ol><h3 id="怎么作图"><a href="#怎么作图" class="headerlink" title="怎么作图"></a>怎么作图</h3><h4 id="分析结构"><a href="#分析结构" class="headerlink" title="分析结构"></a>分析结构</h4><ul><li><p>A、针对问题点，选择层别方法（如人机料法环等）；  </p></li><li><p>B、按头脑风暴分别对各层别类别找出所有可能原因（因素）；</p></li><li><p>C、将找出的各要素进行归类、整理，明确其从属关系；</p></li><li><p>D、分析选取重要因素；</p></li><li><p>E、检查各要素的描述方法，确保语法简明、意思明确;</p></li></ul><h4 id="分析要点"><a href="#分析要点" class="headerlink" title="分析要点"></a>分析要点</h4><ul><li><p>A、确定大要因（大骨）时，现场作业一般从“人机料法环”着手,管理类问题一般从“人事时地物”层别，应视具体情况决定；  </p></li><li><p>B、大要因必须用中性词描述（不说明好坏），中、小要因必须使用价值判断（如…不良）；</p></li><li><p>C、头脑风暴时，应尽可能多而全地找出所有可能原因，而不仅限于自己能完全掌控或正在执行的内容。对人的原因，宜从行动而非思想态度面着手分析；</p></li><li><p>D、中要因跟特性值、小要因跟中要因间有直接的原因-问题关系，小要因应分析至可以直接下对策；</p></li><li><p>E、如果某种原因可同时归属于两种或两种以上因素，请以关联性最强者为准（必要时考虑三现主义：即现时到现场看现物，通过相对条件的比较，找出相关性最强的要因归类。）；</p></li><li><p>F、选取重要原因时，不要超过7项，且应标识在最未端原因。</p></li></ul><h4 id="绘图过程"><a href="#绘图过程" class="headerlink" title="绘图过程"></a>绘图过程</h4><ul><li><p>A、填写鱼头（按为什么不好的方式描述），画出主骨；  </p></li><li><p>B、画出大骨，填写大要因；</p></li><li><p>C、画出中骨、小骨，填写中小要因；</p></li><li><p>D、用特殊符号标识重要因素；</p></li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>(1) 查找要解决的问题；  </p><p>(2) 把问题写在鱼骨的头上；  </p><p>(3) 召集同事共同讨论问题出现的可能原因，尽可能多地找出问题；  </p><p>(4) 把相同的问题分组，在鱼骨上标出；  </p><p>(5) 根据不同问题征求大家的意见，总结出正确的原因；  </p><p>(6) 拿出任何一个问题，研究为什么会产生这样的问题；  </p><p>(7) 针对问题的答案再问为什么？这样至少深入五个层次（连续问五个问题）；  </p><p>(8) 当深入到第五个层次后，认为无法继续进行时，列出这些问题的原因，而后列出至少20个解决方法。   </p><hr><blockquote><p>看了鱼骨图的概念介绍后，在脑海中立马出现了新的问题：”鱼骨图和思维导图有什么区别？”</p></blockquote><h3 id="鱼骨图和思维导图有什么区别？"><a href="#鱼骨图和思维导图有什么区别？" class="headerlink" title="鱼骨图和思维导图有什么区别？"></a>鱼骨图和思维导图有什么区别？</h3><h4 id="类同点"><a href="#类同点" class="headerlink" title="类同点"></a>类同点</h4><ol><li>都是基于主题逐步分解、细化的过程</li><li>都是类树形结构</li></ol><h4 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h4><h5 id="理解-1"><a href="#理解-1" class="headerlink" title="理解-1"></a>理解-1</h5><p>首先、思维导图和鱼骨图都是图形思维，而图形思维最大的特点就是<code>将我们的思维结构化，并由此实现图形化</code>。  </p><p>而所谓的结构化一般就是构建逻辑思维，任何的逻辑思维都是基于这两个出发点而来的：1、分类；2、顺序；所以只要你的分类与顺序是一样的，那么你的逻辑思维是一样的，由此产生的图形思维也是一样的。而图形、分列、表格……只是图形思维具体的呈现方式。换句话说，在图形思维一样的前提下，不同的人选择了自己认为好的呈现方式让图形思维更可视化、更清晰化、更感性化。  </p><p>另外，还有不同之处在于思维导图不仅仅能用于构建逻辑思维，还能<code>扩展发散思维</code>，以及还能强化思维记忆。这是和鱼骨图的区别之一！</p><h5 id="理解-2"><a href="#理解-2" class="headerlink" title="理解-2"></a>理解-2</h5><ul><li><p>【思维导图】在实际应用中，思维导图<code>常用于个人</code>，<code>侧重于个人思维的发散，以求思维的全面性</code>，思维导图的层次感是逻辑思维自然的产出。<code>应用场景广泛</code>。</p></li><li><p>【鱼骨图】常用在多人同时参与的<code>头脑风暴场景</code>，侧重于发挥团队智力<code>逐层解剖问题，找到问题原因</code>。往往会以”问题原因分析 + 跟进Action”作为结果产出。</p></li></ul><h3 id="鱼骨图作图工具"><a href="#鱼骨图作图工具" class="headerlink" title="鱼骨图作图工具"></a>鱼骨图作图工具</h3><ul><li>Xmind<br><img src="/2018/03/29/认识鱼骨图/img-3.png" alt="image">  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/03/29/认识鱼骨图/img-2.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://veryjj.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="分析图" scheme="https://veryjj.github.io/tags/%E5%88%86%E6%9E%90%E5%9B%BE/"/>
    
  </entry>
  
</feed>
