<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄老师</title>
  
  <subtitle>Life Note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://veryjj.github.io/"/>
  <updated>2021-01-10T08:10:05.000Z</updated>
  <id>https://veryjj.github.io/</id>
  
  <author>
    <name>黄老师</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://veryjj.github.io/2021/01/10/%E8%A7%A3%E5%86%B3homebrew%E9%95%BF%E6%97%B6%E9%97%B4%E5%81%9C%E5%9C%A8Updating%20Homebrew%20%E8%BF%99%E4%B8%AA%E6%AD%A5%E9%AA%A4/"/>
    <id>https://veryjj.github.io/2021/01/10/解决homebrew长时间停在Updating Homebrew 这个步骤/</id>
    <published>2021-01-10T08:10:05.000Z</published>
    <updated>2021-01-10T08:10:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在国内的网络环境下使用 Homebrew 安装软件的过程中可能会长时间卡在 Updating Homebrew 这个步骤。</p><p>例：执行 brew install composer 命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ brew install composer</span><br><span class="line">Updating Homebrew... # 如果碰到长时间卡在这里，参考以下 2 种处理方法</span><br></pre></td></tr></table></figure></p><p> <br></p><h2 id="方法-1：按住-control-c-取消本次更新操作"><a href="#方法-1：按住-control-c-取消本次更新操作" class="headerlink" title="方法 1：按住 control + c 取消本次更新操作"></a>方法 1：按住 control + c 取消本次更新操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ brew install composer</span><br><span class="line">Updating Homebrew...</span><br><span class="line">^C</span><br><span class="line">按住 control + c 之后命令行会显示 ^C，就代表已经取消了 Updating Homebrew 操作</span><br><span class="line"></span><br><span class="line">大概不到 1 秒钟之后就会去执行我们真正需要的安装操作了</span><br><span class="line"></span><br><span class="line">➜  ~ brew install composer</span><br><span class="line">Updating Homebrew...</span><br><span class="line">^C==&gt; Satisfying dependencies</span><br><span class="line">==&gt; Downloading https://getcomposer.org/download/1.7.2/composer.phar</span><br><span class="line">...</span><br><span class="line">这个方法是临时的、一次性的</span><br></pre></td></tr></table></figure><p> <br></p><h2 id="【推荐】方法-2：使用-Alibaba-的-Homebrew-镜像源进行加速"><a href="#【推荐】方法-2：使用-Alibaba-的-Homebrew-镜像源进行加速" class="headerlink" title="【推荐】方法 2：使用 Alibaba 的 Homebrew 镜像源进行加速"></a>【推荐】方法 2：使用 Alibaba 的 Homebrew 镜像源进行加速</h2><p>平时我们执行 brew 命令安装软件的时候，跟以下 3 个仓库地址有关：</p><ul><li><p>brew.git</p></li><li><p>homebrew-core.git</p></li><li><p>homebrew-bottles</p></li></ul><p>通过以下操作将这 3 个仓库地址全部替换为 Alibaba 提供的地址<br><br></p><h3 id="1-替换-还原-brew-git-仓库地址"><a href="#1-替换-还原-brew-git-仓库地址" class="headerlink" title="1. 替换 / 还原 brew.git 仓库地址"></a>1. 替换 / 还原 brew.git 仓库地址</h3><ul><li>替换成阿里巴巴的 brew.git 仓库地址:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd "$(brew --repo)"</span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>还原为官方提供的 brew.git 仓库地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd "$(brew --repo)"</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/brew.git</span><br></pre></td></tr></table></figure><p> <br></p><h3 id="2-替换-还原-homebrew-core-git-仓库地址"><a href="#2-替换-还原-homebrew-core-git-仓库地址" class="headerlink" title="2. 替换 / 还原 homebrew-core.git 仓库地址"></a>2. 替换 / 还原 homebrew-core.git 仓库地址</h3><ul><li>替换成阿里巴巴的 homebrew-core.git 仓库地址:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"</span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure><p><br></p><ul><li>还原为官方提供的 homebrew-core.git 仓库地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-替换-还原-homebrew-bottles-访问地址"><a href="#3-替换-还原-homebrew-bottles-访问地址" class="headerlink" title="3. 替换 / 还原 homebrew-bottles 访问地址"></a>3. 替换 / 还原 homebrew-bottles 访问地址</h3><p>这个步骤跟你的 macOS 系统使用的 shell 版本有关系</p><p>所以，先来查看当前使用的 shell 版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure></p><ul><li>如果你的输出结果是 /bin/zsh，参考3.1的 zsh 终端操作方式</li><li>如果你的输出结果是 /bin/bash，参考3.2的 bash 终端操作方式</li></ul><h4 id="3-1-zsh-终端操作方式"><a href="#3-1-zsh-终端操作方式" class="headerlink" title="3.1 zsh 终端操作方式"></a>3.1 zsh 终端操作方式</h4><ul><li>替换成阿里巴巴的 homebrew-bottles 访问地址:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p><br></p><ul><li>还原为官方提供的 homebrew-bottles 访问地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br><span class="line">然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-2-bash-终端操作方式"><a href="#3-2-bash-终端操作方式" class="headerlink" title="3.2 bash 终端操作方式"></a>3.2 bash 终端操作方式</h4><ul><li>替换 homebrew-bottles 访问 URL:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p><br></p><ul><li>还原为官方提供的 homebrew-bottles 访问地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line">然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在国内的网络环境下使用 Homebrew 安装软件的过程中可能会长时间卡在 Updating Homebrew 这个步骤。&lt;/p&gt;
&lt;p&gt;例：执行 brew install composer 命令&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;ta
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 生成随机数的 5 种方式</title>
    <link href="https://veryjj.github.io/2020/12/16/Java%20%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%205%20%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://veryjj.github.io/2020/12/16/Java 生成随机数的 5 种方式/</id>
    <published>2020-12-16T07:11:39.000Z</published>
    <updated>2021-01-10T09:08:45.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h1><blockquote><p>试测数据：</p><ul><li>基于常见场景：在一个数据范围区间内生成随机数。</li><li>1000万的随机数范围，for循环生成50万个随机数。无其他额外操作。</li></ul></blockquote><table><thead><tr><th>SDK包</th><th>性能耗时</th><th style="text-align:left">评价</th></tr></thead><tbody><tr><td>java.util.Random</td><td>9毫秒</td><td style="text-align:left">1、编写简单，方法较多，也快速。很多SDK包都基于此扩展。<br>2、随机性重度依赖seed的情况，seed一样，分配的随机数和顺序一样。<br>3、线程不安全。</td></tr><tr><td>ThreadLocalRandom</td><td>8毫秒</td><td style="text-align:left">1、继承于java.util.Random<br>2、与线程绑定，一个线程一个，多线程下安全。<br>3、seed情况部分借助于线程的内存地址等随机信息，来提升随机性。</td></tr><tr><td>Math.Random</td><td>14毫秒</td><td style="text-align:left">1、用法上比较费劲，只能生成double。<br>2、内部有借用java.util.Random</td></tr><tr><td>SecureRandom</td><td>142毫秒</td><td style="text-align:left">线程安全，seed不可预测（借助于系统中的随机事件信息）</td></tr><tr><td>Apache#RandomDataGenerator</td><td>54毫秒</td><td style="text-align:left">API比较丰富，特殊场景下考虑。</td></tr><tr><td>it.unimi.dsi#XoRoShiRo128PlusRandom</td><td>17毫秒</td><td style="text-align:left">偏门的三方包。比较快。线程不安全。</td></tr></tbody></table><a id="more"></a><hr><h1 id="1-Math-random-静态方法"><a href="#1-Math-random-静态方法" class="headerlink" title="1. Math.random() 静态方法"></a>1. Math.random() 静态方法</h1><p>产生的随机数是 0 - 1 之间的一个 <code>double</code>，即 <code>0 &lt;= random &lt;= 1</code>。</p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  System.out.println(Math.random());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0.3598613895606426 </span><br><span class="line">0.2666778145365811 </span><br><span class="line">0.25090731064243355 </span><br><span class="line">0.011064998061666276 </span><br><span class="line">0.600686228175639 </span><br><span class="line">0.9084006027629496 </span><br><span class="line">0.12700524654847833 </span><br><span class="line">0.6084605849069343 </span><br><span class="line">0.7290804782514261 </span><br><span class="line">0.9923831908303121</span><br></pre></td></tr></table></figure></p><p>实现原理：</p><blockquote><p>When this method is first called, it creates a single new pseudorandom-number generator, exactly as if by the expression new java.util.Random() This new pseudorandom-number generator is used thereafter for all calls to this method and is used nowhere else.</p></blockquote><p>当第一次调用 Math.random() 方法时，自动创建了一个伪随机数生成器，<code>实际上用的是 new java.util.Random()</code>。当接下来继续调用 Math.random() 方法时，就会使用这个新的伪随机数生成器。</p><p>源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random rnd = randomNumberGenerator;</span><br><span class="line">    <span class="keyword">if</span> (rnd == <span class="keyword">null</span>) rnd = initRNG(); <span class="comment">// 第一次调用，创建一个伪随机数生成器</span></span><br><span class="line">    <span class="keyword">return</span> rnd.nextDouble();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Random <span class="title">initRNG</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random rnd = randomNumberGenerator;</span><br><span class="line">    <span class="keyword">return</span> (rnd == <span class="keyword">null</span>) ? (randomNumberGenerator = <span class="keyword">new</span> Random()) : rnd; <span class="comment">// 实际上用的是new java.util.Random()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>initRNG() 方法是 synchronized 的，因此在多线程情况下，只有一个线程会负责创建伪随机数生成器（使用当前时间作为种子），其他线程则利用该伪随机数生成器产生随机数。Java生成随机数的几种高级用法，这篇推荐看一下。</p><p>因此 <code>Math.random() 方法是线程安全的</code>。<br><br><br><strong>什么情况下随机数的生成线程不安全？</strong></p><ul><li>线程1在第一次调用 random() 时产生一个生成器 generator1，使用当前时间作为种子。</li><li>线程2在第一次调用 random() 时产生一个生成器 generator2，使用当前时间作为种子。</li><li>碰巧 generator1 和 generator2 使用相同的种子，导致 generator1 以后产生的随机数每次都和 generator2 以后产生的随机数相同。</li></ul><p><strong>什么情况下随机数的生成线程安全？</strong>： Math.random() 静态方法使用</p><ul><li>线程1在第一次调用 random() 时产生一个生成器 generator1，使用当前时间作为种子。</li><li>线程2在第一次调用 random() 时发现已经有一个生成器 generator1，则直接使用生成器 generator1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaRandom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + Math.random());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-1: 0.8043581595645333 </span><br><span class="line">Thread-0: 0.9338269554390357 </span><br><span class="line">Thread-1: 0.5571569413128877 </span><br><span class="line">Thread-0: 0.37484586843392464</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="2-java-util-Random-工具类"><a href="#2-java-util-Random-工具类" class="headerlink" title="2. java.util.Random 工具类"></a>2. java.util.Random 工具类</h1><blockquote><p>基本算法：linear congruential pseudorandom number generator (LGC) 线性同余法伪随机数生成器缺点：<code>可预测</code></p></blockquote><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(random.nextInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-24520987</span><br><span class="line">-96094681</span><br><span class="line">-952622427</span><br><span class="line">300260419</span><br><span class="line">1489256498</span><br></pre></td></tr></table></figure></p><p><strong>Random类默认使用<code>当前系统时钟作为种子</code></strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getClass() == Random.class)</span><br><span class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong(initialScramble(seed));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// subclass might have overriden setSeed</span></span><br><span class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">        setSeed(seed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Random类提供的方法：API</p><ul><li><code>nextBoolean()</code> - 返回均匀分布的 true 或者 false</li><li><code>nextBytes(byte[] bytes)</code></li><li><code>nextDouble()</code> - 返回 0.0 到 1.0 之间的均匀分布的 double</li><li><code>nextFloat()</code> - 返回 0.0 到 1.0 之间的均匀分布的 float</li><li><code>nextGaussian()</code> - 返回 0.0 到 1.0 之间的高斯分布（即正态分布）的 double</li><li><code>nextInt()</code> - 返回均匀分布的 int</li><li><code>nextInt(int n)</code> - 返回 0 到 n 之间的均匀分布的 int （包括 0，不包括 n）</li><li><code>nextLong()</code> - 返回均匀分布的 long</li><li><code>setSeed(long seed)</code> - 设置种子</li></ul><p><code>只要种子一样，产生的随机数也一样</code>： 因为种子确定，随机数算法也确定，因此输出是确定的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Random random1 = <span class="keyword">new</span> Random(<span class="number">10000</span>);</span><br><span class="line">Random random2 = <span class="keyword">new</span> Random(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(random1.nextInt() + <span class="string">" = "</span> + random2.nextInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-498702880 = -498702880</span><br><span class="line">-858606152 = -858606152</span><br><span class="line">1942818232 = 1942818232</span><br><span class="line">-1044940345 = -1044940345</span><br><span class="line">1588429001 = 1588429001</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="3-java-util-concurrent-ThreadLocalRandom-工具类"><a href="#3-java-util-concurrent-ThreadLocalRandom-工具类" class="headerlink" title="3. java.util.concurrent.ThreadLocalRandom 工具类"></a>3. java.util.concurrent.ThreadLocalRandom 工具类</h1><p><code>ThreadLocalRandom</code> 是 JDK 7 之后提供，也是继承至 java.util.Random。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalRandom&gt; localRandom =</span><br><span class="line">    <span class="keyword">new</span> ThreadLocal&lt;ThreadLocalRandom&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> ThreadLocalRandom <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalRandom();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>每一个线程有一个独立的随机数生成器</strong>，用于并发产生随机数，能够解决多个线程发生的竞争争夺。<strong>效率更高</strong>！</p><p>ThreadLocalRandom 不是直接用 new 实例化，而是第一次使用其静态方法 current() 得到 ThreadLocal<threadlocalrandom> 实例，然后调用 java.util.Random 类提供的方法获得各种随机数。</threadlocalrandom></p><p>使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaRandom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + ThreadLocalRandom.current().nextDouble());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-0: 0.13267085355389086</span><br><span class="line">Thread-1: 0.1138484950410098 </span><br><span class="line">Thread-0: 0.17187774671469858 </span><br><span class="line">Thread-1: 0.9305225910262372</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="4-java-Security-SecureRandom"><a href="#4-java-Security-SecureRandom" class="headerlink" title="4. java.Security.SecureRandom"></a>4. java.Security.SecureRandom</h1><p>也是继承至 java.util.Random。<br><br></p><blockquote><p>Instances of java.util.Random are not cryptographically secure. Consider instead using SecureRandom to get a cryptographically secure pseudo-random number generator for use by security-sensitive applications.SecureRandom takes Random Data from your os (they can be interval between keystrokes etc - most os collect these data store them in files - /dev/random and /dev/urandom in case of linux/solaris) and uses that as the seed. <code>操作系统收集了一些随机事件，比如鼠标点击，键盘点击等等，SecureRandom 使用这些随机事件作为种子。</code></p></blockquote><p>SecureRandom 提供加密的强随机数生成器 (RNG)，要求种子必须是不可预知的，产生非确定性输出。SecureRandom 也提供了与实现无关的算法，因此，调用方（应用程序代码）会请求特定的 RNG 算法并将它传回到该算法的 SecureRandom 对象中。</p><ul><li>如果仅指定算法名称，如下所示：SecureRandom random = SecureRandom.getInstance(“SHA1PRNG”);</li><li>如果既指定了算法名称又指定了包提供程序，如下所示：SecureRandom random = SecureRandom.getInstance(“SHA1PRNG”, “SUN”);</li></ul><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom random1 = SecureRandom.getInstance(<span class="string">"SHA1PRNG"</span>);</span><br><span class="line">SecureRandom random2 = SecureRandom.getInstance(<span class="string">"SHA1PRNG"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(random1.nextInt() + <span class="string">" != "</span> + random2.nextInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">704046703 != 2117229935 </span><br><span class="line">60819811 != 107252259 </span><br><span class="line">425075610 != -295395347 </span><br><span class="line">682299589 != -1637998900 </span><br><span class="line">-1147654329 != 1418666937</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="5-随机字符串"><a href="#5-随机字符串" class="headerlink" title="5. 随机字符串"></a>5. 随机字符串</h1><p>可以使用 Apache Commons-Lang 包中的 RandomStringUtils 类。Maven 依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>API 参考：<a href="https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/RandomStringUtils.html" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/RandomStringUtils.html</a></p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomStringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Creates a 64 chars length random string of number.</span></span><br><span class="line">        String result = RandomStringUtils.random(<span class="number">64</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">"random = "</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates a 64 chars length of random alphabetic string.</span></span><br><span class="line">        result = RandomStringUtils.randomAlphabetic(<span class="number">64</span>);</span><br><span class="line">        System.out.println(<span class="string">"random = "</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates a 32 chars length of random ascii string.</span></span><br><span class="line">        result = RandomStringUtils.randomAscii(<span class="number">32</span>);</span><br><span class="line">        System.out.println(<span class="string">"random = "</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates a 32 chars length of string from the defined array of</span></span><br><span class="line">        <span class="comment">// characters including numeric and alphabetic characters.</span></span><br><span class="line">        result = RandomStringUtils.random(<span class="number">32</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="string">"qw32rfHIJk9iQ8Ud7h0X"</span>.toCharArray());</span><br><span class="line">        System.out.println(<span class="string">"random = "</span> + result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RandomStringUtils 类的实现上也是依赖了 java.util.Random 工具类：<br><img src="https://img-blog.csdnimg.cn/20201216151043714.png" alt="在这里插入图片描述"></p><p>RandomStringUtils 类的定义</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;先说结论&quot;&gt;&lt;a href=&quot;#先说结论&quot; class=&quot;headerlink&quot; title=&quot;先说结论&quot;&gt;&lt;/a&gt;先说结论&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;试测数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于常见场景：在一个数据范围区间内生成随机数。&lt;/li&gt;
&lt;li&gt;1000万的随机数范围，for循环生成50万个随机数。无其他额外操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SDK包&lt;/th&gt;
&lt;th&gt;性能耗时&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;评价&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;java.util.Random&lt;/td&gt;
&lt;td&gt;9毫秒&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;1、编写简单，方法较多，也快速。很多SDK包都基于此扩展。&lt;br&gt;2、随机性重度依赖seed的情况，seed一样，分配的随机数和顺序一样。&lt;br&gt;3、线程不安全。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ThreadLocalRandom&lt;/td&gt;
&lt;td&gt;8毫秒&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;1、继承于java.util.Random&lt;br&gt;2、与线程绑定，一个线程一个，多线程下安全。&lt;br&gt;3、seed情况部分借助于线程的内存地址等随机信息，来提升随机性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.Random&lt;/td&gt;
&lt;td&gt;14毫秒&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;1、用法上比较费劲，只能生成double。&lt;br&gt;2、内部有借用java.util.Random&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SecureRandom&lt;/td&gt;
&lt;td&gt;142毫秒&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;线程安全，seed不可预测（借助于系统中的随机事件信息）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Apache#RandomDataGenerator&lt;/td&gt;
&lt;td&gt;54毫秒&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;API比较丰富，特殊场景下考虑。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;it.unimi.dsi#XoRoShiRo128PlusRandom&lt;/td&gt;
&lt;td&gt;17毫秒&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;偏门的三方包。比较快。线程不安全。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="随机数" scheme="https://veryjj.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM实战 之 奇怪FullGC定位</title>
    <link href="https://veryjj.github.io/2020/10/15/JVM%E5%AE%9E%E6%88%98%20%E4%B9%8B%20%E5%A5%87%E6%80%AAFullGC%E5%AE%9A%E4%BD%8D/"/>
    <id>https://veryjj.github.io/2020/10/15/JVM实战 之 奇怪FullGC定位/</id>
    <published>2020-10-15T15:54:39.000Z</published>
    <updated>2021-01-10T09:07:54.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p><img src="https://img-blog.csdnimg.cn/20201015223319828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图1 真线环境abc-center 堆使用率</center><p> <img src="https://img-blog.csdnimg.cn/20201015223348400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图2 真线环境 abc-center 非堆使用率</center><p>由图1、图2 可见heap和permGen使用率都不高，但是abc-center 2台机器基本上每天会进行2次规律性的FullGC；</p><a id="more"></a><p><br></p><h1 id="二、问题排查"><a href="#二、问题排查" class="headerlink" title="二、问题排查"></a>二、问题排查</h1><p>在线询价真线环境JVM参数配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g</span><br><span class="line">-Xmx2g</span><br><span class="line">-Xmn448m</span><br><span class="line">-XX:SurvivorRatio=5</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+CMSClassUnloadingEnabled</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction=0</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=75</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:MetaspaceSize=300M</span><br><span class="line">-XX:MaxMetaspaceSize=300M</span><br></pre></td></tr></table></figure></p><p>查看真线JVM配置参数CMSInitiatingOccupancyFraction=75，配置的内存是2G，实际堆内存维持在570M左右，老年代内存1.5G，老年代内存使用率也低于75%，达不到触发FullGC的条件；基本上每次FullGC前后，堆内存也无明显变化；</p><p>团队内部分析讨论后，怀疑可能由于System.gc 引起的FullGC。根据pinpoint 触发FullGC的时间点，查看对应时间段的gc-log，确实是由于System.gc引起的FullGC；</p><p><img src="https://img-blog.csdnimg.cn/20201015223808943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center> 图3 真线环境 -center gc日志</center><p>排除掉ABC项目中的程序调用System.gc, 开始猜测二方SDK，三方SDK引入的可能，例如nio包，但是没有找到具有参考价值的日志, 无法定位到具体的调用方法；</p><p>通过反复观察gc日志，发现这些fullgc日志都是周期性的，且周期为10小时，如图3所示；根据GC日志分析可知，应用每10小时触发Full GC的现象大概率是外部组件调用引起的，根据这个线索，开始索骥Google资料，了解到tomcat、nio、cxf部分版本可能会有类似周期性FullGC问题。有价值博客只有:<a href="https://blog.csdn.net/qq_35963057/article/details/85236268" target="_blank" rel="noopener">https://blog.csdn.net/qq_35963057/article/details/85236268</a>，同样的也是每隔10小时FullGC一次；因此大概率判断是由于apache的cxf包引起的FullGC；</p><p><br></p><h1 id="三、定位分析"><a href="#三、定位分析" class="headerlink" title="三、定位分析"></a>三、定位分析</h1><p> 根据上述分析，查看ABC的maven依赖，如图4，果然在ABC中找到了间接引入了apache-cxf的二方SDK包<br><img src="https://img-blog.csdnimg.cn/20201015224357875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center> 图4 inquiry项目maven依赖树</center><p>由于在apache-cxf下的JDKBugHacks利用反射调用了sun.misc.GC中的requestLatency方法如图5所示，调用该方法会创建一个守护线程如图6；</p><p><img src="https://img-blog.csdnimg.cn/20201015224512777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图5 JDKBugHacks类的doHacks方法</center><p><img src="https://img-blog.csdnimg.cn/20201015224548208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图6 GC类中创建守护线程</center><p><img src="https://img-blog.csdnimg.cn/20201015224557199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图7 run方法</center><p><br></p><p>由图7可知，正是由于在守护线程的run方法中调用了System.gc方法导致了FullGC，同时由GC.lock.wait可知，var1是图5 反射调用传入的36000000ms即10小时，当一次FullGC后，var4会变成0，</p><p>因此锁的等待时间是10小时，到这里就基本确定了ABC应用真线是就是由于Apache的cxf包下的JDKBugHacks反射调用导致的；这个GC线程是为了预防部分组件造成的内存泄露问题</p><p>(如javax.management.remote.rmi.RMIConnectorServer等会分配堆外内存)，通过调用sun.misc.GC类中requestLatency创建周期为10小时的GC守护线程，定期通知JVM去回收垃圾。</p><p>这个线程会先判断是否已有其他组件通过requestLatency来创建了GC线程，如果创建了就跳过，否则新建守护进程。根据类名JDKBugHacks，也能猜测这个类是为了修复一些JDK或组件已有的问题，但这个定期FGC在本应用并不需要；</p><p><br></p><p>由于是依赖的二方包引入的，ABC项目中没有显式的调用相关类，需要继续排查是什么地方调用了JDKBugHacks这个类；</p><p>排查发现是由于spring框架在初始化的时候进行了调用，如图8、图9所示(中间省略了几个调用节点)</p><p><img src="https://img-blog.csdnimg.cn/20201015224857258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center> 图8 PostProcessorRegistrationDelegate类</center><p><img src="https://img-blog.csdnimg.cn/20201015224909735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图9   LogUtils类</center><p><br></p><h1 id="四、解决方案"><a href="#四、解决方案" class="headerlink" title="四、解决方案"></a>四、解决方案</h1><p>方案1、由图5可知，可以通过控制判断条件，让其不执行if 里面的逻辑</p><p>直接在启动项目的JVM参数中加入<br>-Dorg.apache.cxf.JDKBugHacks.gcRequestLatency=true   来使JDKBugHacks中的判断为false，然后跳过这段逻辑。</p><p><br><br><br></p><p>方案2、由于二方SDK引入的，实际二方包本身并没有使用到cxf包，maven将Apache-cxf包排除即可,如图10所示；</p><p>本次修改采用第二种解决方案；</p><p><img src="https://img-blog.csdnimg.cn/20201015225231482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图11 真线堆内存</center><p>优化发布上线后，观察近三天确实不在出现FullGC； </p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015223319828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;center&gt;图1 真线环境abc-center 堆使用率&lt;/center&gt;

&lt;p&gt; &lt;img src=&quot;https://img-blog.csdnimg.cn/20201015223348400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;center&gt;图2 真线环境 abc-center 非堆使用率&lt;/center&gt;


&lt;p&gt;由图1、图2 可见heap和permGen使用率都不高，但是abc-center 2台机器基本上每天会进行2次规律性的FullGC；&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://veryjj.github.io/tags/JVM/"/>
    
      <category term="内存" scheme="https://veryjj.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM实战 之 一次内存溢出排查经历</title>
    <link href="https://veryjj.github.io/2020/10/15/JVM%E5%AE%9E%E6%88%98%20%E4%B9%8B%20%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%8E%92%E6%9F%A5%E7%BB%8F%E5%8E%86/"/>
    <id>https://veryjj.github.io/2020/10/15/JVM实战 之 一次内存溢出排查经历/</id>
    <published>2020-10-15T15:09:11.000Z</published>
    <updated>2021-01-10T09:07:49.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源于线上应用事件"><a href="#源于线上应用事件" class="headerlink" title="源于线上应用事件"></a>源于线上应用事件</h1><p>某天团队同学收到线上系统报警，web-abc真线有一台机down掉了。</p><p>为保留事故现场，做剩余应用做了dump。</p><p>然后开始分析</p><a id="more"></a><p><br></p><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>1、 经过对线上出问题周期内的应用日志逐条排查，未发现明显异常。</p><p>2、分析当时的dump快照，发现有两个类的实例数和总大小异常，这两个类是跟poi解析excel有关!这个很关键。</p><p><img src="https://img-blog.csdnimg.cn/20201015230016978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>3、再翻事发时间的真线日志，有所发现，16点11分51秒的时候，确实有流量请求一个上传excel的接口</p><p><img src="https://img-blog.csdnimg.cn/20201015230150609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>4、对比常规接口的日志，事发情况下，只有start没有finish，说明这个请求僵住了，而自这个请求之后的时间，机器才出现不断fullgc的情况</p><p><img src="https://img-blog.csdnimg.cn/20201015230212131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>5、伪造一个excel大文件，在test环境上传，把test服务器搞挂，dump文件分析，与真线类似</p><p><img src="https://img-blog.csdnimg.cn/20201015230357752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>6、通过以上几点证据，判定为本次事件是由于用户上传excel文件出现的极端情况（文件过大，或者一直尝试），具体的情况日志已分析不出。</p><p>8、排查代码中POI读取Excel的方式，发现使用的是用户模式，这样会占用大量的内存；POI提供了2中读取Excel的模式，分别是：</p><ul><li>用户模式：poi下的usermodel有关包，它对用户友好，有统一的接口在ss包下，但是它是把整个文件读取到内存中的，对于大量数据很容易内存溢出，所以只能用来处理相对较小量的数据；</li><li>sax模式：poi下的eventusermodel包下，相对来说实现比较复杂，但是它处理速度快，占用内存少，可以用来处理海量的Excel数据。</li></ul><p>POI sax模式只是改善，并不能完全解决这个问题，所以采用阿里开源easyexcel解决优化。<br><img src="https://img-blog.csdnimg.cn/20201015230508784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><br></p><h1 id="修改优化"><a href="#修改优化" class="headerlink" title="修改优化"></a>修改优化</h1><p>1、poi解析excel的方式改为easyexcel方式</p><p>2、排查后端文件上传、下载的场景，进行大文件极端场景测试</p><p><br></p><h1 id="整改方案"><a href="#整改方案" class="headerlink" title="整改方案"></a>整改方案</h1><p>Java领域解析、生成Excel比较有名的框架有Apache poi、jxl等。但他们都存在一个严重的问题就是非常的耗内存。如果并发量大或excel文件过大，则会OOM或者JVM频繁的full gc。POI的SAX模式虽有改善，但相对比较复杂，excel有03和07两种版本，两个版本数据存储方式截然不同，sax解析方式也各不一样。而阿里开源的easyexcel很好地解决了解析excel大量消耗内存的问题，而且使用简单，功能上也可以覆盖我们的业务需求。<br><br></p><h2 id="easyexcel核心原理"><a href="#easyexcel核心原理" class="headerlink" title="easyexcel核心原理"></a>easyexcel核心原理</h2><p><strong>1、文件解压文件读取通过文件形式</strong></p><p><img src="https://img-blog.csdnimg.cn/20201015230611873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>2、观察者模式按行解析</strong><br>easyExcel采用一行一行的解析模式，并将一行的解析结果以观察者的模式通知处理（AnalysisEventListener）</p><p><img src="https://img-blog.csdnimg.cn/20201015230636250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxODM2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>3、抛弃不重要数据</strong><br>Excel解析时候会包含样式，字体，宽度等数据，但这些数据是我们不关心的，如果将这部分数据抛弃可以大大降低内存使用。Excel中数据如下Style占了相当大的空间。</p><p><br></p><h2 id="easyexcel的使用："><a href="#easyexcel的使用：" class="headerlink" title="easyexcel的使用："></a>easyexcel的使用：</h2><p>请自行百度</p><p>推荐读物：<a href="https://alibaba-easyexcel.github.io/quickstart/faq.html" target="_blank" rel="noopener">https://alibaba-easyexcel.github.io/quickstart/faq.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;源于线上应用事件&quot;&gt;&lt;a href=&quot;#源于线上应用事件&quot; class=&quot;headerlink&quot; title=&quot;源于线上应用事件&quot;&gt;&lt;/a&gt;源于线上应用事件&lt;/h1&gt;&lt;p&gt;某天团队同学收到线上系统报警，web-abc真线有一台机down掉了。&lt;/p&gt;
&lt;p&gt;为保留事故现场，做剩余应用做了dump。&lt;/p&gt;
&lt;p&gt;然后开始分析&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://veryjj.github.io/tags/JVM/"/>
    
      <category term="内存" scheme="https://veryjj.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>一文就让你精通JVM</title>
    <link href="https://veryjj.github.io/2020/10/04/%E4%B8%80%E6%96%87%E5%B0%B1%E8%AE%A9%E4%BD%A0%E7%B2%BE%E9%80%9AJVM/"/>
    <id>https://veryjj.github.io/2020/10/04/一文就让你精通JVM/</id>
    <published>2020-10-04T12:34:00.000Z</published>
    <updated>2021-01-10T08:42:00.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《一文就让你精通JVM》"><a href="#《一文就让你精通JVM》" class="headerlink" title="《一文就让你精通JVM》"></a>《一文就让你精通JVM》</h1><p>网上有关JVM的知识贴多如牛毛，其中有纷杂的零碎知识贴，也有整理优秀的长贴。信息量非常充分。</p><p>但作为复习或整理JVM知识的而言，还可以有更好的学习用户体验和高效的方式。因此，就想尝试写一篇有关JVM知识点的“秘籍”，让初学者仅读此文就能快速精通JVM的知识脉络以及关键知识，也能让复习着快速反查知识和经验之谈。</p><p align="right">黄老师</p><a id="more"></a><p><img src="/2020/10/04/一文就让你精通JVM/目录.png" alt="目录"></p><h1 id="1、背景知识铺垫"><a href="#1、背景知识铺垫" class="headerlink" title="1、背景知识铺垫"></a>1、背景知识铺垫</h1><h2 id="1-1、JRE、JVM、JDK"><a href="#1-1、JRE、JVM、JDK" class="headerlink" title="1.1、JRE、JVM、JDK"></a>1.1、JRE、JVM、JDK</h2><p>先讲讲JVM、JRE、JDK是什么</p><ul><li>JVM (Java Virtual Machine)<ul><li>JVM有自己的规范，所有的JVM版本都必须按此规范实现。</li><li>JVM是一个抽象、虚拟、不物理存在的”机器”。是通过在真实的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。</li><li>JVM负责执行Java代码</li></ul></li><li>JRE (Java Runtime Environment)<ul><li>JRE包含JVM</li><li>JRE是一个运行环境容器，提供诸多Java运行需要的libs。包括：标准、非标准的Java组件；Java规范要求、Java规范未要求的组件。</li><li>JRE为JVM服务</li><li>rt.jar(contains: lang, util, awt, swing, math, runtime libraries)</li></ul></li><li>JDK (Java Development Kit)<ul><li>从Kit单词上可预知JDK会包含很多东西，的确，JDK包含：JVM、JRE，以及Java语言和工具包。</li><li>JDK比JRE多的部分：Development, debugging tools</li></ul></li><li>Oracle 官方Java概念图    </li></ul><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002123247830.png" alt="image-20201002123247830"></p><h2 id="1-2、HotSpot-Client-Server模式"><a href="#1-2、HotSpot-Client-Server模式" class="headerlink" title="1.2、HotSpot Client/Server模式"></a>1.2、HotSpot Client/Server模式</h2><p>为什么要铺垫下 HotSpot Client/Server模式？因为后续GC章节默认收集器在不同模式下不同。</p><p>HotSpot JVM具有两种模式：Client模式和Server模式。可以理解为针对不同的硬件环境和软件场景做的JVM优化版本。</p><ul><li>Java HotSpot Client VM(-client)：轻量级。为在客户端环境中减少启动时间而优化，使用的策略和功能都是较简单版本。</li><li>Java HotSpot Server VM(-server)：重量级。为在服务器环境中最大化程序执行速度而设计，使用的策略和功能是为了最大化的发挥硬件优势，提升吞吐量。《《《 作为服务端Java开发，大多数情况下默认Server模式。</li></ul><p>HotSpot的安装的模式，32位的hotspot都是client模式；64位的都是server模式的。</p><p>可通过java -version查看</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201003153939596.png" alt="image-20201003153939596"></p><p>若想要修改模式，则需变更JVM的配置文件。32位的虚拟机在 “%JAVA_HOME%/jre/lib/i386/jvm.cfg”；64位的虚拟机在“%JAVA_HOME%/jre/lib/amd64/jvm.cfg”；</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201003155003824.png" alt="image-20201003155003824"></p><h1 id="2、JVM体系结构"><a href="#2、JVM体系结构" class="headerlink" title="2、JVM体系结构"></a>2、JVM体系结构</h1><p><img src="/2020/10/04/一文就让你精通JVM/image-20200927212354198.png" alt="image-20200927212354198"></p><center>JVM体系结构图</center><p><img src="/2020/10/04/一文就让你精通JVM/image-20200928214421885.png" alt="image-20200928214421885"></p><center>操作系统视角</center><h2 id="2-1、Class文件"><a href="#2-1、Class文件" class="headerlink" title="2.1、Class文件"></a>2.1、Class文件</h2><ul><li>Class 文件是一种特定的<strong>二进制文件</strong>格式的文件。格式紧凑，包含了JVM指令集和符号表以及若干其他辅助信息，其编码结构风格被称为“字节码”。</li><li>在JVM体系里，不同的硬件(主要是CPU)和操作系统环境下的JVM是不同版本的实现，而<strong>Java语言的平台无关性，主要体现在“Class文件”上</strong>。Java代码一次编译成Class文件，可以在不同体系的JVM版本下运行。</li></ul><p><img src="/2020/10/04/一文就让你精通JVM/image-20200927204916941.png" alt="image-20200927204916941"></p><ul><li>其他语言只要其代码能被编译成符合Class文件规范的Class文件，就能在JVM上运行。</li></ul><h2 id="2-2、内存区-之-虚拟机栈区"><a href="#2-2、内存区-之-虚拟机栈区" class="headerlink" title="2.2、内存区 之 虚拟机栈区"></a>2.2、内存区 之 虚拟机栈区</h2><blockquote><p>见上图《JVM体系结构图》</p></blockquote><p>在JVM里有一块专门为Java线程分配栈空间的内存区，叫”虚拟机栈区”。</p><p>每个Java线程创建时都会分配一个“虚拟机栈”，此虚拟机栈的生命周期与其所绑定的线程生命周期一致。</p><p>而当线程执行Java代码时，JVM会为每个Java方法创建一个固定结构的内存模型：栈帧。</p><ul><li>此“栈帧”结构是线程虚拟机栈入栈/出栈操作的基本单位（入栈/出栈的时机对应Java方法的调用和返回）</li><li>栈帧是用于支持JVM进行方法调用和方法执行的数据结构</li></ul><p><strong>2.2.1、栈帧(Stack Frame)结构</strong></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20200927213751205.png" alt="image-20200927213751205" style="zoom:50%;" align="left"></p><ol><li><p><strong>局部变量表</strong>： 编译期确定局部变量表大小。一组变量存储空间， 容量以slot为最小单位，而slot的大小随硬件体系而定，以此来适应硬件体系的差异。</p><ul><li><blockquote><p>虚拟机规范中未明确指明一个Slot应占用的内存空间大小，只是导向性的说到每个Slot都应该存放一个boolean、byte、char、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型都可以使用32位或更小的物理内存来存放，Slot的长度可以随着处理器、操作系统或虚拟机的不同而发生变化。</p></blockquote></li></ul></li><li><p><strong>操作栈</strong>：编译期确定操作数栈最大深度。是一个后入先出栈（LIFO）。操作数栈可类比CPU的寄存器，协助JVM完成Java方法内的调用传值，计算操作。</p><ul><li><blockquote><p>例如：整数加法的字节码指令iadd再运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int类型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。</p></blockquote></li></ul></li><li><p><strong>动态连接</strong>： 指向运行时常量池中该栈帧所属Java方法的引用，这样才能找到真正&amp;完整的代码片段。</p><ul><li><blockquote><p>Class文件中关于方法调用，存的是符号引用。字节码在运行期，需要将符号引用转化为带具体内存地址的代码片段的直接引用。</p></blockquote></li></ul></li><li><p><strong>方法返回地址</strong>：方法退出的过程实际上等同于把当前栈帧出栈，并恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p><ul><li>方法返回地址里一般存的是调用者当时的PC计数器的值。当方法正常返回时，就返回这个地址。而当方法异常退出时，返回地址要通过异常处理器表来确定。</li></ul></li><li><p><strong>额外附加信息</strong>：预留的扩展区域，由JVM实现方按需使用。</p></li></ol><h2 id="2-3、内存区-之-本地方法栈区"><a href="#2-3、内存区-之-本地方法栈区" class="headerlink" title="2.3、内存区 之 本地方法栈区"></a>2.3、内存区 之 本地方法栈区</h2><p>本地方法栈是JVM为Native方法提供的内存空间。</p><p>本地方法栈里的基本元素结构取决于本地方法接口的具体实现机制。若其使用C连接模型,那么本地方法栈就是C栈。</p><p>Java方法栈和本地方法栈之间可以灵活交叉切换。</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20200928213456079.png" alt="image-20200928213456079" style="zoom:50%;"></p><p>有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如典型的Sun HotSpot虚拟机。</p><h2 id="2-4、内存区-之-堆内存区"><a href="#2-4、内存区-之-堆内存区" class="headerlink" title="2.4、内存区 之 堆内存区"></a>2.4、内存区 之 堆内存区</h2><p><img src="/2020/10/04/一文就让你精通JVM/image-20200928220414158.png" alt="image-20200928220414158" style="zoom:80%;"></p><p>Java堆，是JVM管理的最大的一块内存，也是GC的主战场。里面存放的是几乎所有的对象实例和数组数据。</p><blockquote><p>JIT编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在Java堆，而是栈内存。</p></blockquote><ul><li><p><strong>从内存回收角度</strong>：Java堆为分代回收机制，分为年轻代和老年代。这样划分的好处是为了更快的回收内存（每次回收的内存范围相对小）</p></li><li><p><strong>从内存分配角度</strong>：Java堆可以划分出线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB)；这样划分的好处是为了更快的分配内存；</p><ul><li><blockquote><p>关联知识点：</p><p>1、标量替换：允许将对象打散分配在栈上，比如若一个对象拥有两个字段，会将这两个 字段视作局部变量进行分配。</p></blockquote></li></ul></li></ul><h3 id="2-4-1、各内存区默认配比"><a href="#2-4-1、各内存区默认配比" class="headerlink" title="2.4.1、各内存区默认配比"></a><strong>2.4.1、各内存区默认配比</strong></h3><ul><li>年轻代：老年代 默认 1：2（将堆空间分为3份）</li><li>Eden ：from ：to  默认  8：1：1</li></ul><p><img src="/2020/10/04/一文就让你精通JVM/image-20200928231435881.png" alt="image-20200928231435881" style="zoom:40%;"></p><p>相关JVM参数</p><ul><li>-Xms：初始堆大小。默认物理内存的1/64。</li><li>-Xmx：最大堆大小。默认物理内存的1/4。</li><li>-Xmn：年轻代大小</li><li>-XX:NewRatio：年轻代与老年代的比值</li><li>-XX:SurvivorRatio：Eden区域Survivor区的大小比值。默认8:1:1。</li></ul><h3 id="2-4-2、TLAB"><a href="#2-4-2、TLAB" class="headerlink" title="2.4.2、TLAB"></a><strong>2.4.2、TLAB</strong></h3><p>全称 Thread Local Allocation Buffer，线程本地分配缓冲区。</p><p>默认是开始的。JVM命令 -XX:+UseTLAB。</p><p>由于堆是全局共享的，因此存在同一时间会有多个线程在堆上申请空间的并发情况。为保证堆内存分配操作的原子性，JVM采用“CAS+失败重试”的方式，但这种方式在并发竞争激烈的情况下效率会进一步下降。</p><p>因此，JVM额外设计了TLAB 来避免多线程分配对象内存时的冲突处理。</p><p>大致原理：</p><ul><li>JVM在内存年轻代Eden Space中开辟了一小块线程私有的区域，称作TLAB。默认设定为占用Eden Space的1%。</li><li>Java中每个线程都会有自己的缓冲区称作TLAB。</li><li>由于TLAB是线程私有的，所以内存分配没有锁开销，效率高。</li><li>在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上。</li></ul><blockquote><p>故，对象仍旧是在堆上被分配的，只不过分配的方式变了而已。</p></blockquote><h3 id="2-4-3、逃逸分析"><a href="#2-4-3、逃逸分析" class="headerlink" title="2.4.3、逃逸分析"></a><strong>2.4.3、逃逸分析</strong></h3><blockquote><p>关联知识点：逃逸分析只在JVM运行在server模式时才能启用。</p></blockquote><p>逃逸分析 是一种可以有效减少Java 中堆内存分配压力的分析算法。JVM默认开启。</p><p>通过逃逸分析，Java Hotspot编译器能够分析出一个即将新创建对象的引用的使用范围，从而决定通过哪种方式分配对象内存（栈上标量替换；TLAB分配；堆分配；）。</p><h3 id="2-4-4、对象内存分配的两种方法"><a href="#2-4-4、对象内存分配的两种方法" class="headerlink" title="2.4.4、对象内存分配的两种方法"></a><strong>2.4.4、对象内存分配的两种方法</strong></h3><p>为对象分配内存空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p><ul><li><strong>指针碰撞</strong>    (Serial、ParNew等带Compact过程的收集器)<br>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）。 </li><li><strong>空闲列表</strong>    (CMS这种基于Mark-Sweep算法的收集器)<br>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。 </li></ul><p><img src="/2020/10/04/一文就让你精通JVM/image-20200928224239531.png" alt="image-20200928224239531" style="zoom:50%;" align="left"></p><h3 id="2-4-5、对象实例的具体结构"><a href="#2-4-5、对象实例的具体结构" class="headerlink" title="2.4.5、对象实例的具体结构"></a><strong>2.4.5、对象实例的具体结构</strong></h3><p><img src="/2020/10/04/一文就让你精通JVM/java_object.png" alt="java_object" style="zoom:80%;"></p><ul><li>对于填充数据不是一定存在的，仅仅是为了字节对齐。</li></ul><h2 id="2-5、内存区-之-方法区"><a href="#2-5、内存区-之-方法区" class="headerlink" title="2.5、内存区 之 方法区"></a>2.5、内存区 之 方法区</h2><p>当JVM使用<strong>类装载</strong>器装载某个类时，它首先要定位对应的class文件，然后读入这个class文件，最后，JVM<strong>提取该文件的内容</strong>信息，并将这些信息<strong>存储到方法区</strong>，最后返回一个class实例。</p><ul><li>注：方法区 是 JVM规范的一部分，并不是实际的实现。实际实现有JDK7以前的永久代，以及JDK8的元空间。</li></ul><p><strong>方法区的特点：</strong></p><p>1、方法区是线程安全的。假如同时有两个线程都企图访问方法区中的同一个类，而这个类还没有被装入JVM，那么只允许一个线程去装载它，而其它线程必须等待。</p><p>2、方法区的大小不是固定的，JVM可根据应用运行期的需要动态调整。其内存也不一定是连续的。</p><p>3、方法区也可被垃圾收集（GC），当某个类不在被使用(不可触及)时，JVM将卸载这个类，进行垃圾收集。</p><p>方法区主要存放的是<strong>已被虚拟机加载</strong>的类信息、常量、静态变量、编译器编译后的代码等数据。</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20200929213621269.png" alt="image-20200929213621269" style="zoom:50%;"></p><center>常量池分解</center><p><strong>2.5.1、静态常量池：</strong></p><p>即class文件中的常量池，是文件级、静态级的。class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。</p><p><strong>2.5.2、运行时常量池：</strong></p><p>运行时常量池是方法区的一部分，可以理解为一块专门存放常量的内存。包括装载class文件而放入的常量，也包括代码运行时动态生成的常量（String类的intern()方法）。</p><p>静态常量池和运行时常量池的差别在于，一个是存在文件中，是“静”的，一个是存在内存中，是“动”的。</p><p>而我们常说的常量池，一般是指在方法区中的动态常量池。</p><h2 id="2-6、内存区-之-堆外内存区"><a href="#2-6、内存区-之-堆外内存区" class="headerlink" title="2.6、内存区 之 堆外内存区"></a>2.6、内存区 之 堆外内存区</h2><p>讲堆外内存前，首先带大家从操作系统视角看堆外内存所处的位置。相信看了直观的图示后能立马有清晰的记忆和理解。</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20200929221651061.png" alt="image-20200929221651061" style="zoom:80%;"></p><p>助读说明：</p><p>1、先着眼操作系统进程视角，每个进程都拥有自己独占的进程级内存空间。每个进程看到的机器内存大小是一样的，且内存范围也是一样的。为什么？因为用户态进程看到的是逻辑内存地址，并不是真实的物理内存地址。</p><p>2、用户态进程的内存地址都是逻辑地址，用malloc分配，故物理上不连续。</p><p>3、堆内存在JVM内。受JVM管理，参与GC。</p><p>4、<strong>堆外内存处于进程内存空间，但属于JVM堆内存之外</strong>。</p><p>5、堆外内存不受JVM管理，不参与GC。编码时需要主动释放。</p><p><strong>2.6.1、直接内存</strong>（Direct Buffer）</p><p>Direct Buffer是堆外内存的一种具体类型，常出现于NIO模型中。</p><p>NIO模型中为什么要用Direct Buffer？</p><p>答：NIO需要进行socket连接的收包和发包，这个操作最终要从操作系统用户态进入到内核态进行操作。而内核态调用要求内存地址必须可靠（即在一次完整调用周期内内存地址是不会变的）。但Java堆里的内存会受GC影响而移动整理，地址会变。故NIO不能用堆里的内存。</p><blockquote><p>即使代码层面非要用Java堆内存区做NIO操作，JVM仍会自动将堆内存对象转换为直接内存对象，然后再进行内核态操作。</p></blockquote><p>故Direct Buffer对于JVM来说有如下优点：</p><p>1、对于NIO操作,直接用Direct Buffer比用Java堆内存,免去一次内存拷贝，相比之下效率高了。</p><p>2、GC压力更小。因Direct Buffer是堆外内存，是代码者自行管理，不用JVM额外操心,GC的范围就缩小了。</p><p>其他须知：</p><p>1、Direct Buffer创建是比较耗时的，高性能或高频场景下，建议池化。</p><h1 id="3、JVM垃圾收集器"><a href="#3、JVM垃圾收集器" class="headerlink" title="3、JVM垃圾收集器"></a>3、JVM垃圾收集器</h1><p>JVM垃圾回收是继掌握内存模型后，必须进阶更进一步掌握的JVM内存知识。</p><p>全世界的程序员都知道：“Java的内存是会自动回收的”。这背后会有哪些知识点呢，请看下文。</p><h2 id="3-1、垃圾回收原理"><a href="#3-1、垃圾回收原理" class="headerlink" title="3.1、垃圾回收原理"></a>3.1、垃圾回收原理</h2><p><strong>3.1.1、垃圾分析策略</strong></p><ul><li>引用计数 策略</li></ul><blockquote><p>比较古老的回收算法。原理是额外维护对象上的引用计数。当发生GC时，回收引用计数为0的对象的内存。</p><p>此算法的缺点：无法处理循环引用的问题。</p><p>​        那怎么破解呢？用Java里的弱引用（Weak Reference）破开强引用关系。</p></blockquote><ul><li>可达性分析 策略（主流JVM用的都是这种）</li></ul><blockquote><p>从GC ROOT开始，遍历引用关系节点，当所有的引用节点遍历完毕之后，剩余未遍历到的节点则被认为是没有被引用到的节点，即可被回收的对象节点。</p></blockquote><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002123907218.png" alt="image-20201002123907218" style="zoom:40%;"></p><center>GC Root 示例</center><p>需要知晓的是：</p><p>1、会有一些列的“GC Roots”且同时工作，在Java中可作为GC Root的对象包括：</p><p>​      a）虚拟机栈中引用的对象（栈帧中的本地变量表）</p><p>​      b）方法区中类静态属性引用的对象</p><p>​      c）方法区中常量引用的对象</p><p>​      d）本地方法栈中JNI（Native）引用的对象</p><p>2、<strong>基于GC Root做可达性分析时，需要STW（Stop The World），必须记住此知识点</strong>，对于了解后续垃圾回收算法有帮助。</p><p> <strong>3.1.2、垃圾回收算法</strong></p><p><strong>一、引用计数 算法</strong></p><blockquote><p>略</p></blockquote><p><strong>二、标记-清除 算法（Mark-Sweep）</strong></p><p>最基础的垃圾回收算法，思想简单且容易实现。</p><p>工作上分为两个阶段：</p><p>一、标记阶段：从GC Roots开始标记被引用对象；</p><p>二、清除阶段：遍历整个堆，把未标记的对象清除；</p><p>缺点：会有内存碎片。导致下一次GC的提前到来。</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002130408084.png" alt="image-20201002130408084" style="zoom:30%;"></p><p><strong>三、复制 算法（Copying）</strong></p><p>为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。</p><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把此内存区域空间一次清空，这样一来就不容易出现内存碎片的问题。</p><p>优点：不会出现内存碎片。</p><p>缺点：需要两倍的内存空间。</p><p>适合对象生命周期短的内存区域，一次能回收绝大部分内存。例如：年轻代</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002132644475.png" alt="image-20201002132644475" style="zoom:30%;"></p><p><strong>四、标记-整理 算法（Mark-Compact）</strong></p><p>此算法结合了“标记<strong>-</strong>清除”和“复制”两个算法的优点。</p><p>分为三个阶段：（我更喜欢划分为三个阶段）</p><p>第一阶段：从GC Root开始标记所有被引用对象</p><p>第二阶段：遍历整个堆，将存活对象往集中的一片内存区域移动。</p><p>第三阶段：基于内存整理后的指针边界，清除整理区域以外的内存空间。</p><p><strong>再强调下特殊点：时序上是“标记-&gt;整理-&gt;清理”。</strong></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002133558462.png" alt="image-20201002133558462" style="zoom:30%;"></p><p><strong>3.1.3、小结一下</strong></p><table><thead><tr><th>堆内存区</th><th>垃圾分析策略</th><th>常用垃圾回收算法</th></tr></thead><tbody><tr><td>年轻代</td><td>GC Root可达性分析</td><td>1、复制算法</td></tr><tr><td>老年代</td><td>GC Root可达性分析</td><td>1、标记-清除算法<br>2、标记-整理算法</td></tr></tbody></table><p><strong>衍生的知识点：</strong></p><p>GC Roots的可达性分析，会衍生到图论的算法。有一个比较经典的有向图的问题：有向图检测是否存在环。</p><p>这也是调用引擎，规则引擎经常会遇到的算法问题（新加入一个节点时预检测是否构成环）</p><blockquote><p>考虑简单环，所谓的简单环，即除了第一个和最后一个顶点，其余所有顶点在路径中只出现一次。</p></blockquote><p>实现思路一：DFS    时间复杂度O(V+E)</p><p>做DFS（深度优先搜索）遍历时，每深入遍历一个的节点就把节点都压入<strong>栈</strong>，每退回一层遍历就把节点从栈中退出，且每次压入前都检测当前节点在栈中是否已存在。如果已存在，就表明曾经经过此节点，说明已构成环。</p><p><a href="https://blog.csdn.net/login_sonata/article/details/78002042" target="_blank" rel="noopener">参考之一</a></p><p>实现思路二：拓扑排序    时间复杂度O(n^2)    从有向图的末梢逐步往上砍叶子节点。</p><p>出度和入度的概念。一张有向图是有顶点和带有方向的边组成的。对于一个顶点，如果有n边从其他顶点指向此顶点，则这个顶点的入度就是n。相应的，如果有n条边从这个顶点指向其他顶点，则这个顶点的出度就是n。</p><p><strong>拓扑排序</strong>的一般流程：</p><p>1.初始化各个顶点的出度。</p><p>2.移除出度为0的顶点和与此顶点相连的边。</p><p>3.更新出度。</p><p>4.重复步骤2和3，直到不存在出度为0的顶点或者顶点已经全部被移除了。</p><p>5.判断是否存在剩余顶点，若存在则存在环，若不存在则无环。</p><p><a href="https://blog.csdn.net/weixin_48607921/article/details/107224420?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">参考</a></p><h2 id="3-2、分代收集策略"><a href="#3-2、分代收集策略" class="headerlink" title="3.2、分代收集策略"></a>3.2、分代收集策略</h2><p>分代收集策略的目的本质是为了更高效效率的进行内存回收。</p><p>核心思想是根据对象存活生命周期的特点，将JVM内存划分为若干个区域，不同内存区域按其对象生命周期的特点采用不同的回收频率和回收算法。常见的分代方式：年轻代、老年代、永久代。</p><blockquote><p>反过来试想，假设JVM在一次垃圾回收窗口时，要对整个JVM内存区对垃圾回收分析和清除，Stop The World会持续很长时间。</p></blockquote><p><strong>与垃圾回收策略的匹配</strong></p><table><thead><tr><th>堆内存区</th><th>内存区特点</th><th>垃圾分析策略</th><th>常用垃圾回收算法</th></tr></thead><tbody><tr><td>年轻代</td><td>对象生命周期短，每次回收量大</td><td>GC Root可达性分析</td><td>1、复制算法</td></tr><tr><td>老年代</td><td>对象生命周期长，每次回收量小</td><td>GC Root可达性分析</td><td>1、标记-清除算法<br>2、标记-整理算法</td></tr></tbody></table><h2 id="3-3、JVM触发GC的时机"><a href="#3-3、JVM触发GC的时机" class="headerlink" title="3.3、JVM触发GC的时机"></a>3.3、JVM触发GC的时机</h2><p><strong>3.2.1、JVM自动触发GC的时机</strong></p><ul><li><strong>触发YoungGC：</strong><ul><li>新建对象时，发现eden space满了（或者因内存碎片找不到足够连续的内存），JVM会触发一次YoungGC</li></ul></li><li><strong>触发FullGC：</strong><ul><li>升到老年代的对象空间大于老年代剩余空间，JVM会触发一次FullGC。或者被HandlePromotionFailure参数强制FullGC。</li></ul></li></ul><p><strong>3.2.2、手动触发GC</strong></p><ul><li>代码System.gc()。但只是像JVM提交了一次GC请求，至于何时会真正执行GC，未知。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates to the VM that it would be a good time to run the</span></span><br><span class="line"><span class="comment">     * garbage collector. Note that this is a hint only. There is no guarantee</span></span><br><span class="line"><span class="comment">     * that the garbage collector will actually be run.</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> shouldRunGC;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    shouldRunGC = justRanFinalization;</span><br><span class="line">    <span class="keyword">if</span> (shouldRunGC) &#123;</span><br><span class="line">      justRanFinalization = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      runGC = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shouldRunGC) &#123;</span><br><span class="line">    Runtime.getRuntime().gc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在justRanFinalization=true的时候才会执行。</p><p>强制执行GC的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br><span class="line">runtime.runFinalizationSync();</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><h2 id="3-4、“Stop-The-World”是怎么执行的（SafePoint）"><a href="#3-4、“Stop-The-World”是怎么执行的（SafePoint）" class="headerlink" title="3.4、“Stop The World”是怎么执行的（SafePoint）"></a>3.4、“Stop The World”是怎么执行的（SafePoint）</h2><p>我们知道JVM GC是需要”Stop The World”的，“Stop The World”代表着所有Java线程需要全部暂停。在JVM Java线程高频并发运行的状态下，怎么让所有Java线程全部都进入安全的暂停状态呢？答案：<strong>SafePoint机制</strong>。</p><p><br></p><p>3.4.1、【概念】</p><p>从线程角度看，safepoint可以理解成在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停。比如：GC时需要暂停所以Java线程的需求。</p><p>safepoint的特性可以用在不同的地方：GC、Deoptimization。</p><p>常见的safepoint位置：</p><ol><li><p>循环的末尾 (防止大循环的时候一直不进入 safepoint，而其他线程在等待它进入 safepoint)</p></li><li><p>方法返回前</p></li><li>调用方法的call之后 </li><li>抛出异常的位置</li></ol><p><br></p><p>3.4.2、【Safepoint放在代码什么位置】</p><blockquote><p> 以Hotspot为例说明一下什么地方会放置safepoint</p></blockquote><p>1、理论上，在解释器的每条字节码的边界都可以放一个Safepoint，但挂载Safepoint的调试符号信息（为GC生成的符号信息是OopMap）要占用内存空间，如果每条机器码后面都加safepoint的话，需要保存大量的运行时数据，所以在放置Safepoint方面会取折中适用的策略。</p><p>2、HotSpot JVM在通过JIT编译时，会在所有方法返回之前以及循环跳转、异常跳转之前放置Safepoint，为了防止发生GC需要STW时，该线程一直不能暂停。并且，在每个Safepoint都生成一些信息存储哪些地方是引用（<strong>OopMap</strong>），以便JVM能找到需要的引用。</p><p><br></p><p>3.4.3、【线程如何被挂起】</p><p>有两种方法：<strong>抢占式中断</strong>(Preemptive Suspension)和<strong>主动式中断</strong>(Voluntary Suspension)。</p><p>（线程被）<strong>抢占式中断：</strong></p><p>抢占式中断不需要线程的执行代码去主动配合。当触发GC时，JVM会中断所有线程，然后依次检查每个线程中断的位置是否为Safepoint，如果不是则恢复线程，让它执行至Safepoint再进行终端。</p><p><br></p><p>（线程）<strong>主动式中断：</strong>《《《 <strong>HotSpot JVM的实现方式</strong></p><p>即GC需要中断线程的时候，它仅仅简单地设个标志，每个Java线程会在进入Safepoint时主动轮询这个标志位，如果标志位就绪的话就自行中断。</p><blockquote><p>如果触发GC动作，VM thread会在<code>VMThread::loop()</code>方法中调用<code>SafepointSynchronize::begin()</code>方法，最终使所有的线程都进入到safepoint。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Roll all threads forward to a safepoint and suspend them all</span></span><br><span class="line"><span class="keyword">void</span> SafepointSynchronize::begin() &#123;</span><br><span class="line">  Thread* myThread = Thread::current();</span><br><span class="line">  <span class="keyword">assert</span>(myThread-&gt;is_VM_thread(), <span class="string">"Only VM thread may execute a safepoint"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (PrintSafepointStatistics || PrintSafepointStatisticsTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    _safepoint_begin_time = os::javaTimeNanos();</span><br><span class="line">    _ts_of_current_safepoint = tty-&gt;time_stamp().seconds();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>3.4.4、【线程如何恢复】</p><p>有了<code>begin</code>方法，自然有对应的<code>end</code>方法，在<code>SafepointSynchronize::end()</code>中，会最终唤醒所有挂起等待的线程。</p><p>思考题：</p><p>1、GC时最大的影响就是STW周期，本文讲的所有线程都进入safepoint的也是有个周期，且此周期受并发线程个数和safepoint距离影响。问：线程池配的越多，对GC的耗时有明显的影响吗？</p><h2 id="3-5、垃圾收集器"><a href="#3-5、垃圾收集器" class="headerlink" title="3.5、垃圾收集器"></a>3.5、垃圾收集器</h2><h3 id="3-5-1、垃圾收集器类型"><a href="#3-5-1、垃圾收集器类型" class="headerlink" title="3.5.1、垃圾收集器类型"></a><strong>3.5.1、垃圾收集器类型</strong></h3><p>HotSpot JVM里有7种垃圾收集器，你是怎么记忆它们的呢？</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002145206418.png" alt="image-20201002145206418" style="zoom:50%;"></p><p>上图解读：</p><p>（A）图中展示了<strong>7种</strong>收集器：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；</p><p>（B）图中它们所处区域，表明其是属于年轻代收集器还是老年代收集器：</p><ul><li><p>年轻代收集器**：Serial、ParNew、Parallel Scavenge；</p></li><li><p><strong>老年代收集器</strong>：Serial Old、Parallel Old、CMS；</p></li><li><p><strong>整堆收集器</strong>：G1；</p></li></ul><p>（C）两个收集器间的连线，表明它们<strong>可以搭配使用</strong>：</p><pre><code>- Serial 配 ：Serial Old 或 CMS；- ParNew 配 ：Serial Old 或 CMS；- Parallel Scavenge 配 ：Serial Old 或 Parallel Old；</code></pre><p>（D）CMS与Serial Old的连线表示Serial Old是作为CMS出现<strong>“Concurrent Mode Failure”失败</strong>的后备预案。</p><h3 id="3-5-2、常见垃圾收集器对比"><a href="#3-5-2、常见垃圾收集器对比" class="headerlink" title="3.5.2、常见垃圾收集器对比"></a><strong>3.5.2、常见垃圾收集器对比</strong></h3><p><img src="/2020/10/04/一文就让你精通JVM/image-20201003160503899.png" alt="image-20201003160503899"></p><p><strong>GC时STW的停顿时长的排行</strong>：G1 &lt; CMS &lt; Parallel收集器 &lt; Serial收集器</p><p><strong>JVM默认收集器</strong></p><p>怎么查看？</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201002231309561.png" alt="image-20201002231309561"></p><p>怎么切换？</p><p>例子：-XX:+UseConcMarkSweepGC</p><table><thead><tr><th>参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>UseSerialGC</td><td style="text-align:left">JVM运行下<u><strong>Client模式下的默认收集器</strong></u>，打开此开关后，使用<strong>Serial+Serial Old</strong>的收集器组合。</td></tr><tr><td>UseParNewGC</td><td style="text-align:left">使用ParNew+Serial Old的收集器组合。</td></tr><tr><td>UseConcMarkSweepGC</td><td style="text-align:left">使用ParNew+CMS的收集器组合。</td></tr><tr><td>UseParallelGC</td><td style="text-align:left">虚拟机运行在<strong>Server模式下的默认收集器</strong>，打开此开关后：<br>- <u>JDK 7u4版本前</u>：使用<strong>Parallel Scavenge + Serial Old</strong>的收集器组合。也是Java书上的说法。<br>- <u>JDK 7u4版本后</u>：使用<strong>Parallel Scavenge + Parallel Old</strong>的收集器组合，此时的Parallel已经很成熟了。<br>求证过程：<a href="https://blog.csdn.net/youanyyou/article/details/106464291?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">Link</a></td></tr><tr><td>UseParallelOldGC</td><td style="text-align:left">使用Parallel Scavenge + Parallel Old的收集器组合</td></tr></tbody></table><h3 id="3-5-3、常见垃圾收集器及原理"><a href="#3-5-3、常见垃圾收集器及原理" class="headerlink" title="3.5.3、常见垃圾收集器及原理"></a><strong>3.5.3、常见垃圾收集器及原理</strong></h3><p><strong>1、（年轻代）Serial</strong></p><p>​        Serial（串行）垃圾收集器是最基本、发展历史最悠久的收集器；JDK1.3.1前是HotSpot年轻代收集的唯一选择；</p><p>​       <strong>特点</strong>：</p><p>​       1、针对年轻代；</p><p>​       2、采用<strong>复制算法</strong>；单线程收集；全程STW；</p><p>​       3、HotSpot Client模式下的默认年轻代收集器；</p><p><img src="/2020/10/04/一文就让你精通JVM/20170102225015841.png" alt="img"></p><center>Serial/Serial Old组合收集器运行示意图</center><p>​       <strong>适用场景</strong>：小内存（小于200M），单CPU的环境。</p><p>2、 <strong>（年轻代）ParNew</strong></p><p>​       ParNew垃圾收集器是<strong>Serial收集器的多线程版本</strong>。</p><p>​       <strong>特点</strong>：</p><p>​       1、除了多线程外，其余的行为、特点和Serial收集器一样（两者还共用了不少代码）。</p><p>​       2、也是针对年轻代，也是<strong>复制算法</strong>。</p><p>​       3、”-XX:+UseConcMarkSweepGC”<strong>：</strong>指定使用CMS后，会<strong>默认使用</strong>ParNew作为年轻代收集器；</p><p>​       4、”-XX:ParallelGCThreads”：指定垃圾收集的线程数量，ParNew<strong>默认</strong>开启的收集线程与<strong>CPU的数量</strong>相同；</p><p><img src="/2020/10/04/一文就让你精通JVM/20170102225016331.png" alt="img"></p><center>ParNew/Serial Old组合收集器运行示意图</center><p>​       <strong>适用场景</strong>：</p><p>​       在HotSpot Server模式下，ParNew收集器是一个非常重要的收集器，<strong>因为除了Serial外，只有它能与CMS收集器配合工作</strong>。</p><p>3、 <strong>（年轻代）Parallel Scavenge</strong></p><p>​       （Java8 默认的收集器）Parallel Scavenge又称为吞吐量优先收集器，特点是多线程回收，以吞吐量优先，高效率的利用CPU时间。</p><p>​       <strong>特点</strong>：</p><p>​       1、Java8 默认的收集器；</p><p>​       2、年轻代收集器；<strong>复制算法</strong>；多线程收集；</p><p>​       3、Parallel Scavenge收集器的目标是以高吞吐量为目标，达一个可控制的吞吐量。</p><blockquote><p>吞吐量：</p><p>吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</p><p>高吞吐量即减少垃圾收集时间，让用户代码获得更长的运行时间</p></blockquote><p><img src="/2020/10/04/一文就让你精通JVM/3699e6695a1d4ac69cb66f7c1f52e219.jpeg" alt="img" style="zoom:80%;"></p><p>​       <strong>适用场景</strong>：</p><p>​       Parallel Scavenge收集器的高吞吐量可以最高效率的利用CPU时间，尽快的完成程序的运算任务等，主要适合在后台运算而不是太多交互的任务（其<em>不适合需要与用户交互的程序</em>，良好的响应速度能提升用户的体验，此种场景CMS效果更好）。</p><p>4、 <strong>（老年代）Serial Old</strong></p><p>​       Serial Old是 <strong>Serial收集器的老年代版本</strong>。是JDK 7u4版本前的老年代默认收集器。</p><p>​       <strong>特点</strong>：</p><p>​       1、采用标记整理法；</p><p>​       2、单线程；</p><p><img src="/2020/10/04/一文就让你精通JVM/20170102225016763.png" alt="img"></p><center>Serial/Serial Old组合收集器运行示意图</center><p>​       <strong>适用场景</strong>：</p><p>​       1、主要用于HotSpot的Client模式。</p><p>5、 <strong>（老年代）Parallel Old</strong></p><p>​       Parallel Old垃圾收集器是Parallel Scavenge收集器的老年代版本；<strong>目前已经很成熟了，是JDK 7u4版本后的老年代默认收集器（JDK8的老年代默认收集器）</strong>。</p><p>​       <strong>特点</strong>：</p><p>​       1、标记-整理 算法；</p><p>​       2、多线程收集；</p><p><img src="/2020/10/04/一文就让你精通JVM/20170102225017065.png" alt="img"></p><center>Parallel Scavenge/Parallel Old收集器运行示意图</center><p>6、 <strong>（老年代）CMS</strong></p><p>​       CMS收集器也称为并发低停顿收集器（或低延迟垃圾收集器），以获取最短回收停顿时间为目标。</p><p>​       CMS并不是等内存不足了才进行FullGC，而是基于设定的GC阈值，当超过阈值时主动进行CMS GC，因为CMS GC是与用户线程并发的，故用户线程对于CMS GC的停顿感知是很少的。</p><blockquote><p>CMS的GC阈值：</p><p>1、设定了CMSInitiatingOccupancyFraction时，以此为阈值，区间：0~100。</p><p>2、CMSInitiatingOccupancyFraction默认为-1，则按“((100 - MinHeapFreeRatio) + (double)( CMSTriggerRatio * MinHeapFreeRatio) / 100.0) / 100.0 ”的值决定，其中MinHeapFreeRatio默认值40，CMSTriggerRatio默认值80，那么阈值为92%。</p><p>为什么要通过阈值留有一部分空闲内存时进行GC？因为CMS GC时可能会遇到“浮动垃圾”，见下文。</p></blockquote><p><strong>^敲黑板：</strong> 需要注意：CMS GC不是FullGC！！！</p><ul><li>HotSpot VM里对concurrent collection和full collection有明确的区分。所有带有“FullCollection”字样的VM参数都是跟真正的full GC相关，而跟CMS并发GC无关的，cms收集算法只是清理老年代。</li></ul><p><strong>CMS收集器运作过程</strong></p><p><strong>第一步：初始标记（CMS initial mark）</strong>： 仅标记一下GC Roots能直接关联到的对象。<em>需要STW</em>，但速度很快。</p><p><strong>第二步：并发标记（CMS concurrent mark）</strong>：进行GC Roots Tracing的过程，标出存活对象。因与用户线程并发运行，不能保证标记出所有存活对象。</p><p><strong>第三步：重新标记（CMS remark）</strong>：<strong>多线程</strong>。修正并发标记期的标记结果。<em>需要STW</em>，相对也不长。</p><p><strong>第四步：并发清除（CMS concurrent sweep）</strong>：回收所有垃圾对象。</p><p>整个过程中<strong>耗时最长的并发标记和并发清除都可以与用户线程一起工作</strong>；所以总体上说，CMS收集器的内存回收过程与用户线程一起并发执行；</p><p><img src="/2020/10/04/一文就让你精通JVM/20170102225017372.png" alt="img"></p><center>CMS收集器运行示意图</center><p>​     <strong>特点</strong>：</p><p>​       1、<u>并发收集</u>（与用户线程并发执行），<strong>低停顿</strong>。</p><p>​       2、标记-清除算法，会产生内存碎片。  </p><p>​     <strong>缺点</strong>：</p><p>​       1、对CPU资源非常敏感</p><blockquote><p>CMS的默认收集线程数量 = (ParallelGCThreads + 3) / 4</p><p>ParallelGCThreads = （ncpus &lt;= 8）? ncpus : (3 + （(ncpus * 5) / 8))。CPU数量小于8时，ParallelGCThreads为CPU数量。</p><p>并发收集线程占用一部分CPU资源，当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。</p></blockquote><p>​      </p><p>​       2、无法处理浮动垃圾，可能出现“Concurrent Mode Failure”</p><p>​           a）浮动垃圾（Floating Garbage）</p><blockquote><p>   在并发清除时，用户线程新产生的垃圾，称为浮动垃圾；</p><p>   这使得并发清除时需要预留一定的内存空间，CMS所需要的空间比其他垃圾收集器大；</p><p>   “-XX:CMSInitiatingOccupancyFraction”：用于设置CMS预留内存空间比例；</p></blockquote><p>​          b）”Concurrent Mode Failure”失败</p><blockquote><p>   如果CMS预留内存空间无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败；</p><p>   这时JVM启用后备预案：临时启用Serail Old收集器，而导致另一次FullGC的产生；</p><p>   这样的代价是很大的，所以CMSInitiatingOccupancyFraction不能设置得太大。</p></blockquote><p>​      <strong>3、产生内存碎片</strong></p><blockquote><p>解决方法：        </p><p>（1）”-XX:+UseCMSCompactAtFullCollection + -XX:+CMSFullGCsBeforeCompaction” 设置CMS执行N次FullGC后，进行一次带整理的FullGC。默认未开启。</p><p>（2）降低-XX:CMSInitiatingOccupancyFraction参数，以提早执行CMS GC动作，虽然CMS GC不会进行内存碎片的压缩整理，但它会合并老年代中相邻的free空间。这样就可以容纳更多的年轻代晋升行为。</p></blockquote><p>   <strong>适用场景</strong>：</p><p>​       1、与用户交互多的场景，注重服务的响应速度，常见于WEB、B/S系统的服务器上的应用。系统停顿时间最短，给用户带来较好的体验。</p><p>7、 <strong>（整堆）G1</strong></p><p><strong>G1收集器运作过程：</strong></p><p><strong>第一步、初始标记（Initial Marking）</strong>：仅标记一下GC Roots能直接关联到的对象；且修改TAMS（Next Top at Mark Start）,让下一阶段并发运行时，用户程序能在正确可用的Region中创建新对象；<strong>需要”Stop The World”，但速度很快</strong>；</p><p><strong>第二步、并发标记（Concurrent Marking）</strong>：   进行GC Roots Tracing的过程； 刚才产生的集合中标记出存活对象；耗时较长，但应用程序也在运行；并不能保证可以标记出所有的存活对象；</p><p><strong>第三步、最终标记（Final Marking）</strong>：   为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录； 上一阶段对象的变化记录在线程的Remembered Set Log；这里把Remembered Set Log合并到Remembered Set中； <strong>需要”Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短</strong>；<strong>采用多线程并行执行来提升效率</strong>。</p><p><strong>第四步、筛选回收（Live Data Counting and Evacuation）</strong>：   首先<strong>排序各个Region的回收价值和成本</strong>； <strong>然后根据用户期望的GC停顿时间来制定回收计划</strong>； 最后按计划回收一些价值高的Region中垃圾对象；</p><p>回收时采用”复制”算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中压缩和释放内存；</p><p> 可以并发进行，降低停顿时间，并增加吞吐量；</p><p><img src="/2020/10/04/一文就让你精通JVM/20170102225017799.png" alt="img"></p><p>​       <strong>特点</strong>：</p><p>​       1、充分利用多CPU的硬件优势，通过并行缩短STW时间，通过并发让用户线程同时进程。</p><p>​       2、能独立管理整个堆（年轻代和老年代）</p><p>​       3、结合多种垃圾收集算法，整体上基于标记-整理算法，局部Region间基于复制算法。不会产生内存碎片。</p><p>​       4、可预测的停顿，低停顿，高吞吐。</p><p>​      </p><p>​       <strong>适用场景</strong>：</p><p>​       针对具有大内存、多处理器机器的服务端应用。可提供低GC停顿的能力。</p><h1 id="4、GC调优"><a href="#4、GC调优" class="headerlink" title="4、GC调优"></a>4、GC调优</h1><h2 id="4-1、GC调优的目标内存区"><a href="#4-1、GC调优的目标内存区" class="headerlink" title="4.1、GC调优的目标内存区"></a>4.1、GC调优的目标内存区</h2><p><img src="/2020/10/04/一文就让你精通JVM/image-20201003160844073.png" alt="image-20201003160844073"></p><ul><li>一般都针对年轻代、老年代调优，<strong>尤其是老年代</strong>。</li><li>方法区可以进行GC，但一般不操心方法区的GC，因为GC的性价比太低，主要回收“废弃常量和无用的类”。如果内存不够就扩大吧。JDK8方法区的实现为元空间，元空间使用的是本地内存（非堆内存），默认情况下元空间的大小是无限的。</li></ul><h2 id="4-2、GC调优的策略"><a href="#4-2、GC调优的策略" class="headerlink" title="4.2、GC调优的策略"></a>4.2、GC调优的策略</h2><blockquote><p>常见的招数，一招招使</p><p>注：一定是先找1台机器进行试验，对比，然后再做出选择，发布生产环境。</p></blockquote><p><strong>4.3.1、大多数的Java应用不需要GC调优</strong></p><ul><li>大部分需要GC调优的，不是JVM参数问题，是代码问题。</li><li>在实际情况中，基于GC情况优化代码比优化GC参数要多得多。</li></ul><p><strong>4.2.2、（选择合适的GC收集器）互联网Web应用考虑CMS收集器，提升交互响应性能</strong></p><ul><li>GC低停顿：CMS收集器是与用户线程并发的内存垃圾收集器；</li><li>大幅减少FullGC：CMS GC是concurrent GC，是周期性主动的回收内存。大幅减少FullGC的发生。</li></ul><p><strong>4.2.3、（选择合适的堆大小） 去设置堆大小，别不设置用默认的</strong></p><ul><li>拍脑袋定初始参数 -&gt; 运行JVM -&gt; 查监控 -&gt; 调整JVM -&gt; 查监控 -&gt; 反复试验 -&gt; 确认JVM参数</li></ul><p><strong>4.2.4、（选择合适的年轻代比重）年轻代尽量大</strong></p><ul><li>年轻代 尽量大，那么可以减少YoungGC。进而减少了对象进入老年代的频率,进而减少FullGC的频率。</li></ul><p><strong>4.2.5、-XX:MaxTenuringThreshold 合理年轻代对象晋升进入老年代的年龄</strong></p><ul><li>-XX:MaxTenuringThreshold 设置年轻代对象进入老年代的年龄大小，减少老年代的内存占用，降低 FullGC 发生的频率</li></ul><p><strong>4.3.6、（小心大对象）避免大对象直接进入老年代</strong></p><ul><li><p>怎么应对/避免？</p><ul><li>一：-XX:+PretenureSizeThreshold 控制<ul><li>设置-XX:+PretenureSizeThreshold 参数：代表超过这个值的时候，对象直接在old区分配内存。默认值是0，代表不管新对象多大都是先在eden中分配内存。</li><li>注意：PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。</li></ul></li><li>二：更大的年轻代，含：eden区、survivor区<ul><li>eden区能申请的到，就不会去old区申请了。同时可适当调高-XX:MaxTenuringThreshold（Linux 64下，默认15），让大对象在年轻代生，在年轻代亡。</li><li>同时，可考虑搭配最小堆大小和最大堆大小，并设置MinHeapFreeRatio或MaxHeapFreeRatio来掌控堆大小的按需扩大与收缩。</li></ul></li></ul></li></ul><h2 id="4-3、GC调优分析工具"><a href="#4-3、GC调优分析工具" class="headerlink" title="4.3、GC调优分析工具"></a>4.3、GC调优分析工具</h2><p>发现JVM内存问题以及查看对应GC情况是简单的</p><ul><li>（原始一点的）登录到服务器上敲命令：jstat、jmap、jstack。</li><li>（常见的）登录公司运维平台查看指标情况：Grafana、容器管理平台等</li><li>（辅助工具型的）APM工具，如：pinpoint。</li></ul><p><strong>pinpoint：</strong></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004145438049.png" alt="image-20201004145438049"></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004145634898.png" alt="image-20201004145634898"></p><p><strong>Grafana：</strong></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004145721175.png" alt="image-20201004145721175"></p><p>一般我们能从统计图表里<strong>快速的看到问题</strong>现象，例如：</p><ul><li>FullGC频繁；</li><li>年轻代占用比例不高，但老年代会有规律性FullGC；</li><li>……</li></ul><p>然后，进一步<strong>定位GC现象发生的原因和具体代码位置</strong>，是需要些技术分析能力和不断试验的。</p><p>这里我们需要用工具来帮我们高效的定位问题。</p><p><strong>常用工具</strong>：</p><blockquote><p>使用顺序：</p><p>1、dump JVM堆</p><p>2、用工具load dump后的文件，通过工具查看内存占用Top的对象，通过对象Class声明或Reference找到代码位置。</p></blockquote><p><strong>1、JProfiler（推荐）（功能很强大；需付费）</strong></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004141701029.png" alt="image-20201004141701029" style="zoom:40%;" align="left"></p><ul><li><p>软件下载地址：<a href="https://www.ej-technologies.com/products/jprofiler/overview.html" target="_blank" rel="noopener">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p></li><li><p>IntelliJ IDEA有插件版本</p></li></ul><p><strong>例图</strong>：</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004144703464.png" alt="image-20201004144703464"></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004144713940.png" alt="image-20201004144713940"></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004144723484.png" alt="image-20201004144723484"></p><p><strong>2、JVisualVM</strong>（免费）</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004141748324.png" alt="image-20201004141748324" style="zoom:40%;" align="left"></p><ul><li><p>软件下载地址：<a href="http://visualvm.github.io/index.html" target="_blank" rel="noopener">http://visualvm.github.io/index.html</a></p></li><li><p>IntelliJ IDEA有插件版本</p></li><li>使用指导贴：<a href="https://www.cnblogs.com/happy-rabbit/p/6232581.html" target="_blank" rel="noopener">https://www.cnblogs.com/happy-rabbit/p/6232581.html</a></li></ul><p><strong>例图：<img src="/2020/10/04/一文就让你精通JVM/image-20201004144918722.png" alt="image-20201004144918722"></strong></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004144929718.png" alt="image-20201004144929718"></p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004144951229.png" alt="image-20201004144951229"></p><h2 id="4-4、GC调优的问题举例"><a href="#4-4、GC调优的问题举例" class="headerlink" title="4.4、GC调优的问题举例"></a>4.4、GC调优的问题举例</h2><h1 id="5、监控指标怎么看"><a href="#5、监控指标怎么看" class="headerlink" title="5、监控指标怎么看"></a>5、监控指标怎么看</h1><h2 id="5-1、Heap-amp-Non-Heap"><a href="#5-1、Heap-amp-Non-Heap" class="headerlink" title="5.1、Heap &amp; Non-Heap"></a>5.1、Heap &amp; Non-Heap</h2><blockquote><p>以JDK8及以后为背景</p></blockquote><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004195603358.png" alt="image-20201004195603358"></p><center>例图来自Grafana</center><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004202053909.png" alt="image-20201004202053909"></p><center>例图来自JProfiler</center><p><strong>5.1.1、Heap Memory  =  堆内存</strong></p><p>​    看完之前章节，应熟悉堆内存包含什么。这里不再赘述。</p><p><strong>5.1.2、Non-Heap Memory  =  非堆内存</strong></p><p>如果non-heap使用上升趋势，我们应该关注什么呢？</p><p>non-heap（非堆内存）指Java进程内存中，JVM 堆内存范围以外的内存。不清楚的同学，复习上文第2章节：《JVM体系结构》</p><p>那么，non-heap（非堆内存）主要包含哪些内容呢？</p><p>1、【栈区】：虚拟机栈；本地方法栈；&lt;&lt;&lt;&lt; 这块基本不用操心。也不会持续增大。</p><p>2、【方法区】； &lt;&lt;&lt;&lt; 存在持续增大的可能，见本文《怎么构造方法区OOM》</p><p>3、【Native Memory】； &lt;&lt;&lt;&lt; 一般是JNI用到的内存，可能是频繁NIO导致大量Direct Buffer；也可能是内存未管理好，持续泄露内存了。</p><p>4、【Code Cache】：&lt;&lt;&lt;&lt; 用于编译和保存本地代码的内存。JVM内部处理或优化。一般不操心。</p><h1 id="6、JVM类加载器"><a href="#6、JVM类加载器" class="headerlink" title="6、JVM类加载器"></a>6、JVM类加载器</h1><h2 id="6-1、类加载过程"><a href="#6-1、类加载过程" class="headerlink" title="6.1、类加载过程"></a>6.1、类加载过程</h2><p>类加载的7个步骤:</p><ul><li>装载。根据查找路径找到相应的 class 文件，然后导入。</li><li>验证，检查待加载的 class 文件的正确性。《《《链接的 3 小步</li><li>准备，给类中的静态变量分配存储空间。《《《链接的 3 小步</li><li>解析，将符号引用转换为直接引用(这一步可选)。《《《链接的 3 小步</li><li>初始化。对静态变量和静态代码块执行初始化工作。</li><li>使用</li><li>卸载</li></ul><p>类的加载方式分为隐式加载和显示加载。</p><ul><li>隐式加载指的是程序在使 用 new 等方式创建对象时，会隐式地调用类的加载器把对应的类 加载到 JVM 中。</li><li>显示加载指的是通过直接调用 class.forName() 方法来把所需的类加载到 JVM 中。</li></ul><blockquote><p>1、Class.forName 和 ClassLoader.loadClass 都能加载类，这两者在加载类时的区别？</p><p>Class.forName有重载方法可以指定是否需要初始化，而默认的方法初始化设置为true这会初始化类执行链接和初始化操作</p><p>ClasaLoader是有类加载器的loadClass方法加载，传入的是false，只会执行连接操作，不会初始化操作</p></blockquote><p>类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行 时对内存的开销。</p><p>此外，在 Java 语言中，每个类或接口都对应一 个 .class 文件，这些文件可以被看成是一个个可以被动态加载的</p><p>单元，<strong>因此当只有部分类被修改时，只需要重新编译变化的类即可， 而不需要重新编译所有文件</strong>，因此加快了编译速度。</p><h2 id="6-2、类加载器的种类"><a href="#6-2、类加载器的种类" class="headerlink" title="6.2、类加载器的种类"></a>6.2、类加载器的种类</h2><p>在Java中，类加载器主要有下面四种：</p><ul><li>BootstrapClassLoader：启动类加载器，使用C++实现；</li><li>ExtClassLoader：扩展类加载器，使用Java实现；</li><li>AppClassLoader：应用程序类加载器，加载当前应用的classpath的所有类；</li><li>UserDefinedClassLoader：用户自定义类加载器；</li></ul><p><img src="/2020/10/04/一文就让你精通JVM/Users/chenjie/Documents/笔记中转区/周报/《一文就让你精通JVM》.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlaXhpYW9odWFp,size_16,color_FFFFFF,t_70.png" alt="img"></p><h2 id="6-3、双亲委派机制"><a href="#6-3、双亲委派机制" class="headerlink" title="6.3、双亲委派机制"></a>6.3、双亲委派机制</h2><p>类加载器的加载过程中使用到了双亲委派机制：当一个类收到了类加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器(BootstrapClassLoader)中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。</p><p>好处：</p><p>比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。</p><h2 id="6-4、沙箱安全机制"><a href="#6-4、沙箱安全机制" class="headerlink" title="6.4、沙箱安全机制"></a>6.4、沙箱安全机制</h2><p>沙箱安全机制是由基于双亲委派机制上采取的一种JVM的自我保护机制，假设我们自定了一个java.lang.String 的类，由于双亲委派机制，加载请求会先交给BootstrapClassLoader启动类加载器试图去进行加载，但是BootstrapClassLoader在加载类时首先通过包和类名查找rt.jar中有没有java.lang.String，有则优先加载rt.jar包中的类，由于rt.jar中已经包含了java.lang.String类，所以我们自定义的String类永远得不到加载(当然编译是不会报错的)，它保证了Java源代码的安全。</p><h1 id="7、其他独立知识点"><a href="#7、其他独立知识点" class="headerlink" title="7、其他独立知识点"></a>7、其他独立知识点</h1><h2 id="7-1、内存逃逸分析"><a href="#7-1、内存逃逸分析" class="headerlink" title="7.1、内存逃逸分析"></a>7.1、内存逃逸分析</h2><ul><li>见本文《2.4.3、堆内存区 - 逃逸分析》章节</li></ul><h2 id="7-2、直接内存"><a href="#7-2、直接内存" class="headerlink" title="7.2、直接内存"></a>7.2、直接内存</h2><ul><li>见本文《2.4.6、堆外内存区》章节</li></ul><h2 id="7-3、Java内存屏障"><a href="#7-3、Java内存屏障" class="headerlink" title="7.3、Java内存屏障"></a>7.3、Java内存屏障</h2><p><strong>7.3.1、什么是内存屏障（Memory Barrier）？</strong><br>     内存屏障（memory barrier）是一个CPU指令。</p><p>​     通过在代码中插入这样一条指令可达到几种目的效果：</p><p>作用一：干预编译器的指令重排行为，确保内存屏障前后的代码指令有严格的先后执行顺序。</p><p>作用二：内存屏障的另一个作用是强制更新一次不同CPU的缓存。以此来主动影响一些数据的可见性。</p><blockquote><p>例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p></blockquote><p><strong>7.3.2、为什么需要内存屏障</strong><br>    在多CPU（核）场景下，为了充分利用CPU，会通过流水线将指令并行进行。为了能并行执行，又需要将指令进行重排序以便进行并行执行，那么问题来了，那些指令不是在所有场景下都能进行重排，除了本身的一些规则（如Happens Before 规则）之外，我们还需要确保多CPU的高速缓存中的数据与内存保持一致性, 不能确保内存与CPU缓存数据一致性的指令也不能重排，<strong>内存屏障正是通过阻止屏障两边的指令重排序来避免编译器和硬件的不正确优化而提出的一种解决办法</strong>。</p><p><strong>7.3.3、Java中内存屏障的主要类型</strong><br>Java内存屏障主要有Load和Store两类。 </p><p>对Load Barrier来说，在读指令前插入读屏障，<strong>可以让高速缓存中的数据失效，重新从主内存加载数据</strong> 。</p><p>对Store Barrier来说，在写指令之后插入写屏障，<strong>能让写入缓存的最新数据写回到主内存</strong>。</p><p>对于Load和Store，在实际使用中，又分为以下四种：</p><p>1、LoadLoad 屏障：序列：Load1，Loadload，Load2 。</p><blockquote><p>确保Load1所要读入的数据能够在被Load2和后续的load指令访问前读入。通常能执行预加载指令或/和支持乱序处理的处理器中需要显式声明Loadload屏障。</p></blockquote><p>2、StoreStore 屏障：序列：Store1，StoreStore，Store2 。</p><blockquote><p>确保Store1的数据在Store2以及后续Store指令操作相关数据之前<strong>对其它处理器可见</strong>（例如向主存刷新数据）。</p></blockquote><p>3、LoadStore 屏障：序列： Load1，LoadStore， Store2 。</p><blockquote><p>确保Load1的数据在Store2和后续Store指令<strong>被刷新之前读取</strong>。在等待Store指令可以越过loads指令的乱序处理器上需要使用LoadStore屏障。</p></blockquote><p>4、StoreLoad 屏障：序列: Store1，StoreLoad， Load2 。</p><blockquote><p>确保Store1的数据在被Load2和后续的Load指令读取之前<strong>对其他处理器可见</strong>。</p></blockquote><p><strong>7.3.4、Java中内存屏障的使用</strong></p><p><strong>1、Synchronized</strong></p><p>通过 Synchronized关键字包住的代码区域，当线程进入到该区域读取变量信息时，JVM保证读到的是最新的值。这是因为在同步区内对变量的写入操作，在离开同步区时就将当前线程内的数据刷新到内存中，而对数据的读取也不能从缓存读取，只能从内存中读取，保证了数据的读有效性。这就是插入了StoreStore屏障</p><p><strong>2、volatile</strong></p><p>知识点：如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p>使用了volatile修饰变量，则对变量的写操作，会插入StoreLoad屏障。</p><blockquote><p>大致过程：</p><p>1、在volatile变量的作用域插入内存屏障，防止指令重排序</p><p>2、通过内存屏障，强制将本CPU的修改操作立即写入主存。此时会利用缓存一致性机制，组织多个CPU同时刷主存的此数据区域。</p><p>3、本CPU回写volatile字段数据到主存后，其他CPU的嗅探技术会发现此字段已被回写过主存了，其他CPU的嗅探技术会将它的字段缓存设置为无效，其他CPU下次访问此字段时没，会强制从主存读最新值。</p></blockquote><p><strong>3、Unsafe类</strong></p><p>UNSAFE.putOrderedObject类似这样的方法,会插入StoreStore内存屏障 </p><p>Unsafe.putVolatiObject 则是插入了StoreLoad屏障</p><h2 id="7-4、Java的平台无关性"><a href="#7-4、Java的平台无关性" class="headerlink" title="7.4、Java的平台无关性"></a>7.4、Java的平台无关性</h2><ul><li>Java的平台无关性(一次编译、到处运行)得益于：<ul><li>1、统一的Class字节码文件格式；</li><li>2、统一的JVM 规范 (指令集，内存模型，操作数栈架构)；</li></ul></li><li>JVM将平台相关性的活给干了，屏蔽了差异。</li><li>JVM不止有”平台无关性”，还有”语言无关性”，只要最终能编译成符合Class字节码文件格式规范要求的，都能在JVM上运行。如：Coljure, Groovy, JRuby, Scala等</li></ul><h2 id="7-5、Java对象引用类型"><a href="#7-5、Java对象引用类型" class="headerlink" title="7.5、Java对象引用类型"></a>7.5、Java对象引用类型</h2><p>对象引用类型分为强引用、软引用、弱引用、虚引用。</p><ul><li><strong>强引用</strong>：就是我们一般声明对象时是虚拟机生成的引用，强引用环境下，垃圾回收时需要严格判断当前对象是否被强引用，如果被强引用，则不会被垃圾回收。<strong>对应到我们日常写的代码</strong>。</li><li><strong>软引用</strong>：软引用一般被<strong>作为缓存来使用</strong>。与强引用的区别是，软引用在垃圾回收时，<strong>虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收</strong>。如果剩余内存紧张，则虚拟机会回收软引用所引用的空间。 </li><li><strong>弱引用</strong>：弱引用与软引用类似，都是<strong>作为缓存来使用</strong>。但与软引用不同，弱引用在进行<strong>垃圾回收时，是一定会被回收掉</strong>的，因此其生命周期只存在于一个垃圾回收周期内。 <ul><li>“软引用”和“弱引用”比较少见。 他们一般被作为缓存使用，而且一般是在内存大小比较受限的情况下做为缓存。因为如果内存足够大的话，可以直接使用强引用作为缓存即可，同时可控性更高。</li></ul></li><li><strong>虚引用</strong>：使用虚引用的目的就是为了得知对象被GC的时机，可以利用虚引用来进行销毁前的一些操作，比如说资源释放等。虚引用一个很重要的用途就是用来做堆外内存的释放，<strong>DirectByteBuffer就是通过虚引用来实现堆外内存的释放的</strong>。</li></ul><h2 id="7-6-、容器化环境中的JVM内存设置须知"><a href="#7-6-、容器化环境中的JVM内存设置须知" class="headerlink" title="7.6 、容器化环境中的JVM内存设置须知"></a>7.6 、容器化环境中的JVM内存设置须知</h2><p>在JDK10前，JVM是无法感知容器环境存在的，JVM获取到的有关系统硬件的指标都是实际物理机的CPU和内存指标。这其实对于JVM运行环境来说是不合理的。</p><p>Java在JDK10以后，开始了对容器资源限制的支持（支持向linux cgroup获取容器内的硬件资源指标），可以使用<strong>-XX:+UseContainerSupport</strong>参数来指定JVM使用容器的内存指标，注：此参数是JVM内默认开启的。（其他类似的JVM还有：-XX:InitialRAMPercentage； -XX:MaxRAMPercentage等）</p><p>值得庆幸的是，其中一些功能已被移植到JDK-8u131及以后的版本。在JDK-8u131+及java9，需要加上”-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap”才能使得Xmx感知docker的memory limit。</p><p>我们知道JVM对于CPU和内存都有默认取值逻辑，且这个对于JVM的运行性能影响非常大。这个值设置的不对会严重影响线上应用的可用性和性能。</p><p><img src="/2020/10/04/一文就让你精通JVM/image-20201004210626874.png" alt="image-20201004210626874"></p><p><u>推荐</u>：</p><p>建议大家部署Java应用时，必须设置明确的”Xms,Xmx”。减少外部依赖或假设，以减少未知风险的发生概率。</p><h2 id="7-7、怎么构造方法区OOM？"><a href="#7-7、怎么构造方法区OOM？" class="headerlink" title="7.7、怎么构造方法区OOM？"></a>7.7、怎么构造方法区OOM？</h2><p>先牢记知识点方法区存的是哪些东西：“<strong>已被虚拟机加载</strong>的类信息、常量、静态变量、编译器编译后的代码等数据”</p><p><strong>观察这些存放的信息里，哪几个在JVM运行期是动态的？</strong></p><ul><li>运行期产生大量的动态类。</li><li>持续高频使用String.intern()方法，产生大量常量。</li></ul><p><strong>怎么优化？</strong></p><ul><li>通过工具查看方法区大量的动态类的来源代码。</li><li>一般方法区的溢出是由于大量的动态类，而动态类往往来自于框架或三发SDK。基本没的干预，所以一般是调大方法区大小。</li></ul><h2 id="7-8、怎么构造Java内存泄露"><a href="#7-8、怎么构造Java内存泄露" class="headerlink" title="7.8、怎么构造Java内存泄露"></a>7.8、怎么构造Java内存泄露</h2><p>Java 中的内存泄露的情况:<strong>长生命周期的对象持有短生命周期对象的引用</strong>就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是<strong>因为长生命周期对象持有它的引用而导致不能被回收</strong>，这 就是 Java 中内存泄露的发生场景</p><p>例如</p><ul><li>缓存系统，我们加载了一个对 象放在缓存中 (例如放在一个全局 map 对象中)，然后一直不再 使用它，这个对象一直被缓存引用，但却不再被使用。</li><li>如果一个外部类的实例对象的方法返回了一个内部类的实例对象， 这个内部类对象被长期引用了，即使那个外部类实例对象不再被使 用，但由于内部类持久外部类的实例对象，这个外部类对象将不会 被垃圾回收，这也会造成内存泄露。</li><li>内存泄露的另外一种情况:当一个对象被存储进 HashSet 集合中 以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否 则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希 值就不同了，在这种情况下，即使在 contains 方法使用该对象的 当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不 到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前 对象，造成内存泄露。</li></ul><center><font size="8" face="微软雅黑"> &gt;&gt;&gt;&gt; 更多内容，很快到来 &lt;&lt;&lt;&lt; </font></center>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《一文就让你精通JVM》&quot;&gt;&lt;a href=&quot;#《一文就让你精通JVM》&quot; class=&quot;headerlink&quot; title=&quot;《一文就让你精通JVM》&quot;&gt;&lt;/a&gt;《一文就让你精通JVM》&lt;/h1&gt;&lt;p&gt;网上有关JVM的知识贴多如牛毛，其中有纷杂的零碎知识贴，也有整理优秀的长贴。信息量非常充分。&lt;/p&gt;
&lt;p&gt;但作为复习或整理JVM知识的而言，还可以有更好的学习用户体验和高效的方式。因此，就想尝试写一篇有关JVM知识点的“秘籍”，让初学者仅读此文就能快速精通JVM的知识脉络以及关键知识，也能让复习着快速反查知识和经验之谈。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;黄老师&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://veryjj.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://veryjj.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API命名规范</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API命名规范/</id>
    <published>2018-09-30T09:46:20.000Z</published>
    <updated>2020-10-05T14:14:57.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API命名规范"><a href="#API命名规范" class="headerlink" title="API命名规范"></a>API命名规范</h1><h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h2><hr><h3 id="面向资源"><a href="#面向资源" class="headerlink" title="面向资源"></a>面向资源</h3><blockquote><p>同RESTful命名风格</p></blockquote><p>在大型系统中，常以”业务领域”视角进行模块划分，以达到业务”高内聚低耦合”的效果。</p><p>“业务领域”必有”数据对象”沉淀，<code>从宏观抽象的角度看，&quot;数据对象&quot;可统称为&quot;资源&quot;</code>，”业务领域”就是业务相近的”资源”的集合。</p><a id="more"></a><p><code>&quot;资源&quot;一定是业务抽象后的对象</code>：</p><ol><li>可以是具体的数据对象：<ul><li>商品</li><li>订单</li><li>合同</li><li>发票</li><li>采购计划</li><li>etc</li></ul></li><li>可以是抽象的对象概念：<ul><li>租户</li><li>用户</li><li>支付</li><li>文件</li><li>需求</li><li>etc</li></ul></li></ol><p><code>&quot;业务领域&quot;与&quot;业务领域&quot;之间的依赖，可理解为是对&quot;资源&quot;操作(读、写、通知)的依赖。</code></p><p><code>所以，API作为&quot;业务领域&quot;间沟通的手段，其应该(Should)以面向资源角度进行命名。</code></p><p>注：子资源，需要逐级索引命名，例如：修改-订单-商品：updateOrderItem。</p><hr><h3 id="单一视角"><a href="#单一视角" class="headerlink" title="单一视角"></a>单一视角</h3><ul><li>参见<a href="">单一视角原则</a></li></ul><hr><h3 id="动宾风格"><a href="#动宾风格" class="headerlink" title="动宾风格"></a>动宾风格</h3><p>API应该(Should)以<code>&quot;动宾短语&quot;风格命名</code>。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xxx.xxx.xxx.OrderService            // 上下文已涵盖Order语义</span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; save(...)   </span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; updateItem(Long orderId, List&lt;T&gt; items)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xxx.xxx.xxx.WCService               // 上下文未涵盖Order语义</span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; saveOrder(...)   </span><br><span class="line"></span><br><span class="line">Response&lt;Boolean&gt; removeOrder(Long orderId)   </span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; updateOrderItem(Long orderId, List&lt;T&gt; items) // 逐级索引子资源</span><br></pre></td></tr></table></figure><hr><h3 id="统一术语"><a href="#统一术语" class="headerlink" title="统一术语"></a>统一术语</h3><p>API命名统一”动词”术语、”名词”术语。优点是能风格一致，经验复用。</p><p>详见<a href="">政采云API术语参考</a></p><p>注：统一术语的节奏，参考研发级术语规范逐步执行：业务内统一、业务领域内统一、平台统一。</p><h5 id="错误实践-1：”商品”命名不统一"><a href="#错误实践-1：”商品”命名不统一" class="headerlink" title="错误实践-1：”商品”命名不统一"></a>错误实践-1：”商品”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">业务1：商品 -&gt; item ✔️</span><br><span class="line">业务2：商品 -&gt; items</span><br><span class="line">业务3: 商品 -&gt; product</span><br><span class="line">业务4：商品 -&gt; goods</span><br></pre></td></tr></table></figure><h5 id="错误实践-2：”特性”命名不统一"><a href="#错误实践-2：”特性”命名不统一" class="headerlink" title="错误实践-2：”特性”命名不统一"></a>错误实践-2：”特性”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：特性 -&gt; feature ✔️</span><br><span class="line">业务2: 特性 -&gt; character</span><br><span class="line">业务3：特性 -&gt; rule</span><br></pre></td></tr></table></figure><h5 id="错误实践-3：”金额”命名不统一"><a href="#错误实践-3：”金额”命名不统一" class="headerlink" title="错误实践-3：”金额”命名不统一"></a>错误实践-3：”金额”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：金额 -&gt; amount ✔️</span><br><span class="line">业务2: 金额 -&gt; money</span><br><span class="line">业务3：金额 -&gt; sum</span><br></pre></td></tr></table></figure><h5 id="错误实践-4：”校验”命名不统一"><a href="#错误实践-4：”校验”命名不统一" class="headerlink" title="错误实践-4：”校验”命名不统一"></a>错误实践-4：”校验”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：校验 -&gt; verify</span><br><span class="line">业务2: 校验 -&gt; check ✔️</span><br><span class="line">业务3：校验 -&gt; test</span><br></pre></td></tr></table></figure><h5 id="错误实践-5：”分页”命名不统一"><a href="#错误实践-5：”分页”命名不统一" class="headerlink" title="错误实践-5：”分页”命名不统一"></a>错误实践-5：”分页”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：分页 -&gt; page</span><br><span class="line">业务2: 分页 -&gt; paging✔️</span><br><span class="line">业务3：分页 -&gt; list</span><br></pre></td></tr></table></figure><h5 id="错误实践-6：”创建”命名不统一"><a href="#错误实践-6：”创建”命名不统一" class="headerlink" title="错误实践-6：”创建”命名不统一"></a>错误实践-6：”创建”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：创建 -&gt; save✔️</span><br><span class="line">业务2: 创建 -&gt; create</span><br><span class="line">业务3：创建 -&gt; insert</span><br></pre></td></tr></table></figure><h5 id="错误实践-7：”删除”命名不统一"><a href="#错误实践-7：”删除”命名不统一" class="headerlink" title="错误实践-7：”删除”命名不统一"></a>错误实践-7：”删除”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">业务1：删除 -&gt; delete</span><br><span class="line">业务2: 删除 -&gt; remove✔️</span><br><span class="line">业务3：删除 -&gt; disable </span><br><span class="line">业务3：删除 -&gt; cancel</span><br></pre></td></tr></table></figure><h5 id="错误实践-8：”检索”命名不统一"><a href="#错误实践-8：”检索”命名不统一" class="headerlink" title="错误实践-8：”检索”命名不统一"></a>错误实践-8：”检索”命名不统一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务1：搜索 -&gt; query✔️</span><br><span class="line">业务2: 搜索 -&gt; search</span><br><span class="line">业务3：搜索 -&gt; list</span><br></pre></td></tr></table></figure><hr><h2 id="常见API命名参考"><a href="#常见API命名参考" class="headerlink" title="常见API命名参考"></a>常见API命名参考</h2><blockquote><p>假设：未按资源划分Service(上下文未界定资源域)的情况</p></blockquote><blockquote><p>“XXX”指某一种资源，”xxx”指”XXX”下的子资源</p></blockquote><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;Page&lt;T&gt;&gt; pagingXXX(QueryDTO q)    //用对象包装查询条件</span><br></pre></td></tr></table></figure><ul><li>错误实践    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;Page&lt;T&gt;&gt; pagingXXX(String name, String code, Long orgId, Long creatorId, Integer pageNo, Integer PageSize)</span><br></pre></td></tr></table></figure><p>以上错误实践缺点：<br>1、对于调用方来说，无论以什么条件查询，都需要逐个条件传参<br>2、API对扩展不友好，一旦想增加查询条件，API就不兼容。</p><h3 id="列表查询"><a href="#列表查询" class="headerlink" title="列表查询"></a>列表查询</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;List&lt;T&gt;&gt; listXXX(...)</span><br></pre></td></tr></table></figure><h3 id="获取单个详情"><a href="#获取单个详情" class="headerlink" title="获取单个详情"></a>获取单个详情</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; getXXX(Long id) </span><br><span class="line"></span><br><span class="line">类同条件，用重载</span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; getXXX(String code)</span><br></pre></td></tr></table></figure><ul><li>错误实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; getXXXById(Long id) </span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; getXXXByCode(String code)</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>API契约应该由”API名 + 入参”共同组成，而不是只靠”API名”说明一切。</li><li>API方法支持获取单个详情的方式，可以通过入参字段名自解释。无需再用”By***”来额外标注。</li><li>不带”By***”声明的方法语义上更具有扩展性。</li></ol><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; saveXXX(...)      //参照《阿里巴巴Java编码规范》</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; removeXXX(...)      //参照《阿里巴巴Java编码规范》</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; updateXXX(...)      //参照《阿里巴巴Java编码规范》</span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; updateXXXxxx(...)   //更新主资源下的子资源</span><br></pre></td></tr></table></figure><h3 id="提审"><a href="#提审" class="headerlink" title="提审"></a>提审</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; submitXXX(...)</span><br></pre></td></tr></table></figure><h3 id="审核"><a href="#审核" class="headerlink" title="审核"></a>审核</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; auditXXX(...)</span><br></pre></td></tr></table></figure><h3 id="退回（退回到流程中的某一步）"><a href="#退回（退回到流程中的某一步）" class="headerlink" title="退回（退回到流程中的某一步）"></a>退回（退回到流程中的某一步）</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; returnXXX(...)</span><br></pre></td></tr></table></figure><h3 id="撤销（退回到流程的第一步）"><a href="#撤销（退回到流程的第一步）" class="headerlink" title="撤销（退回到流程的第一步）"></a>撤销（退回到流程的第一步）</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; cancelXXX(...)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;API命名规范&quot;&gt;&lt;a href=&quot;#API命名规范&quot; class=&quot;headerlink&quot; title=&quot;API命名规范&quot;&gt;&lt;/a&gt;API命名规范&lt;/h1&gt;&lt;h2 id=&quot;命名风格&quot;&gt;&lt;a href=&quot;#命名风格&quot; class=&quot;headerlink&quot; title=&quot;命名风格&quot;&gt;&lt;/a&gt;命名风格&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;面向资源&quot;&gt;&lt;a href=&quot;#面向资源&quot; class=&quot;headerlink&quot; title=&quot;面向资源&quot;&gt;&lt;/a&gt;面向资源&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;同RESTful命名风格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在大型系统中，常以”业务领域”视角进行模块划分，以达到业务”高内聚低耦合”的效果。&lt;/p&gt;
&lt;p&gt;“业务领域”必有”数据对象”沉淀，&lt;code&gt;从宏观抽象的角度看，&amp;quot;数据对象&amp;quot;可统称为&amp;quot;资源&amp;quot;&lt;/code&gt;，”业务领域”就是业务相近的”资源”的集合。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="API命名" scheme="https://veryjj.github.io/tags/API%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API错误返回规范</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E9%94%99%E8%AF%AF%E8%BF%94%E5%9B%9E%E8%A7%84%E8%8C%83/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API错误返回规范/</id>
    <published>2018-09-30T09:32:14.000Z</published>
    <updated>2020-10-05T14:14:57.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API错误返回规范"><a href="#API错误返回规范" class="headerlink" title="API错误返回规范"></a>API错误返回规范</h1><h2 id="禁止通过抛异常形式返回API业务错误"><a href="#禁止通过抛异常形式返回API业务错误" class="headerlink" title="禁止通过抛异常形式返回API业务错误"></a>禁止通过抛异常形式返回API业务错误</h2><p>API禁止抛Checked异常，即业务处理上的参数错误、逻辑错误、业务错误等禁止通过抛异常形式返回，应用Response#code, message表达业务错误。</p><p>注：不要逼调用方到处写try{}catch()。</p><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; saveDesposit(...);</span><br></pre></td></tr></table></figure><ul><li>反例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T saveDesposit(...) throws ServiceException, IllegalArgumentException, ValidationException;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="禁止通过抛异常形式返回API业务错误-1"><a href="#禁止通过抛异常形式返回API业务错误-1" class="headerlink" title="禁止通过抛异常形式返回API业务错误"></a>禁止通过抛异常形式返回API业务错误</h2><p>API禁止抛Checked异常，即业务处理上的参数错误、逻辑错误、业务错误等禁止通过抛异常形式返回，应用Response#code, message表达业务错误。</p><p>注：不要逼调用方到处写try{}catch()。</p><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; saveDesposit(...);</span><br></pre></td></tr></table></figure><ul><li>反例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T saveDesposit(...) throws ServiceException, IllegalArgumentException, ValidationException;</span><br></pre></td></tr></table></figure><h2 id="需要调用方做错误细分处理的，API提供方务必一并提供判断工具类"><a href="#需要调用方做错误细分处理的，API提供方务必一并提供判断工具类" class="headerlink" title="需要调用方做错误细分处理的，API提供方务必一并提供判断工具类"></a>需要调用方做错误细分处理的，API提供方务必一并提供判断工具类</h2><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void saveXXX()&#123;</span><br><span class="line">    Response&lt;T&gt; result = xxxWriteService(...)</span><br><span class="line">    if (!result.isSuccess())&#123;</span><br><span class="line">        if (xxxUtils.isBankUnSupport(result.getCode))&#123;   &lt;&lt;&lt;API提供方提供工具类解析code含义，且code含义可持续迭代更新，调用方无感知。</span><br><span class="line">            //银行渠道未开通，需要特殊提示</span><br><span class="line">            ...</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void saveXXX()&#123;</span><br><span class="line">    Response&lt;T&gt; result = xxxWriteService(...)</span><br><span class="line">    if (!result.isSuccess())&#123;</span><br><span class="line">        if (&quot;10101&quot;.equals(result.getCode))&#123;   &lt;&lt;&lt;调用方按API提供方的错误码值做硬编码，代码耦合。</span><br><span class="line">            //银行渠道未开通，需要特殊提示</span><br><span class="line">            ...</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【推荐】API返回可直接显示给用户的中文提示信息"><a href="#【推荐】API返回可直接显示给用户的中文提示信息" class="headerlink" title="【推荐】API返回可直接显示给用户的中文提示信息"></a>【推荐】API返回可直接显示给用户的中文提示信息</h2><p>API失败时，只有API实现方最清楚是什么原因，该怎么提示。那么，请提供对应的提示信息。</p><p>我们系统中存在一些用国际化风格的error message，而当前的国际化实现方式真如你想的那么好用吗？</p><h4 id="error-message国际化原理："><a href="#error-message国际化原理：" class="headerlink" title="error message国际化原理："></a><strong>error message国际化原理：</strong></h4><ul><li>代码中的提示信息国际化配置文件</li></ul><p><img src="/2018/09/30/服务API设计之——API错误返回规范/img-1.png" alt="image-20180930154223074"></p><ul><li>国际化提示原理</li></ul><p><img src="/2018/09/30/服务API设计之——API错误返回规范/img-2.png" alt="image-20180930162340975"></p><p>1) 提示信息国际化的行为发生在Web层，Web层启动时会加载Web层的resources/messages提示信息文件</p><p>2)当REST API需要返回提示信息时，Web会根据HTTP 请求中的Locale值（例如：zh_CN、zh_TW、en_US、es_ES_Traditional_WIN等）来决定返回哪一种语言的提示信息。将errorMessage以此种语言方式返回给浏览器进行提示。</p><p>问题：</p><p>1）在分布式系统中，各个应用按领域自治，其resources/messages只维护了自身业务需要的errorMessage。</p><p>2）当图中C Service 将errorMessage = template.status.not.match 返回给 XX Service，XX Service直接透传给XX Web的情况下，XX Web的resources/messages是不包括template.status.not.match的，所以此errorMessage将无法正确的展示其本应该提示的信息。</p><p>所以，推荐API返回可直接显示给用户的中文提示信息。</p><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(&quot;模板配置正在审核中，请在审核完成后再更新&quot;);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反例： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(&quot;模板管理状态机异常&quot;);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【推荐】返回具备可读性，引导性的错误提示信息"><a href="#【推荐】返回具备可读性，引导性的错误提示信息" class="headerlink" title="【推荐】返回具备可读性，引导性的错误提示信息"></a>【推荐】返回具备可读性，引导性的错误提示信息</h2><ul><li>正例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(&quot;模板配置正在审核中，请在审核完成后再更新&quot;);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反例：</li></ul><p>例1 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(&quot;模板管理状态机异常&quot;);  &lt;&lt;&lt;&lt; 你作为用户，是不是吓一跳？</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Response&lt;Boolean&gt; saveTemplate(...) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;catch(StateMachineException e)&#123;</span><br><span class="line">        log.warn(&quot;...&quot;);</span><br><span class="line">        ...</span><br><span class="line">        return Response.fail(e.getMessage());    &lt;&lt;&lt;&lt; message谁都看不懂，没有任何意义</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;API错误返回规范&quot;&gt;&lt;a href=&quot;#API错误返回规范&quot; class=&quot;headerlink&quot; title=&quot;API错误返回规范&quot;&gt;&lt;/a&gt;API错误返回规范&lt;/h1&gt;&lt;h2 id=&quot;禁止通过抛异常形式返回API业务错误&quot;&gt;&lt;a href=&quot;#禁止通过抛异常形式返回API业务错误&quot; class=&quot;headerlink&quot; title=&quot;禁止通过抛异常形式返回API业务错误&quot;&gt;&lt;/a&gt;禁止通过抛异常形式返回API业务错误&lt;/h2&gt;&lt;p&gt;API禁止抛Checked异常，即业务处理上的参数错误、逻辑错误、业务错误等禁止通过抛异常形式返回，应用Response#code, message表达业务错误。&lt;/p&gt;
&lt;p&gt;注：不要逼调用方到处写try{}catch()。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正例：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Response&amp;lt;T&amp;gt; saveDesposit(...);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;反例：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;T saveDesposit(...) throws ServiceException, IllegalArgumentException, ValidationException;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="错误码" scheme="https://veryjj.github.io/tags/%E9%94%99%E8%AF%AF%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API版本规范</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E7%89%88%E6%9C%AC%E8%A7%84%E8%8C%83/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API版本规范/</id>
    <published>2018-09-30T09:32:07.000Z</published>
    <updated>2020-10-05T14:14:57.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API版本规范"><a href="#API版本规范" class="headerlink" title="API版本规范"></a>API版本规范</h1><h2 id="发布RELEASE版本"><a href="#发布RELEASE版本" class="headerlink" title="发布RELEASE版本"></a>发布RELEASE版本</h2><p>正式发布的api包必须是RELEASE版本</p><p>eg.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.gov.zcy.paas.template&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;template-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="版本号风格"><a href="#版本号风格" class="headerlink" title="版本号风格"></a>版本号风格</h2><p>使用 《<a href="https://semver.org/" target="_blank" rel="noopener">Semantic Versioning</a>》风格</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Version号由 “MAJOR.MINOR.PATCH” 三段组合构成，version号增加含义：</p><ol><li>MAJOR version：【主版本号】代表API发生了不兼容的变更，即使是微小的不兼容。</li><li>MINOR version：【次版本号】代表以兼容的方式新增了功能、特性</li><li>PATCH version：【补丁版本号】代表以兼容的方式做了bugfix</li></ol><h3 id="用法-FAQ"><a href="#用法-FAQ" class="headerlink" title="用法 / FAQ"></a>用法 / FAQ</h3><h3 id="版本号以0开始"><a href="#版本号以0开始" class="headerlink" title="版本号以0开始"></a>版本号以0开始</h3><ul><li>X.Y.Z 三个版本号都是以0开始。</li><li>【特别注意】当版本号是 “1.0.9.RELEASE”时，它的下一个补丁版本号是”1.0.10.RELEASE”  ！！！ <ul><li>而不是”1.1.0.RELEASE”，这里不存在满十进位之说。</li></ul></li></ul><h3 id="初始-MAJOR-version"><a href="#初始-MAJOR-version" class="headerlink" title="初始 MAJOR version"></a>初始 MAJOR version</h3><ul><li>初始MAJOR version以0开始，代表业务的初始开发阶段，这过程中功能上任何改变都可能发生，此时的API是不稳定的。</li><li>初始版本一旦发布生产环境，即将MAJOR version变更为1，即 1.0.0.RELEASE。是第一个基线版本。</li></ul><h3 id="预发布版本"><a href="#预发布版本" class="headerlink" title="预发布版本"></a>预发布版本</h3><ul><li>可以通过在补丁版本之后紧跟附加连字符和一系列点分隔标识符来表示预发布版本。标识符必须仅包含ASCII字母数字和连字符[0-9A-Za-z-]。标识符不能为空。数字标识符不得包含前导零。</li><li>预发布版本的优先级低于关联的普通版本。</li><li>预发布版本表示版本不稳定，可能无法满足其关联的正常版本所表示的预期兼容性要求。示例：1.0.0-alpha，1.0.0-alpha.1,1.0.0-0.3.7,1.0.0-x.7.z.92</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;API版本规范&quot;&gt;&lt;a href=&quot;#API版本规范&quot; class=&quot;headerlink&quot; title=&quot;API版本规范&quot;&gt;&lt;/a&gt;API版本规范&lt;/h1&gt;&lt;h2 id=&quot;发布RELEASE版本&quot;&gt;&lt;a href=&quot;#发布RELEASE版本&quot; class=&quot;headerlink&quot; title=&quot;发布RELEASE版本&quot;&gt;&lt;/a&gt;发布RELEASE版本&lt;/h2&gt;&lt;p&gt;正式发布的api包必须是RELEASE版本&lt;/p&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;cn.gov.zcy.paas.template&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;template-api&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;2.1.1.RELEASE&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;版本号风格&quot;&gt;&lt;a href=&quot;#版本号风格&quot; class=&quot;headerlink&quot; title=&quot;版本号风格&quot;&gt;&lt;/a&gt;版本号风格&lt;/h2&gt;&lt;p&gt;使用 《&lt;a href=&quot;https://semver.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Semantic Versioning&lt;/a&gt;》风格&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="API版本" scheme="https://veryjj.github.io/tags/API%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API参数规范</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E5%8F%82%E6%95%B0%E8%A7%84%E8%8C%83/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API参数规范/</id>
    <published>2018-09-30T09:32:03.000Z</published>
    <updated>2020-10-05T14:14:57.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【强制】字段名称用小驼峰风格"><a href="#【强制】字段名称用小驼峰风格" class="headerlink" title="【强制】字段名称用小驼峰风格"></a>【强制】字段名称用小驼峰风格</h3><h3 id="【强制】Service-API返回值必须使用Response包装"><a href="#【强制】Service-API返回值必须使用Response包装" class="headerlink" title="【强制】Service API返回值必须使用Response包装"></a>【强制】Service API返回值必须使用Response包装</h3><ul><li>Service API返回值强制要求进行通用包装，例如：Response。</li><li><p>Response的作用：</p><ol><li>统一方法表示API调用是否成功</li><li>API调用失败时，统一格式反馈错误Code，错误Message</li><li>统一的Response易于调用方经验复用，框架集成</li></ol></li><li><p>作为API调用方，其编码诉求很简单：</p><ol><li>API调用是否成功；</li><li>调用不成功时，提示文案是什么；</li></ol></li><li><p>调用方几不想：</p><ol><li>不想关心API内部有多牛逼</li><li>不想关心API可能会抛的各种Exception，以及因此不得不做各种异常处理</li></ol></li><li><p>关于当前不统一的Response</p><ul><li>【新业务】【强制】使用架构组定义的统一Response：<a href="http://confluence.cai-inc.com/pages/viewpage.action?pageId=6623775" target="_blank" rel="noopener">ZCY Response</a></li><li>目前业务方有自定义Result/Response，风格和作用大同小异。有更好的设计可以自荐给架构组集成，杜绝各自开辟重复的新定义。</li></ul></li></ul><a id="more"></a><h3 id="【强制】杜绝完全不规范的缩写，避免望文不知义。（国际通用缩写除外）"><a href="#【强制】杜绝完全不规范的缩写，避免望文不知义。（国际通用缩写除外）" class="headerlink" title="【强制】杜绝完全不规范的缩写，避免望文不知义。（国际通用缩写除外）"></a>【强制】杜绝完全不规范的缩写，避免望文不知义。（国际通用缩写除外）</h3><ul><li>错误实践<ul><li>AbstractClass“缩写”命名成 AbsClass;</li><li>condition“缩写”命名成 condi；</li><li>此类随意缩写严重降低了代码的可阅读性。</li></ul></li></ul><h3 id="【强制】禁止使用-Map-作为参数类型"><a href="#【强制】禁止使用-Map-作为参数类型" class="headerlink" title="【强制】禁止使用 Map 作为参数类型"></a>【强制】禁止使用 Map 作为参数类型</h3><p>Map&lt;K,V&gt;机制非常灵活，但这样的灵活却是负作用巨大。</p><ol><li>Map的数据说明是晦涩的，调用方、实现方之间需要具有隐式的契约解释支持哪些Key，每个Key的Value是什么类型。增加了双方的使用复杂度。</li><li>Map&lt;K,V&gt;不可被校验。加之第1条的使用复杂度，导致使用上非常容易出错。</li><li>用Map类型字段做预留扩展性的设计都是不优雅的设计。</li></ol><p>注：参数中的调用方自定义数据部分允许使用Map。API提供方不关系、不解析、只透传。</p><h3 id="【强制】业务对象-查询条件用DTO封装，禁止以入参方式平铺字段。"><a href="#【强制】业务对象-查询条件用DTO封装，禁止以入参方式平铺字段。" class="headerlink" title="【强制】业务对象/查询条件用DTO封装，禁止以入参方式平铺字段。"></a>【强制】业务对象/查询条件用DTO封装，禁止以入参方式平铺字段。</h3><ul><li>正确实践</li></ul><p>分页查询，将查询条件以DTO方式包装。</p><p>Dubbo序列化特点：</p><ul><li>Dubbo API的POJO类中，UID不一致：没关系。</li><li>Dubbo API的POJO类中，字段数量不一致：没关系，只要字段名和类型一致，数据能反序列化成功。</li><li>发送方比接收方的字段多：没关系。</li><li>发送方比接收方的字段少：没关系。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;Page&lt;T&gt;&gt; pagingXXX(QueryDTO q)</span><br></pre></td></tr></table></figure><ul><li>错误实践    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;Page&lt;T&gt;&gt; pagingXXX(String name, String code, Long orgId, Long creatorId, Integer pageNo, Integer PageSize)</span><br></pre></td></tr></table></figure><p>以上错误实践缺点：<br>1、对于调用方来说，无论以什么条件查询，都需要逐个条件传参。<br>2、API对扩展不友好，一旦想增加查询条件，API就不兼容。</p><h3 id="【推荐】DTO字段设置JSR303-Annotation进行基础校验"><a href="#【推荐】DTO字段设置JSR303-Annotation进行基础校验" class="headerlink" title="【推荐】DTO字段设置JSR303 Annotation进行基础校验"></a>【推荐】DTO字段设置JSR303 Annotation进行基础校验</h3><ul><li>正确实践</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ZcyPayFacade &#123;</span><br><span class="line">    Result&lt;Boolean&gt; validTradePay(@NotNull @Valid TradePayPO tradePayPO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class TradePayPO implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(max = 15)</span><br><span class="line">    /** 业务交易编号(订单编号) */</span><br><span class="line">    private String businessTradeNo;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 业务渠道：1-订阅，2-CA</span><br><span class="line">     * @see BusinessTypeEnum</span><br><span class="line">     *</span><br><span class="line">     * */</span><br><span class="line">    @NotNull</span><br><span class="line">    @Range(min = 1, max = 2)</span><br><span class="line">    private Integer businessType;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    /** 商户名称(商家) */</span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(max = 50)</span><br><span class="line">    private String merchantName;</span><br><span class="line"></span><br><span class="line">    /** 订单标题（即商品名称），粗略描述用户的支付目的。如“喜士多（浦东店）消费”*/</span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(max = 256)</span><br><span class="line">    private String orderSubject;</span><br><span class="line"></span><br><span class="line">    /** 订单描述（即商品描述），可以对交易或商品进行一个详细地描述，比如填写&quot;购买商品2件共15.00元&quot;*/</span><br><span class="line">    @NotBlank</span><br><span class="line">    @Length(max = 128)</span><br><span class="line">    private String orderBody;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【推荐】在客户端完成基础字段校验"><a href="#【推荐】在客户端完成基础字段校验" class="headerlink" title="【推荐】在客户端完成基础字段校验"></a>【推荐】在客户端完成基础字段校验</h3><ul><li>方式1：【推荐】自定义Dubbo Filter实现通用拦截、校验。</li><li>方式2：【推荐】通过Builder模式构建入参对象。</li><li>方式3：【不推荐】Dubbo 客户端参数校验，要求consumer方设置validation=”true”，<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/parameter-validation.html" target="_blank" rel="noopener">Dubbo 客户端参数校验</a>。缺点：以抛异常方式处理校验失败，需要业务方额外处理Exception。而且，IDE并不会提示consumer方需要处理ConstraintViolationException。</li><li>方式4：Dubbo方式，local-stub特性。实现较复杂，校验代码通用性低。<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html" target="_blank" rel="noopener">Dubbo local-stub</a></li></ul><hr><h3 id="注：此规范与《阿里巴巴Java编码规范》互补，同时有效。"><a href="#注：此规范与《阿里巴巴Java编码规范》互补，同时有效。" class="headerlink" title="注：此规范与《阿里巴巴Java编码规范》互补，同时有效。"></a>注：此规范与《阿里巴巴Java编码规范》互补，同时有效。</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【强制】字段名称用小驼峰风格&quot;&gt;&lt;a href=&quot;#【强制】字段名称用小驼峰风格&quot; class=&quot;headerlink&quot; title=&quot;【强制】字段名称用小驼峰风格&quot;&gt;&lt;/a&gt;【强制】字段名称用小驼峰风格&lt;/h3&gt;&lt;h3 id=&quot;【强制】Service-API返回值必须使用Response包装&quot;&gt;&lt;a href=&quot;#【强制】Service-API返回值必须使用Response包装&quot; class=&quot;headerlink&quot; title=&quot;【强制】Service API返回值必须使用Response包装&quot;&gt;&lt;/a&gt;【强制】Service API返回值必须使用Response包装&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Service API返回值强制要求进行通用包装，例如：Response。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Response的作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统一方法表示API调用是否成功&lt;/li&gt;
&lt;li&gt;API调用失败时，统一格式反馈错误Code，错误Message&lt;/li&gt;
&lt;li&gt;统一的Response易于调用方经验复用，框架集成&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;作为API调用方，其编码诉求很简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;API调用是否成功；&lt;/li&gt;
&lt;li&gt;调用不成功时，提示文案是什么；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用方几不想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不想关心API内部有多牛逼&lt;/li&gt;
&lt;li&gt;不想关心API可能会抛的各种Exception，以及因此不得不做各种异常处理&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于当前不统一的Response&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【新业务】【强制】使用架构组定义的统一Response：&lt;a href=&quot;http://confluence.cai-inc.com/pages/viewpage.action?pageId=6623775&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ZCY Response&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;目前业务方有自定义Result/Response，风格和作用大同小异。有更好的设计可以自荐给架构组集成，杜绝各自开辟重复的新定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="API规范" scheme="https://veryjj.github.io/tags/API%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>服务API设计之——API设计原则</title>
    <link href="https://veryjj.github.io/2018/09/30/%E6%9C%8D%E5%8A%A1API%E8%AE%BE%E8%AE%A1%E4%B9%8B%E2%80%94%E2%80%94API%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://veryjj.github.io/2018/09/30/服务API设计之——API设计原则/</id>
    <published>2018-09-30T09:31:47.000Z</published>
    <updated>2020-10-05T14:14:57.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="你是否也感同身受？"><a href="#你是否也感同身受？" class="headerlink" title="你是否也感同身受？"></a>你是否也感同身受？</h2><ol><li>对接XX业务时，XX业务具备的功能和API全靠跑业务负责人那反复逐个询问、确认。用哪个API；怎么用；有没有限制；等等</li><li>各个业务间，甚至同一业务内，API风格不统一。<ul><li>API命名：按自然语义全翻译的；按属性角度定义的；按操作角度定义的；动宾、非动宾的；复数、非复数的；等等</li><li>API入参：带Map的；相同语义字段名称不一样；</li><li>API出参：有包装Resoponse的；直接返回结果数据的；相同数据，返回格式和字段名称有差别的；</li><li>错误信息：直接返回中文提示的；返回提示信息编码的；返回异常类型的；等等</li></ul></li><li>XX业务API性能方面未知。</li><li>随着业务的演进，开放的API持续在增加，但类同的很多</li></ol><a id="more"></a><h5 id="API编码规范迫在眉睫"><a href="#API编码规范迫在眉睫" class="headerlink" title="API编码规范迫在眉睫"></a><strong>API编码规范迫在眉睫</strong></h5><hr><h2 id="优秀API的特质"><a href="#优秀API的特质" class="headerlink" title="优秀API的特质"></a>优秀API的特质</h2><ol><li>自解释<ul><li>从API本身一眼就能看懂API是干什么的，支持的用法，适用的场景，异常的处理等</li></ul></li><li>易学习<ul><li>有完善的文档，以及提供尽可能多的示例和可copy－paste的代码。</li></ul></li><li>易使用<ul><li>功能强大，但使用简单。不增加调用方的使用成本（例如要求业务方用API时需要额外的配置和依赖），不暴露复杂的细节、冗长的使用流程给调用方感知。调用方只做最小的感知和最少的传参。</li></ul></li><li>难误用<ul><li>优秀的API可以使有经验的开发直接使用API而不需要阅读文档。</li><li>充分的静态检查、动态校验、显式的异常说明、有效的错误提示。</li></ul></li></ol><hr><h2 id="ZCY-API-设计原则"><a href="#ZCY-API-设计原则" class="headerlink" title="ZCY API 设计原则"></a>ZCY API 设计原则</h2><h3 id="1-充分原则"><a href="#1-充分原则" class="headerlink" title="1. 充分原则"></a>1. 充分原则</h3><p>不是随便一个功能就要有个接口，也不是随便一个需求就要加个接口。</p><p>每新建一个接口，要有充分的理由和考虑，即这个接口的存在是十分有意义和价值的。无意义的接口不仅增加了维护的难度，更重要是对于程序的可控性的大大降低，接口也会十分臃肿。</p><h3 id="2-单一视角原则"><a href="#2-单一视角原则" class="headerlink" title="2. 单一视角原则"></a>2. 单一视角原则</h3><p>设计接口时，分析的角度要统一。否则会造成接口结构的混乱。例如：不要一会以角色的角度设计，一会儿就要以功能的角度设计。</p><p>推荐：以”属性对象 + 行为”的视角定义API</p><h3 id="3-单一功能原则"><a href="#3-单一功能原则" class="headerlink" title="3. 单一功能原则"></a>3. 单一功能原则</h3><p>每个API接口应该只专注一件事，并做好。产品概念简单、关系清楚。功能模棱两可，诸多特殊逻辑的API肯定不是个优雅的API，且会造成功能类似重复的API。</p><p>注：如果API它很难命名，那么这或许是个不好的征兆，好的名称可以驱动开发、并且只需拆分与合并模块即可。</p><p>功能大而全的API在灵活性、简单性方面肯定捉襟见肘。定义API的粒度之前，建议先将业务分领域、划边界，以此来提取业务对象，然后再根据业务对象用例来设计单一功能的API。</p><p>比如：查询会员，可能除了查询会员表外还要获取该会员的其他必要信息，但不要在查询会员的同时还有修改权限等类似的其他业务功能，应该分成两个接口执行。</p><h3 id="4-简单原则"><a href="#4-简单原则" class="headerlink" title="4. 简单原则"></a>4. 简单原则</h3><p>接口设计简单、清晰。API执行的功能可以很丰富、很强大，但API声明和用法一定要尽量的简单，不能将功能的丰富通过复杂的用法来实现，这会导致API功能不单一，演进不可控。</p><p>最终的评审要看API的简单易用程度。</p><ul><li>你写的例子，能不能让你的代码看起来更简单？</li><li>你是不是强迫调用方关注/提供他们不在乎的选项/配置？</li><li>有没有毫无价值的额外步骤？</li></ul><p>编写的代码一定要易于读、易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</p><h3 id="5-抽象原则"><a href="#5-抽象原则" class="headerlink" title="5. 抽象原则"></a>5. 抽象原则</h3><p>API的入参、出参所述的对象、属性，一定是按业务特性进行抽象后的实体。误将底层数据模型概念如实的反应到API上。抽象API、抽象对象实体更宏观，具有更好的适用性、兼容性、扩展性。</p><h3 id="6-兼容扩展原则"><a href="#6-兼容扩展原则" class="headerlink" title="6. 兼容扩展原则"></a>6. 兼容扩展原则</h3><p>对扩展开放，对修改关闭。保证API的向后兼容。</p><p>扩展参数应当是便利的，保证后续类似的需求，可以在已有的API上通过兼容扩展的方式实现。</p><h3 id="7-最小惊讶原则"><a href="#7-最小惊讶原则" class="headerlink" title="7. 最小惊讶原则"></a>7. 最小惊讶原则</h3><p>代码应该尽可能减少让读者惊喜。业务API只需根据需求来设计即可，不需要刻意去设计一下复杂无用、华而不实的API，以免弄巧成拙。</p><h3 id="8-低耦合原则"><a href="#8-低耦合原则" class="headerlink" title="8. 低耦合原则"></a>8. 低耦合原则</h3><p>API应该减少对其他业务代码的依赖关系。低耦合往往是完美结构系统和优秀设计的标志。</p><p>耦合的种类：</p><ul><li>代码实现业务逆向调用。</li><li>条件逻辑依赖耦合。例如：此API在处理国税网超订单类型时，需要额外发送结算支付凭证上传的事件MQ出来。</li><li>耦合API无关的业务行为。例如：采购计划链路日志API被调用时，若是项目采购委托单的情况，需要额外调用公告的API拉取链路信息，新建成为一条此委托单的一条链路日志。</li></ul><h3 id="9-正交原则"><a href="#9-正交原则" class="headerlink" title="9. 正交原则"></a>9. 正交原则</h3><p>正交性是指改变某个特性而不会影响到其他的特性。</p><p>API之间的功能应该成正交性，无功能重合。API之间应该是互相补充的关系。</p><h3 id="10-易测试原则"><a href="#10-易测试原则" class="headerlink" title="10. 易测试原则"></a>10. 易测试原则</h3><p>对于API调用者而言，API应该是可被测试且易于被测试的。测试API不需要依赖额外的环境、容器、配置、公共服务等。</p><p>对可测试友好的API也是可被有效集成测试的前提。</p><h3 id="11-统一原则"><a href="#11-统一原则" class="headerlink" title="11. 统一原则"></a>11. 统一原则</h3><p>API要具备统一的命名、统一的入/出参规范、统一的异常规范、统一的错误码规范、统一的版本规范等。</p><p>统一规范的API优点：</p><ul><li>易于被框架集成、处理</li><li>有助于API调用方、API提供方开发经验复用</li><li>避免犯错，避免误用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;你是否也感同身受？&quot;&gt;&lt;a href=&quot;#你是否也感同身受？&quot; class=&quot;headerlink&quot; title=&quot;你是否也感同身受？&quot;&gt;&lt;/a&gt;你是否也感同身受？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;对接XX业务时，XX业务具备的功能和API全靠跑业务负责人那反复逐个询问、确认。用哪个API；怎么用；有没有限制；等等&lt;/li&gt;
&lt;li&gt;各个业务间，甚至同一业务内，API风格不统一。&lt;ul&gt;
&lt;li&gt;API命名：按自然语义全翻译的；按属性角度定义的；按操作角度定义的；动宾、非动宾的；复数、非复数的；等等&lt;/li&gt;
&lt;li&gt;API入参：带Map的；相同语义字段名称不一样；&lt;/li&gt;
&lt;li&gt;API出参：有包装Resoponse的；直接返回结果数据的；相同数据，返回格式和字段名称有差别的；&lt;/li&gt;
&lt;li&gt;错误信息：直接返回中文提示的；返回提示信息编码的；返回异常类型的；等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;XX业务API性能方面未知。&lt;/li&gt;
&lt;li&gt;随着业务的演进，开放的API持续在增加，但类同的很多&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="API" scheme="https://veryjj.github.io/tags/API/"/>
    
      <category term="API设计原则" scheme="https://veryjj.github.io/tags/API%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JStorm-分享资料</title>
    <link href="https://veryjj.github.io/2018/09/16/JStorm-%E5%88%86%E4%BA%AB%E8%B5%84%E6%96%99/"/>
    <id>https://veryjj.github.io/2018/09/16/JStorm-分享资料/</id>
    <published>2018-09-16T04:34:33.000Z</published>
    <updated>2020-10-05T14:14:57.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JStorm分享-课件资料"><a href="#JStorm分享-课件资料" class="headerlink" title="JStorm分享-课件资料"></a>JStorm分享-课件资料</h2><p><img src="/2018/09/16/JStorm-分享资料/幻灯片01.png" alt="幻灯片01"></p><a id="more"></a><p><img src="/2018/09/16/JStorm-分享资料/幻灯片02.png" alt="幻灯片02"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片03.png" alt="幻灯片03"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片04.png" alt="幻灯片04"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片05.png" alt="幻灯片05"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片06.png" alt="幻灯片06"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片07.png" alt="幻灯片07"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片08.png" alt="幻灯片08"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片09.png" alt="幻灯片09"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片10.png" alt="幻灯片10"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片11.png" alt="幻灯片11"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片12.png" alt="幻灯片12"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片13.png" alt="幻灯片13"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片14.png" alt="幻灯片14"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片15.png" alt="幻灯片15"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片16.png" alt="幻灯片16"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片17.png" alt="幻灯片17"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片18.png" alt="幻灯片18"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片19.png" alt="幻灯片19"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片20.png" alt="幻灯片20"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片21.png" alt="幻灯片21"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片22.png" alt="幻灯片22"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片23.png" alt="幻灯片23"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片24.png" alt="幻灯片24"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片25.png" alt="幻灯片25"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片26.png" alt="幻灯片26"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片27.png" alt="幻灯片27"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片28.png" alt="幻灯片28"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片29.png" alt="幻灯片29"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片30.png" alt="幻灯片30"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片31.png" alt="幻灯片31"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片32.png" alt="幻灯片32"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片33.png" alt="幻灯片33"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片34.png" alt="幻灯片34"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片35.png" alt="幻灯片35"></p><p><img src="/2018/09/16/JStorm-分享资料/幻灯片36.png" alt="幻灯片36"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JStorm分享-课件资料&quot;&gt;&lt;a href=&quot;#JStorm分享-课件资料&quot; class=&quot;headerlink&quot; title=&quot;JStorm分享-课件资料&quot;&gt;&lt;/a&gt;JStorm分享-课件资料&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/09/16/JStorm-分享资料/幻灯片01.png&quot; alt=&quot;幻灯片01&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大数据" scheme="https://veryjj.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="实时计算" scheme="https://veryjj.github.io/tags/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97/"/>
    
      <category term="JStorm" scheme="https://veryjj.github.io/tags/JStorm/"/>
    
      <category term="Storm" scheme="https://veryjj.github.io/tags/Storm/"/>
    
  </entry>
  
  <entry>
    <title>Spring数据库原理-事务管理</title>
    <link href="https://veryjj.github.io/2018/08/11/Spring%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>https://veryjj.github.io/2018/08/11/Spring数据库原理-事务管理/</id>
    <published>2018-08-11T08:33:54.000Z</published>
    <updated>2020-10-05T14:14:57.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点分解"><a href="#知识点分解" class="headerlink" title="知识点分解"></a>知识点分解</h1><h2 id="核心类对象"><a href="#核心类对象" class="headerlink" title="核心类对象"></a>核心类对象</h2><table><thead><tr><th style="text-align:left">对象</th><th style="text-align:left">一句话介绍</th></tr></thead><tbody><tr><td style="text-align:left">PlatformTransactionManager</td><td style="text-align:left">Spring事务的核心底层interface，定义了事务核心方法</td></tr><tr><td style="text-align:left">AbstractPlatformTransactionManager</td><td style="text-align:left">Spring标准事务处理流程的抽象基类，定义了Spring事务处理框架</td></tr><tr><td style="text-align:left">TransactionDefinition</td><td style="text-align:left">事务属性相关。事务隔离级别；超时；传播行为；等</td></tr><tr><td style="text-align:left">TransactionStatus</td><td style="text-align:left">事务实例状态对象，可供查询，用于回滚、SavePoint等场景</td></tr><tr><td style="text-align:left">DataSourceTransactionManager</td><td style="text-align:left">Spring框架TransactionManager的典型实现</td></tr><tr><td style="text-align:left">TransactionTemplate</td><td style="text-align:left">将编程式上下文多个步骤合并成一个核心的execute方法，方便事务编程</td></tr></tbody></table><p><img src="/2018/08/11/Spring数据库原理-事务管理/image-20180811172416549.png" alt="image-20180811172416549"></p><p><img src="/2018/08/11/Spring数据库原理-事务管理/image-20180811172628386.png" alt="image-20180811172628386"></p><a id="more"></a><h2 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h2><ul><li>jar包</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring事务的核心底层interface，定义了事务核心方法：getTransaction, commit, rollback。</p><h2 id="AbstractPlatformTransactionManager"><a href="#AbstractPlatformTransactionManager" class="headerlink" title="AbstractPlatformTransactionManager"></a>AbstractPlatformTransactionManager</h2><ul><li>jar包</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> Spring标准事务处理流程的抽象基类，定义了Spring事务处理框架。</p><ul><li>AbstractPlatformTransactionManager 利用模板方式定义了Spring标准事务的处理流程，并提供了必须的默认实现，且将doBengin, doSuspend, doResume, doCommit, doRollback等方法开放给继承类实现。</li></ul><p>AbstractPlatformTransactionManager 提供了如下事务流程功能</p><ol><li>确定是否已存在事务</li><li>处理事务传播行为</li><li>控制事务的暂停和恢复</li><li>检查commit上的rollback-only标记</li><li>在回滚时进行必要的处理</li><li>触发已注册的事务同步回调。trigger[Before/After][Begin/Commit/Rollback/…]系列，参见：TransactionSynchronizationUtils。</li></ol><h2 id="DataSourceTransactionManager"><a href="#DataSourceTransactionManager" class="headerlink" title="DataSourceTransactionManager"></a>DataSourceTransactionManager</h2><ul><li>jar包</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring TransactionManager的典型实现类。</p><p>继承了AbstractPlatformTransactionManager类，并做了完整的实现。可供编程式事务开发。也可作为TransactionManager的具体实现注入到如TransactionTemplate， Mybatis SqlSessionFactory中去。</p><h2 id="TransactionTemplate"><a href="#TransactionTemplate" class="headerlink" title="TransactionTemplate"></a>TransactionTemplate</h2><ul><li>jar包</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>TransactionTemplate 提供的是便捷的编程式事务的方法，将编程式上下文多个步骤合并成一个核心的execute方法。</p><p>其本身不具备事务管理的机制，需要通过注入PlatformTransactionManager的Bean实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTemplate</span> <span class="keyword">extends</span> <span class="title">DefaultTransactionDefinition</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">TransactionOperations</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TransactionTemplate</span><span class="params">(PlatformTransactionManager transactionManager)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.transactionManager = transactionManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(TransactionCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.transactionManager <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager) &#123;</span><br><span class="line"><span class="keyword">return</span> ((CallbackPreferringPlatformTransactionManager) <span class="keyword">this</span>.transactionManager).execute(<span class="keyword">this</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">TransactionStatus status = <span class="keyword">this</span>.transactionManager.getTransaction(<span class="keyword">this</span>);</span><br><span class="line">T result;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">result = action.doInTransaction(status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line"><span class="comment">// Transactional code threw application exception -&gt; rollback</span></span><br><span class="line">rollbackOnException(status, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line"><span class="comment">// Transactional code threw error -&gt; rollback</span></span><br><span class="line">rollbackOnException(status, err);</span><br><span class="line"><span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="comment">// Transactional code threw unexpected exception -&gt; rollback</span></span><br><span class="line">rollbackOnException(status, ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(ex, <span class="string">"TransactionCallback threw undeclared checked exception"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.transactionManager.commit(status);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rollbackOnException</span><span class="params">(TransactionStatus status, Throwable ex)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">logger.debug(<span class="string">"Initiating transaction rollback on application exception"</span>, ex);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.transactionManager.rollback(status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line">ex2.initApplicationException(ex);</span><br><span class="line"><span class="keyword">throw</span> ex2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException ex2) &#123;</span><br><span class="line">logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">logger.error(<span class="string">"Application exception overridden by rollback error"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Transactional-声明式事务"><a href="#Transactional-声明式事务" class="headerlink" title="@Transactional 声明式事务"></a>@Transactional 声明式事务</h1><p>理解Spring事务的核心对象和配合关系后，再来看Spring框架的声明式事务机制@Transactional就很简单了。</p><p><img src="/2018/08/11/Spring数据库原理-事务管理/image-20180811192914136.png" alt="image-20180811192914136"></p><p><img src="/2018/08/11/Spring数据库原理-事务管理/image-20180811192224441.png" alt="image-20180811192224441"></p><ol><li>sprint-tx包中的ProxyTransactionManagementConfiguration会去配置关于@Transactional注解的处理机制。其中核心的是注册了TransactionInterceptor作为切面事务处理类</li><li>当执行声明式事务的代码块之前，会优先被TransactionInterceptor拦截，先执行TransactionInterceptor#invoke进行事务包围。<ul><li>TransactionAspectSupport#invokeWithinTransaction</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionInterceptor</span> <span class="keyword">extends</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line"><span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line"><span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line">Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapt to TransactionAspectSupport's invokeWithinTransaction...</span></span><br><span class="line"><span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, <span class="keyword">new</span> InvocationCallback() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceedWithInvocation</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部其他方法详见TransactionAspectSupport源码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line"><span class="keyword">final</span> TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line"><span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line"><span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line"><span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">Object retVal = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line"><span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// target invocation exception</span></span><br><span class="line">completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line">commitTransactionAfterReturning(txInfo);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr,</span><br><span class="line"><span class="keyword">new</span> TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line"><span class="comment">// A RuntimeException: will lead to a rollback.</span></span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ThrowableHolderException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// A normal return value: will lead to a commit.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThrowableHolder(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check result: It might indicate a Throwable to rethrow.</span></span><br><span class="line"><span class="keyword">if</span> (result <span class="keyword">instanceof</span> ThrowableHolder) &#123;</span><br><span class="line"><span class="keyword">throw</span> ((ThrowableHolder) result).getThrowable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ThrowableHolderException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex.getCause();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;知识点分解&quot;&gt;&lt;a href=&quot;#知识点分解&quot; class=&quot;headerlink&quot; title=&quot;知识点分解&quot;&gt;&lt;/a&gt;知识点分解&lt;/h1&gt;&lt;h2 id=&quot;核心类对象&quot;&gt;&lt;a href=&quot;#核心类对象&quot; class=&quot;headerlink&quot; title=&quot;核心类对象&quot;&gt;&lt;/a&gt;核心类对象&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;对象&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;一句话介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;PlatformTransactionManager&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Spring事务的核心底层interface，定义了事务核心方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;AbstractPlatformTransactionManager&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Spring标准事务处理流程的抽象基类，定义了Spring事务处理框架&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;TransactionDefinition&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;事务属性相关。事务隔离级别；超时；传播行为；等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;TransactionStatus&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;事务实例状态对象，可供查询，用于回滚、SavePoint等场景&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;DataSourceTransactionManager&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Spring框架TransactionManager的典型实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;TransactionTemplate&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;将编程式上下文多个步骤合并成一个核心的execute方法，方便事务编程&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&quot;/2018/08/11/Spring数据库原理-事务管理/image-20180811172416549.png&quot; alt=&quot;image-20180811172416549&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/08/11/Spring数据库原理-事务管理/image-20180811172628386.png&quot; alt=&quot;image-20180811172628386&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="https://veryjj.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Spring" scheme="https://veryjj.github.io/tags/Spring/"/>
    
      <category term="数据库事务" scheme="https://veryjj.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring数据库原理-DataSource</title>
    <link href="https://veryjj.github.io/2018/08/11/Spring%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-DataSource/"/>
    <id>https://veryjj.github.io/2018/08/11/Spring数据库原理-DataSource/</id>
    <published>2018-08-11T06:57:39.000Z</published>
    <updated>2020-10-05T14:14:57.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>用Spring进行Web应用开发时，我们经常会做datasource的配置。而且datasource的配法风格各异。那么他们到底有哪些异同点呢？</p><p><img src="/2018/08/11/Spring数据库原理-DataSource/image-20180811151925263.png" alt="image-20180811151925263"></p><p><img src="/2018/08/11/Spring数据库原理-DataSource/image-20180811152018356.png" alt="image-20180811152018356"></p><p><img src="/2018/08/11/Spring数据库原理-DataSource/image-20180811152412438.png" alt="image-20180811152412438"></p><h2 id="DataSource作用"><a href="#DataSource作用" class="headerlink" title="DataSource作用"></a>DataSource作用</h2><p>DataSource是javax.sql包中的类，是Java原生rt.jar包中的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataSource</span>  <span class="keyword">extends</span> <span class="title">CommonDataSource</span>, <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>javax.sql.DataSource定义的是抽象方法，通过Java JNDI的方式将具体实现开放给各个厂商、组织自己、个人自己实现。</p><p>在Spring框架中，通过DataSource + 配置的方式，来定义具体的数据库源。并向Spring框架提供数据源的Connection服务。</p><p>在Spring中若想实现多数据源，那么就需要在DataSource下手。</p><h2 id="javax-sql-DataSource源码注释说明"><a href="#javax-sql-DataSource源码注释说明" class="headerlink" title="javax.sql.DataSource源码注释说明"></a>javax.sql.DataSource源码注释说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;p&gt;A factory for connections to the physical data source that this</span><br><span class="line"> * &#123;@code DataSource&#125; object represents.  An alternative to the</span><br><span class="line"> * &#123;@code DriverManager&#125; facility, a &#123;@code DataSource&#125; object</span><br><span class="line"> * is the preferred means of getting a connection. An object that implements</span><br><span class="line"> * the &#123;@code DataSource&#125; interface will typically be</span><br><span class="line"> * registered with a naming service based on the</span><br><span class="line"> * Java&amp;trade; Naming and Directory (JNDI) API.</span><br><span class="line"> * &lt;P&gt;</span><br><span class="line"> * The &#123;@code DataSource&#125; interface is implemented by a driver vendor.</span><br><span class="line"> * There are three types of implementations:</span><br><span class="line"> * &lt;OL&gt;</span><br><span class="line"> *   &lt;LI&gt;Basic implementation -- produces a standard &#123;@code Connection&#125;</span><br><span class="line"> *       object</span><br><span class="line"> *   &lt;LI&gt;Connection pooling implementation -- produces a &#123;@code Connection&#125;</span><br><span class="line"> *       object that will automatically participate in connection pooling.  This</span><br><span class="line"> *       implementation works with a middle-tier connection pooling manager.</span><br><span class="line"> *   &lt;LI&gt;Distributed transaction implementation -- produces a</span><br><span class="line"> *       &#123;@code Connection&#125; object that may be used for distributed</span><br><span class="line"> *       transactions and almost always participates in connection pooling.</span><br><span class="line"> *       This implementation works with a middle-tier</span><br><span class="line"> *       transaction manager and almost always with a connection</span><br><span class="line"> *       pooling manager.</span><br><span class="line"> * &lt;/OL&gt;</span><br><span class="line"> * &lt;P&gt;</span><br><span class="line"> * A &#123;@code DataSource&#125; object has properties that can be modified</span><br><span class="line"> * when necessary.  For example, if the data source is moved to a different</span><br><span class="line"> * server, the property for the server can be changed.  The benefit is that</span><br><span class="line"> * because the data source&apos;s properties can be changed, any code accessing</span><br><span class="line"> * that data source does not need to be changed.</span><br><span class="line"> * &lt;P&gt;</span><br><span class="line"> * A driver that is accessed via a &#123;@code DataSource&#125; object does not</span><br><span class="line"> * register itself with the &#123;@code DriverManager&#125;.  Rather, a</span><br><span class="line"> * &#123;@code DataSource&#125; object is retrieved though a lookup operation</span><br><span class="line"> * and then used to create a &#123;@code Connection&#125; object.  With a basic</span><br><span class="line"> * implementation, the connection obtained through a &#123;@code DataSource&#125;</span><br><span class="line"> * object is identical to a connection obtained through the</span><br><span class="line"> * &#123;@code DriverManager&#125; facility.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * An implementation of &#123;@code DataSource&#125; must include a public no-arg</span><br><span class="line"> * constructor.</span><br><span class="line"> *</span><br><span class="line"> * @since 1.4</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="概要翻译"><a href="#概要翻译" class="headerlink" title="概要翻译"></a>概要翻译</h3><ol><li>Part - 1:<ul><li>DataSource是获取物理数据源连接的工厂类。</li><li>作为DriverManager工具的替代方案，DataSource对象是获取连接的首选方法.</li><li>DataSource的实现类一般都通过JNDI的方式注册到框架中进行使用。</li></ul></li><li>Part - 2:<ul><li>DataSource一般由数据库厂商提供对应的实现类，DataSource有三种实现方式<ol><li>基本实现，生成标准连接对象。</li><li>连接池实现，适用于中间层连接池管理器。</li><li>分布式事务实现。此实现适用于中间层事务管理器，并且几乎总是使用连接池管理器。</li></ol></li></ul></li><li><p>Part - 3:</p><ul><li>DataSource向Spring框架屏蔽了具体数据源的差异，即当物理数据源切换时，只需要更新相关的DataSource配置值即可，不需要应用层修改代码。</li></ul></li><li><p>Part - 4:</p><ul><li>数据库Driver都是通过DataSource对象被注册到DriverManager中，而不是由Driver直接向DriverManager注册。</li><li>但是对于获取Connection，先通过检索先获得DataSource，再根据DataSource对象进行getConnection，而不是直接从DriverManager获取Connection。</li></ul></li></ol><h2 id="Spring-JDBC的DataSource实现案例"><a href="#Spring-JDBC的DataSource实现案例" class="headerlink" title="Spring-JDBC的DataSource实现案例"></a>Spring-JDBC的DataSource实现案例</h2><p><img src="/2018/08/11/Spring数据库原理-DataSource/img-1.png" alt="image"></p><p>在 Spring-jdbc 下，DataSource 最顶级的类是 AbstractDataSource ，对 DataSource 的所有父接口方法做了实现。但保留 getConnection() 方法由子类实现。</p><p>在 AbstractDriverBasedDataSource 中，定义了大量的参数，诸如 url, username 等，这些都被用来定位并定义与数据库实例的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.jdbc.datasource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.UsesJava7;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDriverBasedDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String catalog;</span><br><span class="line">    <span class="keyword">private</span> String schema;</span><br><span class="line">    <span class="keyword">private</span> Properties connectionProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDriverBasedDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......略</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getConnectionFromDriver(<span class="keyword">this</span>.getUsername(), <span class="keyword">this</span>.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getConnectionFromDriver(username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UsesJava</span>7</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Properties mergedProps = <span class="keyword">new</span> Properties();</span><br><span class="line">        Properties connProps = <span class="keyword">this</span>.getConnectionProperties();</span><br><span class="line">        <span class="keyword">if</span>(connProps != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mergedProps.putAll(connProps);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......略</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties var1)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合方案为将除 url 外的所有参数整合在同一个 Properties 对象中 (其中，Properties 可以被认为是一个线程安全的 Hash Map) 。最终调用 Connection getConnectionFromDriver(Properties props) 获取连接。</p><p>AbstractDriverBasedDataSource 抽象类的两个子类 DriverManagerDataSource 和 SimpleDriverDataSource 都以不同方式获得了连接(Connection)，但总结而言，获取连接(Connection) 的任务被委托给了 Driver 来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="comment">// SimpleDriverDataSource 的实现</span></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Driver driver = getDriver();</span><br><span class="line">    String url = getUrl();</span><br><span class="line">    Assert.notNull(driver, <span class="string">"Driver must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating new JDBC Driver Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> driver.connect(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="comment">// DriverManagerDataSource 的实现</span></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String url = getUrl();</span><br><span class="line">    Assert.state(url != <span class="keyword">null</span>, <span class="string">"'url' not set"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating new JDBC DriverManager Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调了个内部函数</span></span><br><span class="line">    <span class="keyword">return</span> getConnectionFromDriverManager(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriverManager</span><span class="params">(String url, Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 委托给 DriverManager 类来获取连接</span></span><br><span class="line">    <span class="comment">// DriverManager 的主要操作是遍历在该管理类中注册的 Driver</span></span><br><span class="line">    <span class="comment">// 每个 Driver 实例都去尝试一下，能不能获得一个连接</span></span><br><span class="line">    <span class="comment">// 第一次在某个 Driver 中拿到一个连接即返回连接 (Connection)</span></span><br><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(url, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DataSource&quot;&gt;&lt;a href=&quot;#DataSource&quot; class=&quot;headerlink&quot; title=&quot;DataSource&quot;&gt;&lt;/a&gt;DataSource&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;用Spring进行Web应用开发时，我们经常会做datasource的配置。而且datasource的配法风格各异。那么他们到底有哪些异同点呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/08/11/Spring数据库原理-DataSource/image-20180811151925263.png&quot; alt=&quot;image-20180811151925263&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/08/11/Spring数据库原理-DataSource/image-20180811152018356.png&quot; alt=&quot;image-20180811152018356&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/08/11/Spring数据库原理-DataSource/image-20180811152412438.png&quot; alt=&quot;image-20180811152412438&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;DataSource作用&quot;&gt;&lt;a href=&quot;#DataSource作用&quot; class=&quot;headerlink&quot; title=&quot;DataSource作用&quot;&gt;&lt;/a&gt;DataSource作用&lt;/h2&gt;&lt;p&gt;DataSource是javax.sql包中的类，是Java原生rt.jar包中的类。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataSource&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CommonDataSource&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Wrapper&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;Connection &lt;span class=&quot;title&quot;&gt;getConnection&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;Connection &lt;span class=&quot;title&quot;&gt;getConnection&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String username, String password)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="https://veryjj.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Spring" scheme="https://veryjj.github.io/tags/Spring/"/>
    
      <category term="DataSource" scheme="https://veryjj.github.io/tags/DataSource/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码解析-Consumer启动</title>
    <link href="https://veryjj.github.io/2018/06/02/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Consumer%E5%90%AF%E5%8A%A8/"/>
    <id>https://veryjj.github.io/2018/06/02/Dubbo源码解析-Consumer启动/</id>
    <published>2018-06-02T07:06:57.000Z</published>
    <updated>2020-10-05T14:14:57.106Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Dubbo Consumer的启动过程和Provider一样，以DubboNamespaceHandler为起点，去解析代码配置中的ReferenceBean。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>ReferenceBean同样既继承了ReferenceConfig，又实现了InitializingBean。也是在afterProperitesSet()中去执行服务引用<ul><li>ReferenceBean<ul><li>afterPropertiesSet<ul><li>ReferenceConfig<ul><li>init()<ul><li>完成service interface的class， methods解析</li><li>获取Service 注册中心registeries配置信息，用于向注册中西订阅service</li><li>检测是否配置有Dubbo Mock， Dubbo Stub</li><li>createProxy()完成ReferenceConfig + Registeries ——》 Dubbo Service Invoker的转化。createProxy()返回时，返回的是被Proxy后的Invoker，即外层加了Dubbo Filter Chain。<ul><li>DubboProtocol.refer(…)</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="DubboProtocol"><a href="#DubboProtocol" class="headerlink" title="DubboProtocol"></a>DubboProtocol</h3><p>DubboProtocol.class 作为Dubbo RPC层的具体实现协议，尤其完成Consumer中向注册中心真正订阅的动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        optimizeSerialization(url);</span><br><span class="line">        <span class="comment">// create rpc invoker with url.</span></span><br><span class="line">        DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">        invokers.add(invoker);</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class="line">        <span class="comment">// whether to share connection</span></span><br><span class="line">        <span class="keyword">boolean</span> service_share_connect = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> connections = url.getParameter(Constants.CONNECTIONS_KEY, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// if not configured, connection is shared, otherwise, one connection for one service</span></span><br><span class="line">        <span class="keyword">if</span> (connections == <span class="number">0</span>) &#123;</span><br><span class="line">            service_share_connect = <span class="keyword">true</span>;</span><br><span class="line">            connections = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExchangeClient[] clients = <span class="keyword">new</span> ExchangeClient[connections];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (service_share_connect) &#123;</span><br><span class="line">                clients[i] = getSharedClient(url);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                clients[i] = initClient(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get service interface.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> service interface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invoke.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与Service Provider端的连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeClient[] clients;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同一service的invokers集合，集群时用到。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Invoker&lt;?&gt;&gt; invokers;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboInvoker</span><span class="params">(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients, Set&lt;Invoker&lt;?&gt;&gt; invokers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(serviceType, url, <span class="keyword">new</span> String[]&#123;Constants.INTERFACE_KEY, Constants.GROUP_KEY, Constants.TOKEN_KEY, Constants.TIMEOUT_KEY&#125;);</span><br><span class="line">        <span class="keyword">this</span>.clients = clients;</span><br><span class="line">        <span class="comment">// get version.</span></span><br><span class="line">        <span class="keyword">this</span>.version = url.getParameter(Constants.VERSION_KEY, <span class="string">"0.0.0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.invokers = invokers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(Constants.VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="keyword">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">                currentClient.send(inv, isSent);</span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync) &#123;</span><br><span class="line">                ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReferenceConfig-核心数据"><a href="#ReferenceConfig-核心数据" class="headerlink" title="ReferenceConfig 核心数据"></a>ReferenceConfig 核心数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractReferenceConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//核心是DubboProtocol</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集群模式下使用，此处不解释</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册中心地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    <span class="comment">// interface name</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line">    <span class="comment">// client type</span></span><br><span class="line">    <span class="keyword">private</span> String client;</span><br><span class="line">    <span class="comment">// url for peer-to-peer invocation</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="comment">// Service的方法列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MethodConfig&gt; methods;</span><br><span class="line">    <span class="comment">// default config</span></span><br><span class="line">    <span class="keyword">private</span> ConsumerConfig consumer;</span><br><span class="line">    <span class="keyword">private</span> String protocol;</span><br><span class="line">    <span class="comment">// invoker 的代理类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> T ref;</span><br><span class="line">    <span class="comment">//原生的service invoker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Invoker&lt;?&gt; invoker;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> destroyed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConsumerModel"><a href="#ConsumerModel" class="headerlink" title="ConsumerModel"></a>ConsumerModel</h3><p>经过ReferenceConfig一番处理后，最终会得到：Reference Dubbo Service Name, InvokerRef, Service Methods, ReferenceConfig Instance。</p><p>这些信息会封装成ConsumerModel，放到ApplicationModel.class中去全局统一记录Consumer的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReferenceConfig metadata;</span><br><span class="line">    <span class="keyword">private</span> Object proxyObject;</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ConsumerMethodModel&gt; methodModels = <span class="keyword">new</span> IdentityHashMap&lt;Method, ConsumerMethodModel&gt;();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Dubbo Consumer的启动过程和Provider一样，以DubboNamespaceHandler为起点，去解析代码配置中的ReferenceBean。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReferenceBean&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReferenceConfig&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FactoryBean&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;ApplicationContextAware&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;InitializingBean&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;DisposableBean&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Dubbo" scheme="https://veryjj.github.io/tags/Dubbo/"/>
    
      <category term="RPC" scheme="https://veryjj.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] REST API必须是超文本驱动的</title>
    <link href="https://veryjj.github.io/2018/05/20/%E7%BF%BB%E8%AF%91-REST-API%E5%BF%85%E9%A1%BB%E6%98%AF%E8%B6%85%E6%96%87%E6%9C%AC%E9%A9%B1%E5%8A%A8%E7%9A%84/"/>
    <id>https://veryjj.github.io/2018/05/20/翻译-REST-API必须是超文本驱动的/</id>
    <published>2018-05-20T06:53:12.000Z</published>
    <updated>2020-10-05T14:14:57.309Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" target="_blank" rel="noopener">Roy T. Fielding: REST APIs must be hypertext-driven</a></p><blockquote><p>I am getting frustrated by the number of people calling any HTTP-based interface a REST API. Today’s example is the SocialSite REST API. That is RPC. It screams RPC. There is so much coupling on display that it should be given an X rating.</p></blockquote><p>我是越来越失望了，许多人把任何基于HTTP的接口叫做REST API，眼前的例子就是SocialSite REST API。那是RPC，实实在在的RPC。它与显示如此耦合，再差也莫过于此</p><a id="more"></a><blockquote><p>What needs to be done to make the REST architectural style clear on the notion that hypertext is a constraint? In other words, if the engine of application state (and hence the API) is not being driven by hypertext, then it cannot be RESTful and cannot be a REST API. Period. Is there some broken manual somewhere that needs to be fixed?</p></blockquote><p>基于超文本概念，如何才能确保清晰的REST架构风格呢？这样来说吧，如果应用程序状态引擎（即API）不是由超文本驱动的，那就不是RESTful也不是REST的API。就这么简单。某些REST方面的破手册是否该修正一下呢？</p><blockquote><p>API designers, please note the following rules before calling your creation a REST API:</p></blockquote><p>API的设计者们，把你们的那些东西叫做REST API前请注意以下的规则：</p><blockquote><p>A REST API should not be dependent on any single communication protocol, though its successful mapping to a given protocol may be dependent on the availability of metadata, choice of methods, etc. In general, any protocol element that uses a URI for identification must allow any URI scheme to be used for the sake of that identification. [Failure here implies that identification is not separated from interaction.]</p></blockquote><p>REST API不应依赖于任何特定的通讯协议，在采用某个具体协议时可能受限于元数据的有效性、方法的选择等。通常，协议元素使用URI作标识时，对该标识必须允许运用任何URI方案。[ 不符合这一点意味着标识与交互没有分离 ]</p><blockquote><p>A REST API should not contain any changes to the communication protocols aside from filling-out or fixing the details of underspecified bits of standard protocols, such as HTTP’s PATCH method or Link header field. Workarounds for broken implementations (such as those browsers stupid enough to believe that HTML defines HTTP’s method set) should be defined separately, or at least in appendices, with an expectation that the workaround will eventually be obsolete. [Failure here implies that the resource interfaces are object-specific, not generic.]</p></blockquote><p>REST API不应修改通讯协议中预留出来作为补充或修正标准协议用途的资源，例如HTTP的PATCH方法和Link head域。违背了这一原则的方案应当单独定义，或者至少在附录中标注出来这样的方案最终会废弃掉。[ 不符合这一点意味着资源接口是对象相关的，不通用 ]</p><blockquote><p>A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types. Any effort spent describing what methods to use on what URIs of interest should be entirely defined within the scope of the processing rules for a media type (and, in most cases, already defined by existing media types). [Failure here implies that out-of-band information is driving interaction instead of hypertext.]</p></blockquote><p>REST API应当将绝大部分精力放在媒体类型的定义上，或者是扩展关系名称的定义、已有超文本标记中的标准媒体类型等方面，以实现资源的表述、操作应用程序状态。任何类似于对某某URI应当使用什么样的方法等工作，都应当完全定义在特定媒体类型的处理规则范围中（绝大部分情况下已有媒体类型都已经定义好了这些规则）。[ 不符合这一点意味着交互是由其它信息驱动，而不是超文本 ]</p><blockquote><p>A REST API must not define fixed resource names or hierarchies (an obvious coupling of client and server). Servers must have the freedom to control their own namespace. Instead, allow servers to instruct clients on how to construct appropriate URIs, such as is done in HTML forms and URI templates, by defining those instructions within media types and link relations. [Failure here implies that clients are assuming a resource structure due to out-of band information, such as a domain-specific standard, which is the data-oriented equivalent to RPC’s functional coupling].</p></blockquote><p>REST API决不能定义固定的资源名称或者层次关系（这是明显的客户端、服务器端耦合），服务器必须可以自由控制自己的名称空间。应当像HTML forms和URI模板一样，通过媒体类型和链接关系指示客户端如何构造正确的URI。[ 不符合这一点意味着客户端在通过其它信息（例如领域相关标准）猜测资源结构，这是数据导向，类似于RPC的函数耦合 ]</p><blockquote><p>A REST API should never have “typed” resources that are significant to the client. Specification authors may use resource types for describing server implementation behind the interface, but those types must be irrelevant and invisible to the client. The only types that are significant to a client are the current representation’s media type and standardized relation names. [ditto]</p></blockquote><p>REST API决不能使用对客户端有重要意义的类型化资源。规范的作者可能使用资源类型描述接口背后的服务器端实现，但这些类型必须与客户端无关，对客户端不可见。对客户端唯一有意义的类型是当前的表述性媒体类型和标准的关系名称。[ 同上 ]</p><blockquote><p>A REST API should be entered with no prior knowledge beyond the initial URI (bookmark) and set of standardized media types that are appropriate for the intended audience (i.e., expected to be understood by any client that might use the API). From that point on, all application state transitions must be driven by client selection of server-provided choices that are present in the received representations or implied by the user’s manipulation of those representations. The transitions may be determined (or limited by) the client’s knowledge of media types and resource communication mechanisms, both of which may be improved on-the-fly (e.g., code-on-demand). [Failure here implies that out-of-band information is driving interaction instead of hypertext.]</p></blockquote><p>使用REST API应该只需要知道初始URI（书签）和一系列针对目标用户的标准媒体类型（任何客户端都了解用来操作该媒体类型的API）。这样所有的应用程序状态转换都通过这样的方式进行：服务器在返回的表述性消息中提供选项，由客户端进行选择，或者是伴随着用户对表述性内容的操作而进行。状态转换由客户端对媒体类型的了解程度和资源通讯机制决定，或者受限于这些因素，这些问题都可以根据实际情况得以改善的（例如使用javascript这种code-on-demand技术）。[ 不符合这一点意味着交互是由其它信息驱动，而不是超文本 ]</p><blockquote><p>There are probably other rules that I am forgetting, but the above are the rules related to the hypertext constraint that are most often violated within so-called REST APIs. Please try to adhere to them or choose some other buzzword for your API.</p></blockquote><p>也许还有其它一些规则我一时想不起来了，但在那些所谓的REST API中通常都违背了上面这些超文本约束相关的规则，请纠正这些错误或者改用其它称谓吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Roy T. Fielding: REST APIs must be hypertext-driven
&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I am getting frustrated by the number of people calling any HTTP-based interface a REST API. Today’s example is the SocialSite REST API. That is RPC. It screams RPC. There is so much coupling on display that it should be given an X rating.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我是越来越失望了，许多人把任何基于HTTP的接口叫做REST API，眼前的例子就是SocialSite REST API。那是RPC，实实在在的RPC。它与显示如此耦合，再差也莫过于此&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="REST" scheme="https://veryjj.github.io/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API命名实践</title>
    <link href="https://veryjj.github.io/2018/05/18/RESTful-API%E5%91%BD%E5%90%8D%E5%AE%9E%E8%B7%B5/"/>
    <id>https://veryjj.github.io/2018/05/18/RESTful-API命名实践/</id>
    <published>2018-05-18T02:29:30.000Z</published>
    <updated>2020-10-05T14:14:57.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在互联网高度普及的今天，作为一名Web开发者，如果你还没听说过“REST”这个技术名词，出门都不好意思跟人打招呼。尽管如此，对于REST这个泊来品的理解，大多数人仍然停留在“盲人摸象”的阶段。</p><p>有人认为，在Web Controller层写的API就是REST API。而且，从开发角度对于URI的命名、HTTP  Mehthod的选择没有建立起规范的意识。这样是不优雅的！（没有对错之分）</p><p>作为带着问题学习总结的我，未打算通过本篇文档全面的阐述清楚REST，而是尽量的总结一些理论和思考，一起探讨！</p><a id="more"></a><h1 id="REST-的诞生"><a href="#REST-的诞生" class="headerlink" title="REST 的诞生"></a>REST 的诞生</h1><h2 id="Web-技术发展"><a href="#Web-技术发展" class="headerlink" title="Web 技术发展"></a>Web 技术发展</h2><p>Web开发技术的发展可以粗略划分成以下几个阶段：</p><ol><li><p>静态内容阶段：在这个最初的阶段，使用Web的主要是一些研究机构。Web由大量的静态HTML文档组成，其中大多是一些学术论文。Web服务器可以被看作是支持超文本的共享文件服务器。</p><ul><li>可以想象下当时的HTTP请求只有“GET”，且MIME为“HTML或TEXT”</li></ul></li><li><p>CGI程序阶段：在这个阶段，Web服务器增加了一些编程API。通过这些API编写的应用程序，可以向客户端提供一些动态变化的内容。Web服务器与应用程序之间的通信，通过CGI（Common Gateway Interface）协议完成，应用程序被称作CGI程序。</p></li><li><p>脚本语言阶段：在这个阶段，服务器端出现了ASP、PHP、JSP、ColdFusion等支持session的脚本语言技术，浏览器端出现了Java Applet、JavaScript等技术。使用这些技术，可以提供更加丰富的动态内容。</p></li><li><p>瘦客户端应用阶段：在这个阶段，在服务器端出现了独立于Web服务器的应用服务器。同时出现了Web MVC开发模式，各种Web MVC开发框架逐渐流行，并且占据了统治地位。基于这些框架开发的Web应用，通常都是瘦客户端应用，因为它们是在服务器端生成全部的动态内容。</p></li><li><p>RIA应用阶段：在这个阶段，出现了多种RIA（Rich Internet Application）技术，大幅改善了Web应用的用户体验。应用最为广泛的RIA技术是DHTML+Ajax。Ajax技术支持在不刷新页面的情况下动态更新页面中的局部内容。同时诞生了大量的Web前端DHTML开发库，例如Prototype、Dojo、ExtJS、jQuery/jQuery UI等等，很多开发库都支持单页面应用（Single Page Application）的开发。其他的RIA技术还有Adobe公司的Flex、微软公司的Silverlight、Sun公司的JavaFX（现在为Oracle公司所有）等等。</p></li><li><p>移动Web应用阶段：在这个阶段，出现了大量面向移动设备的Web应用开发技术。除了Android、iOS、Windows Phone等操作系统平台原生的开发技术之外，基于HTML5的开发技术也变得非常流行。</p></li></ol><h2 id="REST-的诞生-1"><a href="#REST-的诞生-1" class="headerlink" title="REST 的诞生"></a>REST 的诞生</h2><p>从上述Web开发技术的发展过程看，Web从最初其设计者所构思的主要支持静态文档的阶段，逐渐变得越来越动态化。Web应用的交互模式，变得越来越复杂：从静态文档发展到以内容为主的门户网站、电子商务网站、搜索引擎、社交网站，再到以娱乐为主的大型多人在线游戏、手机游戏。</p><p>Web发展到了1995年，在CGI、ASP等技术出现之后，沿用了多年、主要面向静态文档的HTTP/1.0协议已经无法满足Web应用的开发需求，因此需要设计新版本的HTTP协议。在HTTP/1.0协议专家组之中，有一位年轻人脱颖而出，显示出了不凡的洞察力，后来他成为了HTTP/1.1协议专家组的负责人。这位年轻人就是Apache HTTP服务器的核心开发者Roy Fielding，他还是Apache软件基金会的合作创始人。</p><p>所以，REST 并不是在互联网诞生之初就有的，它是在HTTP/1.1协议中才出现的，由Roy Thomas Fielding这位大神对Web技术做了深入的总结和分析，提出的一套网络软件的架构风格理论框架，当时Fielding为这种架构风格取了一个轻松愉快的名字：“REST” ———— Representational State Transfer（表述性状态转移）</p><ul><li>Roy Thomas Fielding 关于REST的论文<ul><li><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf" target="_blank" rel="noopener">https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf</a></li></ul></li></ul><hr><h1 id="REST-详解"><a href="#REST-详解" class="headerlink" title="REST 详解"></a>REST 详解</h1><h2 id="REST-架构风格"><a href="#REST-架构风格" class="headerlink" title="REST 架构风格"></a>REST 架构风格</h2><pre><code>问题：REST 究竟是什么？是一种新的技术、一种新的架构、还是一种新的规范？</code></pre><p>首先，REST是Web自身的<code>架构风格</code>，也是世界上最成功的分布式应用架构风格。它是为运行在互联网环境的分布式超媒体系统量身定制的。</p><ul><li>REST是一种架构风格！</li><li>REST是一种架构风格！</li><li>REST是一种架构风格！</li></ul><p>所以，就会存在实际开发工作中即使没有正确的理解和应用REST，但也能顺利的完成开发工作。也正因为如此，给开发工作中推广正确实践和统一风格带来不小的困难。因为大多数程序员总是在寻找最快解决问题，最快完成需求的方式，怎么简单怎么来。</p><h2 id="解读-REST"><a href="#解读-REST" class="headerlink" title="解读 REST"></a>解读 REST</h2><pre><code>REST ———— Representational State Transfer (表现层状态转化)</code></pre><p>从“Representational State Transfer”这个定义去理解REST架构风格原则。</p><h3 id="1-资源（Resources）"><a href="#1-资源（Resources）" class="headerlink" title="1. 资源（Resources）"></a>1. 资源（Resources）</h3><p>REST 的名称“表现层状态转化”中，省略了主语。“表现层”其实指的是“资源（Resources）”的“表现层”</p><p>资源是一种看待服务器的方式，此处指的“资源”是一个抽象的概念，它不仅仅指服务器端真实存在的文件、数据库表，而是指任何可被名词表述的东西。所以在定义“资源”时可以要多抽象就多抽象。</p><p>对于客户端，可以将服务器端看作是由很多离散的资源组成。服务端可以用URI（统一资源定位符）指向资源，每种资源都对应一个特定的URI。要向获取这个资源，访问它的URI就可以了，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓“上网”，就是与互联网上一系列的“资源”互动，调用它的URI。</p><h3 id="2-表现层（Representation）"><a href="#2-表现层（Representation）" class="headerlink" title="2. 表现层（Representation）"></a>2. 表现层（Representation）</h3><p>“资源”是一种信息实体，它可以有多在的表现形式。我们把“资源”具体呈现出来的形式，叫做它的“表现层（Representation）”</p><p>比如，文本信息可以用txt格式表现，也可以用HTML格式 、XML格式、JSON格式表现，甚至可以用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的表现形式。资源的具体表现形式，应该在HTTP请求的的头部信息中用Accept和Content-Type字段指明，这两个字段才是对“表现层”的描述。  </p><ul><li>详见HTTP MIME明细</li></ul><h3 id="3-状态转化（State-Transfer）"><a href="#3-状态转化（State-Transfer）" class="headerlink" title="3. 状态转化（State Transfer）"></a>3. 状态转化（State Transfer）</h3><p>HTTP协议是一个无状态的协议，这意味着所有资源的状态都保存在服务器端。因为客户端想要操作服务器，必须通过某种手段，让服务器端资源发生“状态转化”。而这种转化是建立在表现层之上的，所以就是“表现层状态转化”。</p><p>客户端用到的手段，只能是HTTP协议。具体对应HTTP协议中的HTTP Method：GET、POST、PUT、PATCH、DELETE、HEAD、OPTIONS。每一种HTTP Method代表资源状态转化的一种<code>约定的</code>方式。</p><p><strong>HTTP 动词</strong></p><p>对于资源的具体操作类型，有HTTP动词表示。</p><p>常用的HTTP动词如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- GET : 从服务器取出资源（一个或多个）</span><br><span class="line"></span><br><span class="line">- POST : 在服务器新建一个资源，并返回创建后的完整资源到客户端</span><br><span class="line"></span><br><span class="line">- PUT : 在服务器以覆盖形式，全量更新资源，并返回更新后的完整资源到客户端</span><br><span class="line"></span><br><span class="line">- PATCH : 在服务器端更新资源，但只更新指定的内容</span><br><span class="line"></span><br><span class="line">- DELETE : 在服务器端删除资源</span><br></pre></td></tr></table></figure><p>其中，GET、PUT、PATCH、DELETE都应该是幂等的。</p><p>另外，HEAD、OPTIONS对于团队开发来说基本不用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- HEAD : 获取资源的元数据</span><br><span class="line"></span><br><span class="line">- OPTIONS : 获取信息，关于资源的哪些属性是客户端可以改变的</span><br></pre></td></tr></table></figure><h3 id="4-综述"><a href="#4-综述" class="headerlink" title="4. 综述"></a>4. 综述</h3><p>综合上面的解读，总结一下什么是REST架构风格：</p><p>(1) 服务器端的任何信息和数据都要被抽象资源化；<br>(2) 资源用URI进行表述，每一个URI代表一种资源；<br>(3) 客户端与服务器之间，基于某种表现层形式，互相传递资源；<br>(4) 客户端与服务器之间，基于HTTP Method对服务器端资源的操作，实现“表现层状态转化”；  </p><h2 id="REST-与-RESTful"><a href="#REST-与-RESTful" class="headerlink" title="REST 与 RESTful"></a>REST 与 RESTful</h2><p>定义：  </p><ul><li>如果一个架构符合REST原则，就称它为RESTful架构</li><li>如果HTTP API的设计符合REST原则，那么可称它为RESTful API</li></ul><p>所以，回到开篇讲的大多数人对于REST还是处于“盲人摸象”的阶段，回想下自己和身边的同事，在工作中经常交流到的REST API或RESTful API，其实只能算个HTTP API吧？</p><hr><h1 id="REST-风格优点"><a href="#REST-风格优点" class="headerlink" title="REST 风格优点"></a>REST 风格优点</h1><p>架构风格不是非此即彼的是非题，在实际开发中可以自主的选择是否应用REST风格。那么，如果应用REST风格会带来哪些优势呢？</p><ol><li>从面向操作编程，转变为面向资源编程。更面向对象，架构更清晰、松耦合。<ul><li>我们应该确定的认为系统由“资源+对资源的操作”组成，而不是由“操作”组成</li><li>面向操作编程会导致API膨胀，功能重复度高。</li></ul></li><li>统一URI命名风格，URI具备很强的可读性，具备自解释的能力。服务器资源层次目录清晰。</li><li>状态无关。确保系统横向扩展的能力。</li><li>超文本驱动。确保系统演化的能力。</li></ol><hr><h1 id="REST实践体会"><a href="#REST实践体会" class="headerlink" title="REST实践体会"></a>REST实践体会</h1><h2 id="1-URI命名难度变大"><a href="#1-URI命名难度变大" class="headerlink" title="1. URI命名难度变大"></a>1. URI命名难度变大</h2><p>在没有要求URI必须用资源名词来组成URI时，URI的命名从来不是什么难事，常见的命名风格有：</p><ul><li>动词+名词<ul><li>/deposit/getUsers: 获取某个项目保证金用户列表</li><li>/orders/submitAudit: 订单提交审核 </li><li>/cart/add: 商品加购物车</li></ul></li><li>URI全局唯一即可<ul><li>/finance/budget/getPurchaseplanNextAuditOrgList：我有点小无语…  </li></ul></li></ul><blockquote><p>为什么会这样：</p></blockquote><p>我们平时搞系统是这样的：</p><ol><li>有新建用户功能</li><li>新建用户需要一个URL</li><li>往这个URL发送的数据要定义好</li><li>开始写后端和前端</li></ol><p>这是以操作为第一位的设计方法，首先确认了一个操作，然后围绕这个操作把周边需要的东西建设好，这种方式当然可以架构出一个系统，甚至是一个好系统，但是偶尔会有些问题：</p><ol><li>操作之间是会有关联，你的设计容易变成“第2个操作要求第1个操作进行过”，这种关系多起来你的系统就乱了</li><li>你的URL设计会缺乏一致性</li><li>操作通常被认为是有副作用（Side Effect）的，所以很少有人基于操作去设计缓存之类的东西  </li></ol><blockquote><p>该怎么应对？</p></blockquote><p>确实，REST是高度抽象的理论和风格，在实际开发中会面对各种复杂的功能和场景，导致很难完全的应用REST风格。当我们在争论REST风格到底如何设计才是正宗时，发现心中的困惑不仅没有降低，反而增加了。</p><p>我的想法：仍以真正的系统需求为出发点，使用REST风格让系统的架构更清晰，让系统的开发协作更高效。部分不适合REST的场景应该灵活变通。</p><p>回到URI的命名：</p><ol><li>坚持URI仍以资源为导向，清晰的表述服务器端资源目录</li><li>保障URI资源层次清晰的情况下，只允许在URI最末一级添加动词，例如：/market/orders/1/audit</li><li>如果某些动作是HTTP动词表示不了的，考虑把动作抽象成一种资源</li></ol><p>比如：网上汇款，从账户1向账户2汇款100元，错误的URI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /accounts/1/transfer/500/to/2</span><br></pre></td></tr></table></figure><p>正确的写法是把动词transfer改成名词transaction</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /transaction?from=1&amp;to=2&amp;amount=100</span><br></pre></td></tr></table></figure><h2 id="2-用不用HTTP-PATCH"><a href="#2-用不用HTTP-PATCH" class="headerlink" title="2. 用不用HTTP PATCH"></a>2. 用不用HTTP PATCH</h2><p>PATCH 作为HTTP的Method之一，其实它是2010年3月份才正式成为HTTP Method的，详见：<a href="http://tools.ietf.org/html/rfc5789" target="_blank" rel="noopener">RFC 5789</a></p><p>也正因为PATCH出现的晚, 所以并不是所有Web容器都支持，反而目前实现了PATCH方法的Web容器很少</p><p>几个常见Web容器实现PATCH方法的情况，供参考：</p><ol><li>Apache HttpComponents HttpClient version 4.2 or later 支持了 PATCH</li><li>目前 JDK7 的 HttpURLConnection 未实现 PATCH</li><li>TOMCAT 7 也不行</li><li>PlayFramework 2 也不支持</li><li>Spring 3.2 开始支持 PATCH 方法，但要选对部署的容器</li><li>JBoss Netty 支持 PATCH，可见： <a href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/handler/codec/http/class-use/HttpMethod.html" target="_blank" rel="noopener">http://docs.jboss.org/netty/3.2/api/org/jboss/netty/handler/codec/http/class-use/HttpMethod.html</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在互联网高度普及的今天，作为一名Web开发者，如果你还没听说过“REST”这个技术名词，出门都不好意思跟人打招呼。尽管如此，对于REST这个泊来品的理解，大多数人仍然停留在“盲人摸象”的阶段。&lt;/p&gt;
&lt;p&gt;有人认为，在Web Controller层写的API就是REST API。而且，从开发角度对于URI的命名、HTTP  Mehthod的选择没有建立起规范的意识。这样是不优雅的！（没有对错之分）&lt;/p&gt;
&lt;p&gt;作为带着问题学习总结的我，未打算通过本篇文档全面的阐述清楚REST，而是尽量的总结一些理论和思考，一起探讨！&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="RESTful" scheme="https://veryjj.github.io/tags/RESTful/"/>
    
      <category term="Web" scheme="https://veryjj.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引合并</title>
    <link href="https://veryjj.github.io/2018/05/06/MySQL%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6/"/>
    <id>https://veryjj.github.io/2018/05/06/MySQL索引合并/</id>
    <published>2018-05-06T09:55:18.000Z</published>
    <updated>2020-10-05T14:14:57.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h2><p>MySQL 5.0版本之前，一个表一次只能选择并使用一个索引。</p><p>MySQL 5.1版本开始，引入了Index Merge Optimization技术，使得MySQL支持一个表一次查询同时使用多个索引。</p><p>官方文档：<a href="https://dev.mysql.com/doc/refman/5.5/en/index-merge-optimization.html" target="_blank" rel="noopener">MySQL Index Merge Optimization</a> </p><p>Index Merge Optimization支持三种合并算法</p><ul><li>The Index Merge Intersection Access Algorithm<ul><li>对应SQL 中的 AND 场景</li></ul></li><li>The Index Merge Union Access Algorithm<ul><li>对应SQL中的 OR 场景（where条件是等值判断）</li></ul></li><li>The Index Merge Sort-Union Access Algorithm<ul><li>对应SQL中的 OR 场景（where条件是范围查询）</li></ul></li></ul><a id="more"></a><blockquote><p>注：索引合并(Index Merge)的使用取决于optimizer_switch系统变量的index_merge，index_merge_intersection，index_merge_union和index_merge_sort_union标志的值。默认情况下，所有这些标志都打开。 要仅启用特定算法，请将index_merge设置为关闭，并仅启用其他应允许的其他算法。</p></blockquote><p>##关于”Index Merge Intersection Access Algorithm”的疑问</p><blockquote><p>针对 MySQL Index Merge Optimization Intersection Algorithm</p></blockquote><p>AND 场景的 index merge optimization为什么会比使用单个索引来的高效？</p><p>设想：</p><ul><li><p>使用单个索引的场景</p><ol><li>选中选择性高的索引先获得一份数据</li><li>在再mysql服务器端用using where的方式，按第二条件进行过滤，得到最终满足所有条件的数据行。</li></ol></li><li><p>同时使用表内多个索引的场景</p><ol><li>按每个索引，在索引树里拿只满足本索引条件的行数据</li><li>将两份行数据，放一块进行交集运算。</li><li>从索引的次数、磁盘IO、内存交接运算来看，事情没变少、反而变多了。</li></ol></li></ul><hr><h2 id="自我初版解释"><a href="#自我初版解释" class="headerlink" title="自我初版解释"></a>自我初版解释</h2><h4 id="合理的解释"><a href="#合理的解释" class="headerlink" title="合理的解释"></a>合理的解释</h4><p>样例SQL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_sample where column_1 = A AND column_2 = B;</span><br></pre></td></tr></table></figure></p><ol><li>前提条件，SQL中不能有范围查询，如果存在范围查询，数据库优化器默认使用单索引方式，不用index merge optimization</li><li>SQL的<code>WHERE从句中的所有条件字段都有对应的索引</code>，否则问题就来了，肯定会在内存中有次using_where的。</li><li>单表多Index并行检索时，拿到的是数据行地址，以上述SQL为例，即拿到了两份行数据地址：Index Column_1的行数据地址集，Index Column_2的行数据地址集</li><li>再在内存中完成两份行数据地址集的交集运算（只需要比地址）</li><li>此时，再决定是否回表拿更多的数据。<ul><li>如果字段中有primary key，就不用回表啦！</li></ul></li></ol><ul><li>如上的执行步骤，就会比较合理。有效率上的优势。</li></ul><h4 id="【更进一步】-explain-显示type-为-index-merge时，到底要不要引起关注？"><a href="#【更进一步】-explain-显示type-为-index-merge时，到底要不要引起关注？" class="headerlink" title="【更进一步】 explain 显示type 为 index_merge时，到底要不要引起关注？"></a>【更进一步】 explain 显示type 为 index_merge时，到底要不要引起关注？</h4><p><code>【需要引起注意】</code></p><p>拿着SQL琢磨下，是否还有优化的空间，例如：采用组合索引；强制走单索引（需要对比测试看效果，还要看业务数据场景和增长趋势）；</p><hr><p>注：</p><ol><li>当索引本身信息可以覆盖select的字段时（或是select count(*)）,效率会很高，因为内存索引里已经能提供返回的数据了，不用回表。</li><li>当索引本身信息不能覆盖select的字段时，就要回表查行数据了，性能差别很大。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;历史背景&quot;&gt;&lt;a href=&quot;#历史背景&quot; class=&quot;headerlink&quot; title=&quot;历史背景&quot;&gt;&lt;/a&gt;历史背景&lt;/h2&gt;&lt;p&gt;MySQL 5.0版本之前，一个表一次只能选择并使用一个索引。&lt;/p&gt;
&lt;p&gt;MySQL 5.1版本开始，引入了Index Merge Optimization技术，使得MySQL支持一个表一次查询同时使用多个索引。&lt;/p&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.5/en/index-merge-optimization.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL Index Merge Optimization&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;Index Merge Optimization支持三种合并算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Index Merge Intersection Access Algorithm&lt;ul&gt;
&lt;li&gt;对应SQL 中的 AND 场景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The Index Merge Union Access Algorithm&lt;ul&gt;
&lt;li&gt;对应SQL中的 OR 场景（where条件是等值判断）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The Index Merge Sort-Union Access Algorithm&lt;ul&gt;
&lt;li&gt;对应SQL中的 OR 场景（where条件是范围查询）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="https://veryjj.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://veryjj.github.io/tags/MySQL/"/>
    
      <category term="索引" scheme="https://veryjj.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL子查询很慢的问题分析</title>
    <link href="https://veryjj.github.io/2018/05/04/MySQL%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%BE%88%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>https://veryjj.github.io/2018/05/04/MySQL子查询很慢的问题分析/</id>
    <published>2018-05-04T07:29:46.000Z</published>
    <updated>2020-10-05T14:14:57.302Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="慢查询案例"><a href="#慢查询案例" class="headerlink" title="慢查询案例"></a>慢查询案例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> settlement_invoice_attachment g1 <span class="keyword">WHERE</span> demand_id <span class="keyword">in</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> settlement_invoice_demand g2 <span class="keyword">WHERE</span> statement_id = <span class="number">1802065000000074956</span>)</span><br></pre></td></tr></table></figure><p>乍眼一看，上述SQL如此简单，且demand_id和statement_id字段都是建了索引，即使是Review也会认为是OK没问题的。</p><p>然而，实际情况却是个慢查询，情况如下：</p><p><strong>explain明细</strong></p><p><img src="/2018/05/04/MySQL子查询很慢的问题分析/img-1.png" alt="image"></p><a id="more"></a><p>settlement_invoice_attachment是全表查</p><p>注：rows 2689 是因为用的测试环境，真线环境数据是几十万级别</p><hr><h4 id="子查询-原理分析-上述SQL子查询为什么这么慢"><a href="#子查询-原理分析-上述SQL子查询为什么这么慢" class="headerlink" title="子查询 原理分析(上述SQL子查询为什么这么慢)"></a>子查询 原理分析(上述SQL子查询为什么这么慢)</h4><h5 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a><code>经验之谈</code></h5><ul><li>当看到SQL执行计划中select_type字段出现“DEPENDENT SUBQUERY”的时候，要打起精神了！着重分析下潜在风险！</li></ul><h5 id="基础知识：Dependent-SubQuery意味着什么？"><a href="#基础知识：Dependent-SubQuery意味着什么？" class="headerlink" title="基础知识：Dependent SubQuery意味着什么？"></a>基础知识：Dependent SubQuery意味着什么？</h5><ul><li>官方含义为：<ol><li>SUBQUERY: 子查询中的第一个SELECT；</li><li>DEPENDENT SUBQUERY: 子查询中的第一个SELECT， 取决于外面的查询。</li></ol></li></ul><p>换句话说，就是<code>子查询的g2查询执行方式依赖于外层g1的查询结果</code><br>什么意思呢？它以为着两步走：</p><ul><li>第一步：【先执行外部SQL查询】MySQL根据”DELETE FROM settlement_invoice_attachment g1 WHERE” 得到一个大结果集t1，其数据量就是全表所有行了，假设是85万行。</li><li>第二步：【后执行内部SQL子查询】第一步的大结果集t1中的每一条记录，都将与子查询SQL组成新的查询语句：SELECT id FROM settlement_invoice_demand g2 WHERE statement_id = 1802065000000074956 AND id = %t1.demand_id%。等于说，子查询要执行85万次……即使这两部查询都用到了索引，也是巨慢的。</li></ul><h5 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h5><ul><li>改写SQL为JOIN的方式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> ah <span class="keyword">FROM</span> settlement_invoice_attachment ah <span class="keyword">INNER</span> <span class="keyword">JOIN</span> settlement_invoice_demand de </span><br><span class="line"><span class="keyword">ON</span> ah.demand_id = de.id <span class="keyword">WHERE</span> de.statement_id = <span class="number">1802065000000074956</span>;</span><br></pre></td></tr></table></figure><ul><li>拆成独立SQL多次执行</li></ul><hr><h4 id="平时怎么识别？"><a href="#平时怎么识别？" class="headerlink" title="平时怎么识别？"></a>平时怎么识别？</h4><ul><li>看子查询出现的位置<ul><li>若子查询出现在WHERE从句中，而且是出现在IN（）中，则需要引起注意，用Explain瞧瞧（并不是子查询放IN（）里就一定是全表扫，本案例用，将DELETE改成SELECT就不是DEPENDENT SUBQUERY）</li></ul></li></ul><h4 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h4><ol><li><p>MySQL处理子查询时，会(优化)改写子查询，但优化的不是很友好，一直受业界批评比较多</p><ul><li>有时候优化的挺糟糕的，特别是WHERE从句中的IN（）子查询</li></ul></li><li><p>MySQL 子查询的弱点</p><ul><li>mysql 在处理子查询时，会改写子查询。通常情况下，我们希望由内到外，先完成子查询的结果，然后再用子查询来驱动外查询的表，完成查询。</li></ul></li></ol><p>例如：select * from test where tid in(select fk_tid from sub_test where gid=10)<br>通常我们会感性地认为该 sql 的执行顺序是：</p><p>1、sub_test 表中根据 gid 取得 fk_tid(2,3,4,5,6)记录。<br>2、然后再到 test 中，带入 tid=2,3,4,5,6，取得查询数据。</p><p>但是实际mysql的处理方式为：<br>select <em> from test where exists (select </em> from sub_test where gid=10 and sub_test.fk_tid=test.tid)<br>mysql 将会扫描 test 中所有数据，每条数据都将会传到子查询中与 sub_test 关联，子查询不会先被执行，所以如果 test 表很大的话，那么性能上将会出现问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;慢查询案例&quot;&gt;&lt;a href=&quot;#慢查询案例&quot; class=&quot;headerlink&quot; title=&quot;慢查询案例&quot;&gt;&lt;/a&gt;慢查询案例&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; settlement_invoice_attachment g1 &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; demand_id &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; settlement_invoice_demand g2 &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; statement_id = &lt;span class=&quot;number&quot;&gt;1802065000000074956&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;乍眼一看，上述SQL如此简单，且demand_id和statement_id字段都是建了索引，即使是Review也会认为是OK没问题的。&lt;/p&gt;
&lt;p&gt;然而，实际情况却是个慢查询，情况如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;explain明细&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/05/04/MySQL子查询很慢的问题分析/img-1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SQL" scheme="https://veryjj.github.io/tags/SQL/"/>
    
      <category term="数据库" scheme="https://veryjj.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码解析-Provider暴露服务</title>
    <link href="https://veryjj.github.io/2018/05/02/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Provider%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1/"/>
    <id>https://veryjj.github.io/2018/05/02/Dubbo源码解析-Provider暴露服务/</id>
    <published>2018-05-02T13:20:44.000Z</published>
    <updated>2020-10-05T14:14:57.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Dubbo Provider暴露服务的流程中，需要掌握几个核心抽象对象</p><ul><li>过程中的重要类<ul><li>ServiceConfig：记录了Dubbo Service所有相关的配置信息。<a href="#ServiceConfig">ServiceConfig作用</a></li><li>DubboProtocol：以Dubbo协议的方式暴露服务，并以此为中心维护所有相关的动态服务数据。</li><li>RegisterProtocol: 内部会加载具体的注册中心Register,例如：ZookeeperRegister。完成服务向注册中心注册的动作。</li><li>ServiceConfig#loadRegistries：解析获得注册中心地址列表</li></ul></li></ul><ul><li>过程中的重要对象<ul><li>com.alibaba.dubbo.common.URL: 服务发布的地址</li><li>Invoker: 对原Service Interface进行了代理封装，屏蔽了具体Service Interface的差异，方便统一管理和调用。</li><li>Exporter： 一个ServiceBean每向一个注册中心Register注册一次，就会生成已各Exporter。Exporter用于连接暴露服务的Url与本地Invoker的对应关系。</li><li>ExporterMap: 记录着服务地址和Exporter的对应关系</li></ul></li></ul><a id="more"></a><ul><li>来自Dubbo官方的几个架构设计图，先感觉下</li></ul><p><img src="/2018/05/02/Dubbo源码解析-Provider暴露服务/img-2.png" alt="image"></p><p><img src="/2018/05/02/Dubbo源码解析-Provider暴露服务/img-1.png" alt="image"></p><h2 id="ServiceBean核心流程"><a href="#ServiceBean核心流程" class="headerlink" title="ServiceBean核心流程"></a>ServiceBean核心流程</h2><ol><li>Spring容器启动，带动Dubbo Bean配置解析以及Bean实例化。<ul><li><a href="#Dubbo 启动">Dubbo启动</a></li><li>关键类：<ul><li>DubboNamespaceHandler</li><li>ServiceBean</li><li><a href="#ServiceConfig">ServiceConfig作用</a></li></ul></li></ul></li><li>ServiceBean 继承了ServiceConfig，所有的Provider服务的Dubbo配置都在ServiceConfig中。<ul><li>Dubbo Service基本信息</li><li>Dubbo Service参数配置</li><li>注册中心地址信息。对应ServiceConfig中的loadRegistries().</li></ul></li><li>ServiceBean 实现了InitializingBean, 实现了afterPropertiesSet()方法，在每个Dubbo Service Bean实例化后，在afterPropertiesSet()方法中进行所有Dubbo服务注册需要的操作。</li><li>afterPropertiesSet()中前置代码都是在做一些配置校验和默认值设置，最后会执行export()方法注册暴露服务。</li><li>afterPropertiesSet()<ul><li>export()<ul><li>doExport()<ul><li>doExportUrls()<ul><li>doExportUrlsFor1Protocol(DubboProtocol, regitsryURLs)<ul><li>DubboProtocol.export(wrapperInvoker)</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<url> registryURLs) 是真正执行export暴露服务的代码区<ul><li></li></ul></url></li></ol><h2 id="DubboProtocol-Export核心流程"><a href="#DubboProtocol-Export核心流程" class="headerlink" title="DubboProtocol#Export核心流程"></a>DubboProtocol#Export核心流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// export service.</span></span><br><span class="line">    String key = serviceKey(url);</span><br><span class="line">    DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//export an stub service for dispatching event</span></span><br><span class="line">    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">        <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"consumer ["</span> + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">                        <span class="string">"], has set stubproxy support event ,but no stub methods founded."</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个服务端口，使用NettyServer绑定并监听，并设置Server监听事件处理回调为：DubboProtocol#requestHandler</span></span><br><span class="line">    <span class="comment">//Exchanger.bind的实际对象可配置，对应dubbo-remoting-api包</span></span><br><span class="line">    openServer(url);   </span><br><span class="line">    optimizeSerialization(url);</span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DubboProtocol核心数据"><a href="#DubboProtocol核心数据" class="headerlink" title="DubboProtocol核心数据"></a>DubboProtocol核心数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DubboProtocol INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//本地启动Server监听服务的Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ExchangeServer&gt; serverMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ExchangeServer&gt;(); <span class="comment">// &lt;host:port,Exchanger&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录消费端的Exchanger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ReferenceCountExchangeClient&gt; referenceClientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ReferenceCountExchangeClient&gt;(); <span class="comment">// &lt;host:port,Exchanger&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, LazyConnectExchangeClient&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; optimizers = <span class="keyword">new</span> ConcurrentHashSet&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//consumer side export a stub service for dispatching event</span></span><br><span class="line">    <span class="comment">//servicekey-stubmethods</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, String&gt; stubServiceMethodsMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> ExchangeHandler requestHandler = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ExporterMap</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Exporter&lt;?&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dubbo-Service是哪个时机注册到注册中心的？"><a href="#Dubbo-Service是哪个时机注册到注册中心的？" class="headerlink" title="Dubbo Service是哪个时机注册到注册中心的？"></a>Dubbo Service是哪个时机注册到注册中心的？</h3><blockquote><p>有关注到这个章节内容的小伙伴，说明你此时可能也还没想通吧，请听我道来。</p></blockquote><p>这里会涉及到Dubbo的SPI机制，Dubbo 有好几个利用SPI+动态代理+Filter的处理责任链模式，ProtocolFilterWrapper.java算一个。  </p><pre><code>- Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</code></pre><p>在Dubbo源码中，Dubbo有自行注册几个protocol SPI （这里只列举Dubbo服务注册相关的） </p><ul><li><a href="http://dubbo.apache.org/books/dubbo-dev-book/SPI.html" target="_blank" rel="noopener">SPI机制用法详见</a></li><li><a href="http://dubbo.apache.org/books/dubbo-dev-book/impls/protocol.html" target="_blank" rel="noopener">Dubbo Protocol SPI扩展详见</a></li><li>RegistryProtocol SPI: <ul><li>注册位置：dubbo-registry-api包,resources下的com.alibaba.dubbo.rpc.Protocol</li><li>注册位置：dubbo-registry-zookeeper包,resources下的com.alibaba.dubbo.register.RegistryFactory</li></ul></li></ul><p>其实，在ServiceConfig中拿到的全局protocol并不直接是DubboProtocol，而是一串Protocol，DubboProtocol只是其中之一，这些Protocol会以责任链的方式逐一被调用</p><p>所以，在doExportUrlsFor1Protocol中protocol.export(…)时，会先执行DubboProtocol#export,再执行RegisterProtocol#export,各司其职。</p><p>RegisterProtocol中会根据Dubbo Service配置的register地址类型来决定加载哪个具体的RegisterFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registedProviderUrl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//RegisterFactory根据注册中心类型，获取到注册实例，例如ZookeeperRegistry</span></span><br><span class="line">        Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行注册，实际对应ZookeeperRegistry#register</span></span><br><span class="line">        registry.register(registedProviderUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (register) &#123;</span><br><span class="line">            register(registryUrl, registedProviderUrl);</span><br><span class="line">            ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Netty-Server"><a href="#Netty-Server" class="headerlink" title="Netty Server"></a>Netty Server</h3><p>当DubboProtocol.export.openServer()时，就是在本地启动Dubbo Service的Server服务并启动监听。</p><p>实现上是通过Exchanger拿到被配置的信息交换层的实现套件（一般是Netty）。  </p><pre><code>- 获取一个服务端口，使用NettyServer绑定并监听，并设置Server监听事件处理回调为：DubboProtocol#requestHandler- Exchanger.bind的实际对象可配置，对应dubbo-remoting-api包</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Channel&gt; channels; <span class="comment">// &lt;ip:port, channel&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerBootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> org.jboss.netty.channel.Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        NettyHelper.setNettyLoggerFactory();</span><br><span class="line">        ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br><span class="line">        ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line">        ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">        channels = nettyHandler.getChannels();</span><br><span class="line">        <span class="comment">// https://issues.jboss.org/browse/NETTY-365</span></span><br><span class="line">        <span class="comment">// https://issues.jboss.org/browse/NETTY-379</span></span><br><span class="line">        <span class="comment">// final Timer timer = new HashedWheelTimer(new NamedThreadFactory("NettyIdleTimer", true));</span></span><br><span class="line">        bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">                ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">                <span class="comment">/*int idleTimeout = getIdleTimeout();</span></span><br><span class="line"><span class="comment">                if (idleTimeout &gt; 10000) &#123;</span></span><br><span class="line"><span class="comment">                    pipeline.addLast("timer", new IdleStateHandler(timer, idleTimeout / 1000, 0, 0));</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">                pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">                pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">                pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">                <span class="keyword">return</span> pipeline;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// bind</span></span><br><span class="line">        channel = bootstrap.bind(getBindAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Channel <span class="title">getChannel</span><span class="params">(InetSocketAddress remoteAddress)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBound</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ServiceConfig作用-见代码注释"><a href="#ServiceConfig作用-见代码注释" class="headerlink" title="ServiceConfig作用(见代码注释)"></a><span id="ServiceConfig">ServiceConfig作用(见代码注释)</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用的protocol远程调用层实现，用于封装RPC调用，默认是DubboProtocol，其余可选还有HttpProtocol,HessianProtocol,InjvmProtocol,RedisProtocol等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对ServiceBean进行代理，包装成Dubbo内部通用的Invoker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ServiceBean作为Dubbo Provider启动时，会在本地起server服务，每个server服务都会绑定并监听端口。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; RANDOM_PORT_MAP = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录已暴露服务的服务地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个ServiceBean每向一个注册中心Register注册一次，就会生成已各Exporter。Exporter用于连接暴露服务的Url与本地Invoker的对应关系。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Exporter&lt;?&gt;&gt; exporters = <span class="keyword">new</span> ArrayList&lt;Exporter&lt;?&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关于本ServiceBean的Java Class信息</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line">    <span class="comment">// reference to interface impl</span></span><br><span class="line">    <span class="keyword">private</span> T ref;</span><br><span class="line">    <span class="comment">// service name</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">// method configuration</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MethodConfig&gt; methods;</span><br><span class="line">    <span class="keyword">private</span> ProviderConfig provider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exported;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> unexported;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String generic;</span><br></pre></td></tr></table></figure><h3 id="Dubbo-启动"><a href="#Dubbo-启动" class="headerlink" title="Dubbo 启动"></a><span id="Dubbo 启动">Dubbo 启动</span></h3><p>Spring容器启动，带动Dubbo Bean配置实例化。Dubbo Bean配置来自于Dubbo Provider XML 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"application"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"module"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"registry"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"monitor"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"protocol"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"service"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class="keyword">true</span>));  <span class="comment">//dubbo provider bean配置解析</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"reference"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class="keyword">false</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation"</span>, <span class="keyword">new</span> AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体详见笔记：<a href="/2018/04/22/Dubbo源码解析-Spring-Bean注册/">Dubbo源码解析-Spring Bean注册</a></li></ul><h3 id="ServiceBean实例化"><a href="#ServiceBean实例化" class="headerlink" title="ServiceBean实例化"></a>ServiceBean实例化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean 继承了ServiceConfig，所有的Provider服务的Dubbo配置都在ServiceConfig中。</p><p>ServiceBean 实现了InitializingBean, 实现了afterPropertiesSet()方法，在每个Dubbo Service Bean实例化后，进行暴露服务的相关操作。</p><p>afterPropertiesSet()中前置代码都是在做一些配置校验和默认值设置，最后会执行export()方法注册暴露服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">//如果没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> (getProvider() == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">//获取IOC容器里的所有provider  </span></span><br><span class="line">            Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span>  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (providerConfigMap != <span class="keyword">null</span> &amp;&amp; providerConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span>  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">                <span class="keyword">if</span> ((protocolConfigMap == <span class="keyword">null</span> || protocolConfigMap.size() == <span class="number">0</span>)  </span><br><span class="line">                        &amp;&amp; providerConfigMap.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// 兼容旧版本  </span></span><br><span class="line">                    List&lt;ProviderConfig&gt; providerConfigs = <span class="keyword">new</span> ArrayList&lt;ProviderConfig&gt;();  </span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() != <span class="keyword">null</span> &amp;&amp; config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                            providerConfigs.add(config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="comment">//关联所有providers  </span></span><br><span class="line">                    <span class="keyword">if</span> (providerConfigs.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                        setProviders(providerConfigs);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    ProviderConfig providerConfig = <span class="keyword">null</span>;  </span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                            <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate provider configs: "</span> + providerConfig + <span class="string">" and "</span> + config);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            providerConfig = config;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                        setProvider(providerConfig);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置application，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span>  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getApplication() == <span class="keyword">null</span>)) &#123;  </span><br><span class="line">            <span class="comment">//获取所有applications  </span></span><br><span class="line">            Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (applicationConfigMap != <span class="keyword">null</span> &amp;&amp; applicationConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                ApplicationConfig applicationConfig = <span class="keyword">null</span>;  </span><br><span class="line">                <span class="keyword">for</span> (ApplicationConfig config : applicationConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate application configs: "</span> + applicationConfig + <span class="string">" and "</span> + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        applicationConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联application  </span></span><br><span class="line">                <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    setApplication(applicationConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置module，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> (getModule() == <span class="keyword">null</span>  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getModule() == <span class="keyword">null</span>)) &#123;  </span><br><span class="line">            Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (moduleConfigMap != <span class="keyword">null</span> &amp;&amp; moduleConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                ModuleConfig moduleConfig = <span class="keyword">null</span>;  </span><br><span class="line">                <span class="keyword">for</span> (ModuleConfig config : moduleConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate module configs: "</span> + moduleConfig + <span class="string">" and "</span> + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        moduleConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联module  </span></span><br><span class="line">                <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    setModule(moduleConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置registries，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> ((getRegistries() == <span class="keyword">null</span> || getRegistries().size() == <span class="number">0</span>)  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getRegistries() == <span class="keyword">null</span> || getProvider().getRegistries().size() == <span class="number">0</span>)  </span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getRegistries() == <span class="keyword">null</span> || getApplication().getRegistries().size() == <span class="number">0</span>)) &#123;  </span><br><span class="line">            Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (registryConfigMap != <span class="keyword">null</span> &amp;&amp; registryConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                List&lt;RegistryConfig&gt; registryConfigs = <span class="keyword">new</span> ArrayList&lt;RegistryConfig&gt;();  </span><br><span class="line">                <span class="keyword">for</span> (RegistryConfig config : registryConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        registryConfigs.add(config);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联registries  </span></span><br><span class="line">                <span class="keyword">if</span> (registryConfigs != <span class="keyword">null</span> &amp;&amp; registryConfigs.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="keyword">super</span>.setRegistries(registryConfigs);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置monitor，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> (getMonitor() == <span class="keyword">null</span>  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getMonitor() == <span class="keyword">null</span>)  </span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getMonitor() == <span class="keyword">null</span>)) &#123;  </span><br><span class="line">            Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (monitorConfigMap != <span class="keyword">null</span> &amp;&amp; monitorConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                MonitorConfig monitorConfig = <span class="keyword">null</span>;  </span><br><span class="line">                <span class="keyword">for</span> (MonitorConfig config : monitorConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate monitor configs: "</span> + monitorConfig + <span class="string">" and "</span> + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        monitorConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联monitor  </span></span><br><span class="line">                <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    setMonitor(monitorConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置protocol，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> ((getProtocols() == <span class="keyword">null</span> || getProtocols().size() == <span class="number">0</span>)  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getProtocols() == <span class="keyword">null</span> || getProvider().getProtocols().size() == <span class="number">0</span>)) &#123;  </span><br><span class="line">            Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span>  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (protocolConfigMap != <span class="keyword">null</span> &amp;&amp; protocolConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                List&lt;ProtocolConfig&gt; protocolConfigs = <span class="keyword">new</span> ArrayList&lt;ProtocolConfig&gt;();  </span><br><span class="line">                <span class="keyword">for</span> (ProtocolConfig config : protocolConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        protocolConfigs.add(config);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联protocol  </span></span><br><span class="line">                <span class="keyword">if</span> (protocolConfigs != <span class="keyword">null</span> &amp;&amp; protocolConfigs.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="keyword">super</span>.setProtocols(protocolConfigs);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置path  </span></span><br><span class="line">        <span class="keyword">if</span> (getPath() == <span class="keyword">null</span> || getPath().length() == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; beanName.length() &gt; <span class="number">0</span>   </span><br><span class="line">                    &amp;&amp; getInterface() != <span class="keyword">null</span> &amp;&amp; getInterface().length() &gt; <span class="number">0</span>  </span><br><span class="line">                    &amp;&amp; beanName.startsWith(getInterface())) &#123;  </span><br><span class="line">                setPath(beanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//暴露provider,重点！！！</span></span><br><span class="line">        <span class="keyword">if</span> (! isDelay()) &#123;  </span><br><span class="line">            export();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Export暴露服务"><a href="#Export暴露服务" class="headerlink" title="Export暴露服务"></a>Export暴露服务</h3><ul><li>export()方法会完成后续服务注册的所有流程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//如果provider没有配置  </span></span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">//如果exporter没有配置使用provider所关联的exporter  </span></span><br><span class="line">            <span class="keyword">if</span> (export == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                export = provider.getExport();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//如果delay（延迟暴露）没有配置，获取provider的delay  </span></span><br><span class="line">            <span class="keyword">if</span> (delay == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                delay = provider.getDelay();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果不需要暴露接口则直接返回  </span></span><br><span class="line">        <span class="keyword">if</span> (export != <span class="keyword">null</span> &amp;&amp; ! export.booleanValue()) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果延迟暴露的时间（毫秒级）是存在的，开启线程并等待delay毫秒后开始暴露接口，否则直接执行暴露接口过程  </span></span><br><span class="line">        <span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        Thread.sleep(delay);  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    doExport();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">            thread.setDaemon(<span class="keyword">true</span>);  </span><br><span class="line">            thread.setName(<span class="string">"DelayExportServiceThread"</span>);  </span><br><span class="line">            thread.start();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            doExport();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Dubbo Provider暴露服务的流程中，需要掌握几个核心抽象对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过程中的重要类&lt;ul&gt;
&lt;li&gt;ServiceConfig：记录了Dubbo Service所有相关的配置信息。&lt;a href=&quot;#ServiceConfig&quot;&gt;ServiceConfig作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;DubboProtocol：以Dubbo协议的方式暴露服务，并以此为中心维护所有相关的动态服务数据。&lt;/li&gt;
&lt;li&gt;RegisterProtocol: 内部会加载具体的注册中心Register,例如：ZookeeperRegister。完成服务向注册中心注册的动作。&lt;/li&gt;
&lt;li&gt;ServiceConfig#loadRegistries：解析获得注册中心地址列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;过程中的重要对象&lt;ul&gt;
&lt;li&gt;com.alibaba.dubbo.common.URL: 服务发布的地址&lt;/li&gt;
&lt;li&gt;Invoker: 对原Service Interface进行了代理封装，屏蔽了具体Service Interface的差异，方便统一管理和调用。&lt;/li&gt;
&lt;li&gt;Exporter： 一个ServiceBean每向一个注册中心Register注册一次，就会生成已各Exporter。Exporter用于连接暴露服务的Url与本地Invoker的对应关系。&lt;/li&gt;
&lt;li&gt;ExporterMap: 记录着服务地址和Exporter的对应关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Dubbo" scheme="https://veryjj.github.io/tags/Dubbo/"/>
    
      <category term="RPC" scheme="https://veryjj.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>服务端业务处理不成功，应该返回HTTP 200 还是 HTTP 4XXX系列？</title>
    <link href="https://veryjj.github.io/2018/04/23/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E4%B8%8D%E6%88%90%E5%8A%9F%EF%BC%8C%E5%BA%94%E8%AF%A5%E8%BF%94%E5%9B%9EHTTP-200-%E8%BF%98%E6%98%AF-HTTP-4XXX%E7%B3%BB%E5%88%97%EF%BC%9F/"/>
    <id>https://veryjj.github.io/2018/04/23/服务端业务处理不成功，应该返回HTTP-200-还是-HTTP-4XXX系列？/</id>
    <published>2018-04-23T06:27:23.000Z</published>
    <updated>2020-10-05T14:14:57.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>其实，纠结只出现在例如保存表单的场景，如果服务端因各种业务上的原因（校验不通过，状态不满足等）导致保存未成功，并要返回对应的提示信息，此时服务端回应此HTTP 请求时，是用 “200 + json” 还是用“400 + 错误信息”？</p><p>在公司内不同项目间，两种风格都有，且小伙伴们各执己见。</p><a id="more"></a><h2 id="我这么看"><a href="#我这么看" class="headerlink" title="我这么看"></a>我这么看</h2><p>首先，我先表达我赞同“200 + json”的方式。</p><p>更具体些，服务端所有的Controller Method对返回值做统一的Response包装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">样例<span class="number">1</span>：</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"code"</span>: <span class="number">200</span>,</span><br><span class="line">   <span class="string">"data"</span>: &#123;...&#125;,</span><br><span class="line">   <span class="string">"message"</span>:<span class="string">"操作成功"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">样例<span class="number">2</span>：</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"success"</span>: <span class="keyword">false</span></span><br><span class="line">   <span class="string">"data"</span>: &#123;...&#125;,</span><br><span class="line">   <span class="string">"code"</span>: <span class="number">100409</span>,</span><br><span class="line">   <span class="string">"message"</span>:<span class="string">"数据已存在"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我的观点"><a href="#我的观点" class="headerlink" title="我的观点"></a>我的观点</h3><h4 id="1-协议分层"><a href="#1-协议分层" class="headerlink" title="1. 协议分层"></a>1. 协议分层</h4><p>对于RPC请求，存在两个层面的操作结果</p><p>[1] HTTP请求本身的结果 ———— 业务无关性，与网络、框架层面相关<br>[2] 业务处理的结果 ———— 强业务逻辑相关性，与网络、框架层面无关</p><p>为什么我们会有本贴讨论的话题与分歧，或者说为什么大部分人觉得http code不够试用，是因为实际开发应用场景中，尝试着只用http code 去表达上述两个层面的结果。</p><p>分层表示的优点：</p><ol><li>RPC请求， 是可以基于不同的底层协议的， 比如我们用的HTTP协议，很容易替换成ZeroMQ, RabbitMQ,  UDP， 基于TCP的自定义协议…… 只要能实现一问一答模型的协议，都是可以用的。这个时候， HTTP协议只是一种底层协议， 底层协议的错误号，并不应该被上层协议使用。</li></ol><h4 id="2-HTTP-Code-表达能力局限性"><a href="#2-HTTP-Code-表达能力局限性" class="headerlink" title="2. HTTP Code 表达能力局限性"></a>2. HTTP Code 表达能力局限性</h4><p>虽然HTTP协议非常友好的定义了诸多的HTTP Code码，但在实际开发应用中，对于繁多的应用场景，HTTP Code的表达能力显得力不从心，部分场景仍旧不能避免的辅以Response Body信息。加之这些HTTP Code并不是应用开发中的绝对标准。</p><h4 id="3-HTTP-Code-语义表达的不统一性"><a href="#3-HTTP-Code-语义表达的不统一性" class="headerlink" title="3. HTTP Code 语义表达的不统一性"></a>3. HTTP Code 语义表达的不统一性</h4><p>[1] 同样是HTTP 4XX系列，不同系统的解释也是不一样的<br>[2] 同样是”参数校验不通过”的业务问题，不同系统使用的HTTP码也是不一样的</p><h4 id="4-Http-Code数量有限，表达能力有限"><a href="#4-Http-Code数量有限，表达能力有限" class="headerlink" title="4. Http Code数量有限，表达能力有限"></a>4. Http Code数量有限，表达能力有限</h4><p>这个应该很好理解，大家应该也有体会。</p><h4 id="5-系统集成友好性"><a href="#5-系统集成友好性" class="headerlink" title="5. 系统集成友好性"></a>5. 系统集成友好性</h4><p>如果我们把HTTP协议当作一种传输层协议看待，200 可以很好表达， 整个底层传输都是没有问题， 包括负载均衡系统， nginx， 反向代理， fast cgi守护程序都是工作正常的。</p><p>而返回各种HTTP Status Code经常会让外部使用者非常的困惑，特别是他们对HTTP Status Code有一定了解，却对你的系统不甚了解的情况下。</p><p>所以，除了考虑ajax请求的处理，还要考虑整个调用的中间链路以及框架集成方面的因素</p><ul><li>返回200能避免CDN等中间商替换或缓存<ul><li>国内的通信运营商画蛇添足根据HTTP状态码给替换成导航页或广告推广页面</li></ul></li><li>对于系统审计程序不友好，例如 HTTP Response Code = 4XX的请求算请求成功？请求失败？请求异常？————无法区分！</li></ul><h4 id="6-扩展性"><a href="#6-扩展性" class="headerlink" title="6. 扩展性"></a>6. 扩展性</h4><ul><li>返回200OK，扩展性更强，修改的时候只需要修改字段而不需要特别处理Status Code</li><li>易于与真正的400错误区分，方便审计和分析。而实际上，当服务器能够正常返回，证明服务器已经正确的理解并得出相应的结果（并且这个结果也是预定义的，并非未知），这显然与400的定义不符。</li><li>返回200更优。保不准哪天某种状态是HTTP协议不支持的，保不准哪个需要新增的字段是HTTP协议没有的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;其实，纠结只出现在例如保存表单的场景，如果服务端因各种业务上的原因（校验不通过，状态不满足等）导致保存未成功，并要返回对应的提示信息，此时服务端回应此HTTP 请求时，是用 “200 + json” 还是用“400 + 错误信息”？&lt;/p&gt;
&lt;p&gt;在公司内不同项目间，两种风格都有，且小伙伴们各执己见。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://veryjj.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HTTP" scheme="https://veryjj.github.io/tags/HTTP/"/>
    
      <category term="WEB" scheme="https://veryjj.github.io/tags/WEB/"/>
    
      <category term="REST" scheme="https://veryjj.github.io/tags/REST/"/>
    
  </entry>
  
</feed>
