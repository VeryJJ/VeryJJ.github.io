<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>MySQL索引合并</title>
      <link href="/2018/05/06/MySQL%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6/"/>
      <content type="html"><![CDATA[<h2 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h2><p>MySQL 5.0版本之前，一个表一次只能选择并使用一个索引。</p><p>MySQL 5.1版本开始，引入了Index Merge Optimization技术，使得MySQL支持一个表一次查询同时使用多个索引。</p><p>官方文档：<a href="https://dev.mysql.com/doc/refman/5.5/en/index-merge-optimization.html" target="_blank" rel="noopener">MySQL Index Merge Optimization</a> </p><p>Index Merge Optimization支持三种合并算法</p><ul><li>The Index Merge Intersection Access Algorithm<ul><li>对应SQL 中的 AND 场景</li></ul></li><li>The Index Merge Union Access Algorithm<ul><li>对应SQL中的 OR 场景（where条件是等值判断）</li></ul></li><li>The Index Merge Sort-Union Access Algorithm<ul><li>对应SQL中的 OR 场景（where条件是范围查询）</li></ul></li></ul><a id="more"></a><blockquote><p>注：索引合并(Index Merge)的使用取决于optimizer_switch系统变量的index_merge，index_merge_intersection，index_merge_union和index_merge_sort_union标志的值。默认情况下，所有这些标志都打开。 要仅启用特定算法，请将index_merge设置为关闭，并仅启用其他应允许的其他算法。</p></blockquote><p>##关于”Index Merge Intersection Access Algorithm”的疑问</p><blockquote><p>针对 MySQL Index Merge Optimization Intersection Algorithm</p></blockquote><p>AND 场景的 index merge optimization为什么会比使用单个索引来的高效？</p><p>设想：</p><ul><li><p>使用单个索引的场景</p><ol><li>选中选择性高的索引先获得一份数据</li><li>在再mysql服务器端用using where的方式，按第二条件进行过滤，得到最终满足所有条件的数据行。</li></ol></li><li><p>同时使用表内多个索引的场景</p><ol><li>按每个索引，在索引树里拿只满足本索引条件的行数据</li><li>将两份行数据，放一块进行交集运算。</li><li>从索引的次数、磁盘IO、内存交接运算来看，事情没变少、反而变多了。</li></ol></li></ul><hr><h2 id="自我初版解释"><a href="#自我初版解释" class="headerlink" title="自我初版解释"></a>自我初版解释</h2><h4 id="合理的解释"><a href="#合理的解释" class="headerlink" title="合理的解释"></a>合理的解释</h4><p>样例SQL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_sample where column_1 = A AND column_2 = B;</span><br></pre></td></tr></table></figure></p><ol><li>前提条件，SQL中不能有范围查询，如果存在范围查询，数据库优化器默认使用单索引方式，不用index merge optimization</li><li>SQL的<code>WHERE从句中的所有条件字段都有对应的索引</code>，否则问题就来了，肯定会在内存中有次using_where的。</li><li>单表多Index并行检索时，拿到的是数据行地址，以上述SQL为例，即拿到了两份行数据地址：Index Column_1的行数据地址集，Index Column_2的行数据地址集</li><li>再在内存中完成两份行数据地址集的交集运算（只需要比地址）</li><li>此时，再决定是否回表拿更多的数据。<ul><li>如果字段中有primary key，就不用回表啦！</li></ul></li></ol><ul><li>如上的执行步骤，就会比较合理。有效率上的优势。</li></ul><h4 id="【更进一步】-explain-显示type-为-index-merge时，到底要不要引起关注？"><a href="#【更进一步】-explain-显示type-为-index-merge时，到底要不要引起关注？" class="headerlink" title="【更进一步】 explain 显示type 为 index_merge时，到底要不要引起关注？"></a>【更进一步】 explain 显示type 为 index_merge时，到底要不要引起关注？</h4><p><code>【需要引起注意】</code></p><p>拿着SQL琢磨下，是否还有优化的空间，例如：采用组合索引；强制走单索引（需要对比测试看效果，还要看业务数据场景和增长趋势）；</p><hr><p>注：</p><ol><li>当索引本身信息可以覆盖select的字段时（或是select count(*)）,效率会很高，因为内存索引里已经能提供返回的数据了，不用回表。</li><li>当索引本身信息不能覆盖select的字段时，就要回表查行数据了，性能差别很大。</li></ol>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL子查询很慢的问题分析</title>
      <link href="/2018/05/04/MySQL%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%BE%88%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<hr><h2 id="慢查询案例"><a href="#慢查询案例" class="headerlink" title="慢查询案例"></a>慢查询案例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> settlement_invoice_attachment g1 <span class="keyword">WHERE</span> demand_id <span class="keyword">in</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> settlement_invoice_demand g2 <span class="keyword">WHERE</span> statement_id = <span class="number">1802065000000074956</span>)</span><br></pre></td></tr></table></figure><p>乍眼一看，上述SQL如此简单，且demand_id和statement_id字段都是建了索引，即使是Review也会认为是OK没问题的。</p><p>然而，实际情况却是个慢查询，情况如下：</p><p><strong>explain明细</strong></p><p><img src="/2018/05/04/MySQL子查询很慢的问题分析/img-1.png" alt="image"></p><a id="more"></a><p>settlement_invoice_attachment是全表查</p><p>注：rows 2689 是因为用的测试环境，真线环境数据是几十万级别</p><hr><h4 id="子查询-原理分析-上述SQL子查询为什么这么慢"><a href="#子查询-原理分析-上述SQL子查询为什么这么慢" class="headerlink" title="子查询 原理分析(上述SQL子查询为什么这么慢)"></a>子查询 原理分析(上述SQL子查询为什么这么慢)</h4><h5 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a><code>经验之谈</code></h5><ul><li>当看到SQL执行计划中select_type字段出现“DEPENDENT SUBQUERY”的时候，要打起精神了！着重分析下潜在风险！</li></ul><h5 id="基础知识：Dependent-SubQuery意味着什么？"><a href="#基础知识：Dependent-SubQuery意味着什么？" class="headerlink" title="基础知识：Dependent SubQuery意味着什么？"></a>基础知识：Dependent SubQuery意味着什么？</h5><ul><li>官方含义为：<ol><li>SUBQUERY: 子查询中的第一个SELECT；</li><li>DEPENDENT SUBQUERY: 子查询中的第一个SELECT， 取决于外面的查询。</li></ol></li></ul><p>换句话说，就是<code>子查询的g2查询执行方式依赖于外层g1的查询结果</code><br>什么意思呢？它以为着两步走：</p><ul><li>第一步：【先执行外部SQL查询】MySQL根据”DELETE FROM settlement_invoice_attachment g1 WHERE” 得到一个大结果集t1，其数据量就是全表所有行了，假设是85万行。</li><li>第二步：【后执行内部SQL子查询】第一步的大结果集t1中的每一条记录，都将与子查询SQL组成新的查询语句：SELECT id FROM settlement_invoice_demand g2 WHERE statement_id = 1802065000000074956 AND id = %t1.demand_id%。等于说，子查询要执行85万次……即使这两部查询都用到了索引，也是巨慢的。</li></ul><h5 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h5><ul><li>改写SQL为JOIN的方式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> ah <span class="keyword">FROM</span> settlement_invoice_attachment ah <span class="keyword">INNER</span> <span class="keyword">JOIN</span> settlement_invoice_demand de </span><br><span class="line"><span class="keyword">ON</span> ah.demand_id = de.id <span class="keyword">WHERE</span> de.statement_id = <span class="number">1802065000000074956</span>;</span><br></pre></td></tr></table></figure><ul><li>拆成独立SQL多次执行</li></ul><hr><h4 id="平时怎么识别？"><a href="#平时怎么识别？" class="headerlink" title="平时怎么识别？"></a>平时怎么识别？</h4><ul><li>看子查询出现的位置<ul><li>若子查询出现在WHERE从句中，而且是出现在IN（）中，则需要引起注意，用Explain瞧瞧（并不是子查询放IN（）里就一定是全表扫，本案例用，将DELETE改成SELECT就不是DEPENDENT SUBQUERY）</li></ul></li></ul><h4 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h4><ol><li><p>MySQL处理子查询时，会(优化)改写子查询，但优化的不是很友好，一直受业界批评比较多</p><ul><li>有时候优化的挺糟糕的，特别是WHERE从句中的IN（）子查询</li></ul></li><li><p>MySQL 子查询的弱点</p><ul><li>mysql 在处理子查询时，会改写子查询。通常情况下，我们希望由内到外，先完成子查询的结果，然后再用子查询来驱动外查询的表，完成查询。</li></ul></li></ol><p>例如：select * from test where tid in(select fk_tid from sub_test where gid=10)<br>通常我们会感性地认为该 sql 的执行顺序是：</p><p>1、sub_test 表中根据 gid 取得 fk_tid(2,3,4,5,6)记录。<br>2、然后再到 test 中，带入 tid=2,3,4,5,6，取得查询数据。</p><p>但是实际mysql的处理方式为：<br>select <em> from test where exists (select </em> from sub_test where gid=10 and sub_test.fk_tid=test.tid)<br>mysql 将会扫描 test 中所有数据，每条数据都将会传到子查询中与 sub_test 关联，子查询不会先被执行，所以如果 test 表很大的话，那么性能上将会出现问题。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dubbo源码解析-Provider暴露服务</title>
      <link href="/2018/05/02/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Provider%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Dubbo Provider暴露服务的流程中，需要掌握几个核心抽象对象</p><ul><li>过程中的重要类<ul><li>ServiceConfig：记录了Dubbo Service所有相关的配置信息。<a href="#ServiceConfig">ServiceConfig作用</a></li><li>DubboProtocol：以Dubbo协议的方式暴露服务，并以此为中心维护所有相关的动态服务数据。</li><li>RegisterProtocol: 内部会加载具体的注册中心Register,例如：ZookeeperRegister。完成服务向注册中心注册的动作。</li><li>ServiceConfig#loadRegistries：解析获得注册中心地址列表</li></ul></li></ul><ul><li>过程中的重要对象<ul><li>com.alibaba.dubbo.common.URL: 服务发布的地址</li><li>Invoker: 对原Service Interface进行了代理封装，屏蔽了具体Service Interface的差异，方便统一管理和调用。</li><li>Exporter： 一个ServiceBean每向一个注册中心Register注册一次，就会生成已各Exporter。Exporter用于连接暴露服务的Url与本地Invoker的对应关系。</li><li>ExporterMap: 记录着服务地址和Exporter的对应关系</li></ul></li></ul><a id="more"></a><ul><li>来自Dubbo官方的几个架构设计图，先感觉下</li></ul><p><img src="/2018/05/02/Dubbo源码解析-Provider暴露服务/img-2.png" alt="image"></p><p><img src="/2018/05/02/Dubbo源码解析-Provider暴露服务/img-1.png" alt="image"></p><h2 id="ServiceBean核心流程"><a href="#ServiceBean核心流程" class="headerlink" title="ServiceBean核心流程"></a>ServiceBean核心流程</h2><ol><li>Spring容器启动，带动Dubbo Bean配置解析以及Bean实例化。<ul><li><a href="#Dubbo 启动">Dubbo启动</a></li><li>关键类：<ul><li>DubboNamespaceHandler</li><li>ServiceBean</li><li><a href="#ServiceConfig">ServiceConfig作用</a></li></ul></li></ul></li><li>ServiceBean 继承了ServiceConfig，所有的Provider服务的Dubbo配置都在ServiceConfig中。<ul><li>Dubbo Service基本信息</li><li>Dubbo Service参数配置</li><li>注册中心地址信息。对应ServiceConfig中的loadRegistries().</li></ul></li><li>ServiceBean 实现了InitializingBean, 实现了afterPropertiesSet()方法，在每个Dubbo Service Bean实例化后，在afterPropertiesSet()方法中进行所有Dubbo服务注册需要的操作。</li><li>afterPropertiesSet()中前置代码都是在做一些配置校验和默认值设置，最后会执行export()方法注册暴露服务。</li><li>afterPropertiesSet()<ul><li>export()<ul><li>doExport()<ul><li>doExportUrls()<ul><li>doExportUrlsFor1Protocol(DubboProtocol, regitsryURLs)<ul><li>DubboProtocol.export(wrapperInvoker)</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<url> registryURLs) 是真正执行export暴露服务的代码区<ul><li></li></ul></url></li></ol><h2 id="DubboProtocol-Export核心流程"><a href="#DubboProtocol-Export核心流程" class="headerlink" title="DubboProtocol#Export核心流程"></a>DubboProtocol#Export核心流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// export service.</span></span><br><span class="line">    String key = serviceKey(url);</span><br><span class="line">    DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//export an stub service for dispatching event</span></span><br><span class="line">    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">        <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"consumer ["</span> + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">                        <span class="string">"], has set stubproxy support event ,but no stub methods founded."</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个服务端口，使用NettyServer绑定并监听，并设置Server监听事件处理回调为：DubboProtocol#requestHandler</span></span><br><span class="line">    <span class="comment">//Exchanger.bind的实际对象可配置，对应dubbo-remoting-api包</span></span><br><span class="line">    openServer(url);   </span><br><span class="line">    optimizeSerialization(url);</span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DubboProtocol核心数据"><a href="#DubboProtocol核心数据" class="headerlink" title="DubboProtocol核心数据"></a>DubboProtocol核心数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DubboProtocol INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//本地启动Server监听服务的Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ExchangeServer&gt; serverMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ExchangeServer&gt;(); <span class="comment">// &lt;host:port,Exchanger&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录消费端的Exchanger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ReferenceCountExchangeClient&gt; referenceClientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ReferenceCountExchangeClient&gt;(); <span class="comment">// &lt;host:port,Exchanger&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, LazyConnectExchangeClient&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; optimizers = <span class="keyword">new</span> ConcurrentHashSet&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//consumer side export a stub service for dispatching event</span></span><br><span class="line">    <span class="comment">//servicekey-stubmethods</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, String&gt; stubServiceMethodsMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> ExchangeHandler requestHandler = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ExporterMap</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Exporter&lt;?&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dubbo-Service是哪个时机注册到注册中心的？"><a href="#Dubbo-Service是哪个时机注册到注册中心的？" class="headerlink" title="Dubbo Service是哪个时机注册到注册中心的？"></a>Dubbo Service是哪个时机注册到注册中心的？</h3><blockquote><p>有关注到这个章节内容的小伙伴，说明你此时可能也还没想通吧，请听我道来。</p></blockquote><p>这里会涉及到Dubbo的SPI机制，Dubbo 有好几个利用SPI+动态代理+Filter的处理责任链模式，ProtocolFilterWrapper.java算一个。  </p><pre><code>- Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</code></pre><p>在Dubbo源码中，Dubbo有自行注册几个protocol SPI （这里只列举Dubbo服务注册相关的） </p><ul><li><a href="http://dubbo.apache.org/books/dubbo-dev-book/SPI.html" target="_blank" rel="noopener">SPI机制用法详见</a></li><li><a href="http://dubbo.apache.org/books/dubbo-dev-book/impls/protocol.html" target="_blank" rel="noopener">Dubbo Protocol SPI扩展详见</a></li><li>RegistryProtocol SPI: <ul><li>注册位置：dubbo-registry-api包,resources下的com.alibaba.dubbo.rpc.Protocol</li><li>注册位置：dubbo-registry-zookeeper包,resources下的com.alibaba.dubbo.register.RegistryFactory</li></ul></li></ul><p>其实，在ServiceConfig中拿到的全局protocol并不直接是DubboProtocol，而是一串Protocol，DubboProtocol只是其中之一，这些Protocol会以责任链的方式逐一被调用</p><p>所以，在doExportUrlsFor1Protocol中protocol.export(…)时，会先执行DubboProtocol#export,再执行RegisterProtocol#export,各司其职。</p><p>RegisterProtocol中会根据Dubbo Service配置的register地址类型来决定加载哪个具体的RegisterFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registedProviderUrl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//RegisterFactory根据注册中心类型，获取到注册实例，例如ZookeeperRegistry</span></span><br><span class="line">        Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行注册，实际对应ZookeeperRegistry#register</span></span><br><span class="line">        registry.register(registedProviderUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (register) &#123;</span><br><span class="line">            register(registryUrl, registedProviderUrl);</span><br><span class="line">            ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Netty-Server"><a href="#Netty-Server" class="headerlink" title="Netty Server"></a>Netty Server</h3><p>当DubboProtocol.export.openServer()时，就是在本地启动Dubbo Service的Server服务并启动监听。</p><p>实现上是通过Exchanger拿到被配置的信息交换层的实现套件（一般是Netty）。  </p><pre><code>- 获取一个服务端口，使用NettyServer绑定并监听，并设置Server监听事件处理回调为：DubboProtocol#requestHandler- Exchanger.bind的实际对象可配置，对应dubbo-remoting-api包</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Channel&gt; channels; <span class="comment">// &lt;ip:port, channel&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerBootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> org.jboss.netty.channel.Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        NettyHelper.setNettyLoggerFactory();</span><br><span class="line">        ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br><span class="line">        ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line">        ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">        channels = nettyHandler.getChannels();</span><br><span class="line">        <span class="comment">// https://issues.jboss.org/browse/NETTY-365</span></span><br><span class="line">        <span class="comment">// https://issues.jboss.org/browse/NETTY-379</span></span><br><span class="line">        <span class="comment">// final Timer timer = new HashedWheelTimer(new NamedThreadFactory("NettyIdleTimer", true));</span></span><br><span class="line">        bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">                ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">                <span class="comment">/*int idleTimeout = getIdleTimeout();</span></span><br><span class="line"><span class="comment">                if (idleTimeout &gt; 10000) &#123;</span></span><br><span class="line"><span class="comment">                    pipeline.addLast("timer", new IdleStateHandler(timer, idleTimeout / 1000, 0, 0));</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">                pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">                pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">                pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">                <span class="keyword">return</span> pipeline;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// bind</span></span><br><span class="line">        channel = bootstrap.bind(getBindAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Channel <span class="title">getChannel</span><span class="params">(InetSocketAddress remoteAddress)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBound</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ServiceConfig作用-见代码注释"><a href="#ServiceConfig作用-见代码注释" class="headerlink" title="ServiceConfig作用(见代码注释)"></a><span id="ServiceConfig">ServiceConfig作用(见代码注释)</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用的protocol远程调用层实现，用于封装RPC调用，默认是DubboProtocol，其余可选还有HttpProtocol,HessianProtocol,InjvmProtocol,RedisProtocol等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对ServiceBean进行代理，包装成Dubbo内部通用的Invoker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ServiceBean作为Dubbo Provider启动时，会在本地起server服务，每个server服务都会绑定并监听端口。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; RANDOM_PORT_MAP = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录已暴露服务的服务地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个ServiceBean每向一个注册中心Register注册一次，就会生成已各Exporter。Exporter用于连接暴露服务的Url与本地Invoker的对应关系。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Exporter&lt;?&gt;&gt; exporters = <span class="keyword">new</span> ArrayList&lt;Exporter&lt;?&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关于本ServiceBean的Java Class信息</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line">    <span class="comment">// reference to interface impl</span></span><br><span class="line">    <span class="keyword">private</span> T ref;</span><br><span class="line">    <span class="comment">// service name</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">// method configuration</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MethodConfig&gt; methods;</span><br><span class="line">    <span class="keyword">private</span> ProviderConfig provider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exported;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> unexported;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String generic;</span><br></pre></td></tr></table></figure><h3 id="Dubbo-启动"><a href="#Dubbo-启动" class="headerlink" title="Dubbo 启动"></a><span id="Dubbo 启动">Dubbo 启动</span></h3><p>Spring容器启动，带动Dubbo Bean配置实例化。Dubbo Bean配置来自于Dubbo Provider XML 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"application"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"module"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"registry"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"monitor"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"protocol"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"service"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class="keyword">true</span>));  <span class="comment">//dubbo provider bean配置解析</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"reference"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class="keyword">false</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation"</span>, <span class="keyword">new</span> AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体详见笔记：<a href="/2018/04/22/Dubbo源码解析-Spring-Bean注册/">Dubbo源码解析-Spring Bean注册</a></li></ul><h3 id="ServiceBean实例化"><a href="#ServiceBean实例化" class="headerlink" title="ServiceBean实例化"></a>ServiceBean实例化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean 继承了ServiceConfig，所有的Provider服务的Dubbo配置都在ServiceConfig中。</p><p>ServiceBean 实现了InitializingBean, 实现了afterPropertiesSet()方法，在每个Dubbo Service Bean实例化后，进行暴露服务的相关操作。</p><p>afterPropertiesSet()中前置代码都是在做一些配置校验和默认值设置，最后会执行export()方法注册暴露服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">//如果没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> (getProvider() == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">//获取IOC容器里的所有provider  </span></span><br><span class="line">            Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span>  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (providerConfigMap != <span class="keyword">null</span> &amp;&amp; providerConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span>  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">                <span class="keyword">if</span> ((protocolConfigMap == <span class="keyword">null</span> || protocolConfigMap.size() == <span class="number">0</span>)  </span><br><span class="line">                        &amp;&amp; providerConfigMap.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// 兼容旧版本  </span></span><br><span class="line">                    List&lt;ProviderConfig&gt; providerConfigs = <span class="keyword">new</span> ArrayList&lt;ProviderConfig&gt;();  </span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() != <span class="keyword">null</span> &amp;&amp; config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                            providerConfigs.add(config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="comment">//关联所有providers  </span></span><br><span class="line">                    <span class="keyword">if</span> (providerConfigs.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                        setProviders(providerConfigs);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    ProviderConfig providerConfig = <span class="keyword">null</span>;  </span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                            <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate provider configs: "</span> + providerConfig + <span class="string">" and "</span> + config);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            providerConfig = config;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                        setProvider(providerConfig);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置application，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span>  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getApplication() == <span class="keyword">null</span>)) &#123;  </span><br><span class="line">            <span class="comment">//获取所有applications  </span></span><br><span class="line">            Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (applicationConfigMap != <span class="keyword">null</span> &amp;&amp; applicationConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                ApplicationConfig applicationConfig = <span class="keyword">null</span>;  </span><br><span class="line">                <span class="keyword">for</span> (ApplicationConfig config : applicationConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate application configs: "</span> + applicationConfig + <span class="string">" and "</span> + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        applicationConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联application  </span></span><br><span class="line">                <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    setApplication(applicationConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置module，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> (getModule() == <span class="keyword">null</span>  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getModule() == <span class="keyword">null</span>)) &#123;  </span><br><span class="line">            Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (moduleConfigMap != <span class="keyword">null</span> &amp;&amp; moduleConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                ModuleConfig moduleConfig = <span class="keyword">null</span>;  </span><br><span class="line">                <span class="keyword">for</span> (ModuleConfig config : moduleConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate module configs: "</span> + moduleConfig + <span class="string">" and "</span> + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        moduleConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联module  </span></span><br><span class="line">                <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    setModule(moduleConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置registries，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> ((getRegistries() == <span class="keyword">null</span> || getRegistries().size() == <span class="number">0</span>)  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getRegistries() == <span class="keyword">null</span> || getProvider().getRegistries().size() == <span class="number">0</span>)  </span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getRegistries() == <span class="keyword">null</span> || getApplication().getRegistries().size() == <span class="number">0</span>)) &#123;  </span><br><span class="line">            Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (registryConfigMap != <span class="keyword">null</span> &amp;&amp; registryConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                List&lt;RegistryConfig&gt; registryConfigs = <span class="keyword">new</span> ArrayList&lt;RegistryConfig&gt;();  </span><br><span class="line">                <span class="keyword">for</span> (RegistryConfig config : registryConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        registryConfigs.add(config);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联registries  </span></span><br><span class="line">                <span class="keyword">if</span> (registryConfigs != <span class="keyword">null</span> &amp;&amp; registryConfigs.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="keyword">super</span>.setRegistries(registryConfigs);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置monitor，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> (getMonitor() == <span class="keyword">null</span>  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getMonitor() == <span class="keyword">null</span>)  </span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getMonitor() == <span class="keyword">null</span>)) &#123;  </span><br><span class="line">            Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (monitorConfigMap != <span class="keyword">null</span> &amp;&amp; monitorConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                MonitorConfig monitorConfig = <span class="keyword">null</span>;  </span><br><span class="line">                <span class="keyword">for</span> (MonitorConfig config : monitorConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate monitor configs: "</span> + monitorConfig + <span class="string">" and "</span> + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        monitorConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联monitor  </span></span><br><span class="line">                <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    setMonitor(monitorConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置protocol，且没有配置provider  </span></span><br><span class="line">        <span class="keyword">if</span> ((getProtocols() == <span class="keyword">null</span> || getProtocols().size() == <span class="number">0</span>)  </span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getProtocols() == <span class="keyword">null</span> || getProvider().getProtocols().size() == <span class="number">0</span>)) &#123;  </span><br><span class="line">            Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span>  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (protocolConfigMap != <span class="keyword">null</span> &amp;&amp; protocolConfigMap.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                List&lt;ProtocolConfig&gt; protocolConfigs = <span class="keyword">new</span> ArrayList&lt;ProtocolConfig&gt;();  </span><br><span class="line">                <span class="keyword">for</span> (ProtocolConfig config : protocolConfigMap.values()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        protocolConfigs.add(config);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//关联protocol  </span></span><br><span class="line">                <span class="keyword">if</span> (protocolConfigs != <span class="keyword">null</span> &amp;&amp; protocolConfigs.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="keyword">super</span>.setProtocols(protocolConfigs);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果没有配置path  </span></span><br><span class="line">        <span class="keyword">if</span> (getPath() == <span class="keyword">null</span> || getPath().length() == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; beanName.length() &gt; <span class="number">0</span>   </span><br><span class="line">                    &amp;&amp; getInterface() != <span class="keyword">null</span> &amp;&amp; getInterface().length() &gt; <span class="number">0</span>  </span><br><span class="line">                    &amp;&amp; beanName.startsWith(getInterface())) &#123;  </span><br><span class="line">                setPath(beanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//暴露provider,重点！！！</span></span><br><span class="line">        <span class="keyword">if</span> (! isDelay()) &#123;  </span><br><span class="line">            export();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Export暴露服务"><a href="#Export暴露服务" class="headerlink" title="Export暴露服务"></a>Export暴露服务</h3><ul><li>export()方法会完成后续服务注册的所有流程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//如果provider没有配置  </span></span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">//如果exporter没有配置使用provider所关联的exporter  </span></span><br><span class="line">            <span class="keyword">if</span> (export == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                export = provider.getExport();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//如果delay（延迟暴露）没有配置，获取provider的delay  </span></span><br><span class="line">            <span class="keyword">if</span> (delay == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                delay = provider.getDelay();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果不需要暴露接口则直接返回  </span></span><br><span class="line">        <span class="keyword">if</span> (export != <span class="keyword">null</span> &amp;&amp; ! export.booleanValue()) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果延迟暴露的时间（毫秒级）是存在的，开启线程并等待delay毫秒后开始暴露接口，否则直接执行暴露接口过程  </span></span><br><span class="line">        <span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        Thread.sleep(delay);  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    doExport();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">            thread.setDaemon(<span class="keyword">true</span>);  </span><br><span class="line">            thread.setName(<span class="string">"DelayExportServiceThread"</span>);  </span><br><span class="line">            thread.start();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            doExport();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务端业务处理不成功，应该返回HTTP 200 还是 HTTP 4XXX系列？</title>
      <link href="/2018/04/23/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E4%B8%8D%E6%88%90%E5%8A%9F%EF%BC%8C%E5%BA%94%E8%AF%A5%E8%BF%94%E5%9B%9EHTTP-200-%E8%BF%98%E6%98%AF-HTTP-4XXX%E7%B3%BB%E5%88%97%EF%BC%9F/"/>
      <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>其实，纠结只出现在例如保存表单的场景，如果服务端因各种业务上的原因（校验不通过，状态不满足等）导致保存未成功，并要返回对应的提示信息，此时服务端回应此HTTP 请求时，是用 “200 + json” 还是用“400 + 错误信息”？</p><p>在公司内不同项目间，两种风格都有，且小伙伴们各执己见。</p><a id="more"></a><h2 id="我这么看"><a href="#我这么看" class="headerlink" title="我这么看"></a>我这么看</h2><p>首先，我先表达我赞同“200 + json”的方式。</p><p>更具体些，服务端所有的Controller Method对返回值做统一的Response包装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">样例<span class="number">1</span>：</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"code"</span>: <span class="number">200</span>,</span><br><span class="line">   <span class="string">"data"</span>: &#123;...&#125;,</span><br><span class="line">   <span class="string">"message"</span>:<span class="string">"操作成功"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">样例<span class="number">2</span>：</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"success"</span>: <span class="keyword">false</span></span><br><span class="line">   <span class="string">"data"</span>: &#123;...&#125;,</span><br><span class="line">   <span class="string">"code"</span>: <span class="number">100409</span>,</span><br><span class="line">   <span class="string">"message"</span>:<span class="string">"数据已存在"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我的观点"><a href="#我的观点" class="headerlink" title="我的观点"></a>我的观点</h3><h4 id="1-协议分层"><a href="#1-协议分层" class="headerlink" title="1. 协议分层"></a>1. 协议分层</h4><p>对于RPC请求，存在两个层面的操作结果</p><p>[1] HTTP请求本身的结果 ———— 业务无关性，与网络、框架层面相关<br>[2] 业务处理的结果 ———— 强业务逻辑相关性，与网络、框架层面无关</p><p>为什么我们会有本贴讨论的话题与分歧，或者说为什么大部分人觉得http code不够试用，是因为实际开发应用场景中，尝试着只用http code 去表达上述两个层面的结果。</p><p>分层表示的优点：</p><ol><li>RPC请求， 是可以基于不同的底层协议的， 比如我们用的HTTP协议，很容易替换成ZeroMQ, RabbitMQ,  UDP， 基于TCP的自定义协议…… 只要能实现一问一答模型的协议，都是可以用的。这个时候， HTTP协议只是一种底层协议， 底层协议的错误号，并不应该被上层协议使用。</li></ol><h4 id="2-HTTP-Code-表达能力局限性"><a href="#2-HTTP-Code-表达能力局限性" class="headerlink" title="2. HTTP Code 表达能力局限性"></a>2. HTTP Code 表达能力局限性</h4><p>虽然HTTP协议非常友好的定义了诸多的HTTP Code码，但在实际开发应用中，对于繁多的应用场景，HTTP Code的表达能力显得力不从心，部分场景仍旧不能避免的辅以Response Body信息。加之这些HTTP Code并不是应用开发中的绝对标准。</p><h4 id="3-HTTP-Code-语义表达的不统一性"><a href="#3-HTTP-Code-语义表达的不统一性" class="headerlink" title="3. HTTP Code 语义表达的不统一性"></a>3. HTTP Code 语义表达的不统一性</h4><p>[1] 同样是HTTP 4XX系列，不同系统的解释也是不一样的<br>[2] 同样是”参数校验不通过”的业务问题，不同系统使用的HTTP码也是不一样的</p><h4 id="4-Http-Code数量有限，表达能力有限"><a href="#4-Http-Code数量有限，表达能力有限" class="headerlink" title="4. Http Code数量有限，表达能力有限"></a>4. Http Code数量有限，表达能力有限</h4><p>这个应该很好理解，大家应该也有体会。</p><h4 id="5-系统集成友好性"><a href="#5-系统集成友好性" class="headerlink" title="5. 系统集成友好性"></a>5. 系统集成友好性</h4><p>如果我们把HTTP协议当作一种传输层协议看待，200 可以很好表达， 整个底层传输都是没有问题， 包括负载均衡系统， nginx， 反向代理， fast cgi守护程序都是工作正常的。</p><p>而返回各种HTTP Status Code经常会让外部使用者非常的困惑，特别是他们对HTTP Status Code有一定了解，却对你的系统不甚了解的情况下。</p><p>所以，除了考虑ajax请求的处理，还要考虑整个调用的中间链路以及框架集成方面的因素</p><ul><li>返回200能避免CDN等中间商替换或缓存<ul><li>国内的通信运营商画蛇添足根据HTTP状态码给替换成导航页或广告推广页面</li></ul></li><li>对于系统审计程序不友好，例如 HTTP Response Code = 4XX的请求算请求成功？请求失败？请求异常？————无法区分！</li></ul><h4 id="6-扩展性"><a href="#6-扩展性" class="headerlink" title="6. 扩展性"></a>6. 扩展性</h4><ul><li>返回200OK，扩展性更强，修改的时候只需要修改字段而不需要特别处理Status Code</li><li>易于与真正的400错误区分，方便审计和分析。而实际上，当服务器能够正常返回，证明服务器已经正确的理解并得出相应的结果（并且这个结果也是预定义的，并非未知），这显然与400的定义不符。</li><li>返回200更优。保不准哪天某种状态是HTTP协议不支持的，保不准哪个需要新增的字段是HTTP协议没有的</li></ul>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> WEB </tag>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dubbo源码解析-Spring Bean注册</title>
      <link href="/2018/04/22/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring-Bean%E6%B3%A8%E5%86%8C/"/>
      <content type="html"><![CDATA[<p>相信大家对于Dubbo Provider/Consumer的配置非常熟练，但这背后的实现原理清楚吗？如果有不太清楚的朋友，可以再往下阅读下。</p><a id="more"></a><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>自定义 Spring XML Bean机制</li></ul><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>据我们所知</p><p>Spring 注解方式声明Bean的方式是在Class上打上@Component注解（@Component的扩展注解也可），当Spring容器启动时，Spring会自动扫面所有带有@Component注解的Class，自动注册到Bean容器中。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过XML文件配置的方式声明Bean</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Student"</span> <span class="attr">class</span>=<span class="string">"com.test.spring.beans.Student"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但，回过头来看Dubbo，我们并没有通过上述的方式去声明Dubbo配置中的Bean，却也能像使用Spring Bean一样用@Autowire去注入Dubbo服务的Bean，这其中的原理是什么呢？让我们从源码中找答案。</p><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="启动Spring容器"><a href="#启动Spring容器" class="headerlink" title="启动Spring容器"></a>启动Spring容器</h3><p>在SpringBoot+Dubbo的搭配中，Java应用的启动入口main方法一般会这么写。通过此步骤去启动Java程序并将Dubbo Bean注册Spring容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sample;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;</span><br><span class="line">        <span class="string">"com.sample.myapp"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//启动Spring容器</span></span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(MyApplication.class,  </span><br><span class="line">                <span class="string">"classpath:/spring/dubbo-config.xml"</span>);  <span class="comment">//指定Dubbo配置文件</span></span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring如何识别Dubbo-自定义Bean标签"><a href="#Spring如何识别Dubbo-自定义Bean标签" class="headerlink" title="Spring如何识别Dubbo 自定义Bean标签"></a>Spring如何识别Dubbo 自定义Bean标签</h3><p>Spring为了支持用户自定义类加载到Spring容器，提供了org.springframework.beans.factory.xml.NamespaceHandler接口和org.springframework.beans.factory.xml.NamespaceHandlerSupport抽象类，NamespaceHandler#init方法会在对象的构造函数调用之后、属性初始化之前被DefaultNamespaceHandlerResolver调用。dubbo的DubboNamespaceHandler类正是继承了NamespaceHandlerSupport，其代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"application"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"module"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"registry"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"monitor"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"protocol"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"service"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"reference"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class="keyword">false</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation"</span>, <span class="keyword">new</span> AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerBeanDefinitionParser方法使用的是父抽象类NamespaceHandlerSupport的默认实现，第一个参数是elementName，即元素名称，即告诉Spring你要解析哪个标签，第二个参数是BeanDefinitionParser的实现类，BeanDefinitionParser是Spring用来将xml元素转换成BeanDefinition对象的接口。dubbo的DubboBeanDefinitionParser类就实现了这个接口，负责将标签转换成bean定义对象BeanDefinition。</p><p>所以，以后想要了解Dubbo Bean初始化相关细节，可以查看DubboBeanDefinitionParser#parse的代码实现。</p><p>例如：</p><ul><li>Dubbo Bean 会有哪些默认设置<ul><li>dubbo服务提供者使用dubbo:service标签时，如果既不设置id，也不设置name，则dubbo给ServiceBean在Spring容器中定义的ID是什么？</li></ul></li><li>Dubbo xml文件中的配置是怎么作用到Dubbo Bean中去的</li></ul><h4 id="关于NamespaceHandlerSupport"><a href="#关于NamespaceHandlerSupport" class="headerlink" title="关于NamespaceHandlerSupport"></a>关于NamespaceHandlerSupport</h4><ul><li>spring.handlers           # 指定xml namespace的解析handler类</li><li>spring.schemas            # 指定xml xsd文件位置</li><li>dubbo.xsd                 # 设计你要的xml配置格式</li><li>DubboNamespaceHandler     # 自定义NamespaceHandler,完成从xml中读取配置内容，并转换成Spring Bean进行注册</li></ul><p>Spring容器会默认加载classpath/META-INF下的spring.handlers和spring.schemas两个文件，来加载xsd和对应的NamespaceHandler,所以dubbo-config-spring包下的META-INF目录下也有这两个文件</p><hr><h2 id="练习DEMO"><a href="#练习DEMO" class="headerlink" title="练习DEMO"></a>练习DEMO</h2><p><strong>1. 设计配置属性和JavaBean</strong></p><p>设计好配置项，并通过JavaBean来建模，本例中需要配置People实体，配置属性name和age（id是默认需要的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String id;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> Integer age;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 编写XSD文件</strong></p><p>为上一步设计好的配置项编写XSD文件，XSD是schema的定义文件，配置的输入和解析输出都是以XSD为契约，本例中XSD如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;  </span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://veryjj/cutesource/schema/people"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:beans</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">targetNamespace</span>=<span class="string">"http://veryjj/cutesource/schema/people"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">elementFormDefault</span>=<span class="string">"qualified"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">attributeFormDefault</span>=<span class="string">"unqualified"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"people"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:complexType</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:complexContent</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">xsd:extension</span> <span class="attr">base</span>=<span class="string">"beans:identifiedType"</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span> /&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"xsd:int"</span> /&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">xsd:extension</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">xsd:complexContent</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于xsd:schema的各个属性具体含义就不作过多解释，可以参见<a href="http://www.w3school.com.cn/schema/schema_schema.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/schema/schema_schema.asp</a></p><p>&lt;xsd:element name=”people”&gt;对应着配置项节点的名称，因此在应用中会用people作为节点名来引用这个配置</p><p>&lt;xsd:attribute name=”name” type=”xsd:string” /&gt;和&lt;xsd:attribute name=”age” type=”xsd:int” /&gt;对应着配置项people的两个属性名，因此在应用中可以配置name和age两个属性，分别是string和int类型</p><p>完成后需把xsd存放在classpath下，一般都放在META-INF目录下（本例就放在这个目录下）</p><p><strong>3. 编写NamespaceHandler和BeanDefinitionParser完成解析工作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"people"</span>, <span class="keyword">new</span> PeopleBeanDefinitionParser());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Class <span class="title">getBeanClass</span><span class="params">(Element element)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> People.class;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder bean)</span> </span>&#123;  </span><br><span class="line">        String name = element.getAttribute(<span class="string">"name"</span>);  </span><br><span class="line">        String age = element.getAttribute(<span class="string">"age"</span>);  </span><br><span class="line">        String id = element.getAttribute(<span class="string">"id"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(id)) &#123;  </span><br><span class="line">            bean.addPropertyValue(<span class="string">"id"</span>, id);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(name)) &#123;  </span><br><span class="line">            bean.addPropertyValue(<span class="string">"name"</span>, name);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(age)) &#123;  </span><br><span class="line">            bean.addPropertyValue(<span class="string">"age"</span>, Integer.valueOf(age));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 编写spring.handlers和spring.schemas串联起所有部件</strong></p><p>spring提供了 spring.handlers和spring.schemas这两个配置文件来完成这项工作，这两个文件需要我们自己编写并放入META-INF文件夹 中，这两个文件的地址必须是META-INF/spring.handlers和META-INF/spring.schemas，spring会默认去 载入它们，本例中spring.handlers如下所示：</p><p>spring.handlers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://veryjj/cutesource/schema/people=study.schemaExt.MyNamespaceHandler</span><br></pre></td></tr></table></figure><p>spring.schemas</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://veryjj/cutesource/schema/people.xsd=META-INF/people.xsd</span><br></pre></td></tr></table></figure><p>以上就是载入xsd文件</p><p><strong>5. 使用自定义schema定义Spring Bean</strong></p><p>到此为止一个简单的自定义配置以完成，可以在具体应用中使用了。使用方法很简单，和配置一个普通的spring bean类似，只不过需要基于我们自定义schema，本例中引用方式如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:cutesource</span>=<span class="string">"http://veryjj/cutesource/schema/people"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://veryjj/cutesource/schema/people http://veryjj/cutesource/schema/people.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">cutesource:people</span> <span class="attr">id</span>=<span class="string">"cutesource"</span> <span class="attr">name</span>=<span class="string">"黄老师"</span> <span class="attr">age</span>=<span class="string">"27"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中xmlns:cutesource=”<a href="http://veryjj/cutesource/schema/people&quot;" target="_blank" rel="noopener">http://veryjj/cutesource/schema/people&quot;</a> 是用来指定自定义schema，xsi:schemaLocation用来指定xsd文件。&lt;cutesource:people id=”cutesource” name=”黄老师” age=”27”/&gt;是一个具体的自定义配置使用实例。</p><p><strong>6. 注入自定义schema定义的Spring Bean</strong></p><p>跟Spring Bean的注入方式完全一样，按你喜欢的方式来。</p><hr>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dubbo源码解析-Dubbo可以这么学</title>
      <link href="/2018/04/22/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Dubbo%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E5%AD%A6/"/>
      <content type="html"><![CDATA[<p>最近面试工作颇多，Dubbo作为的微服务主流技术架构，也是分布式系统中面试的高频考题之一。但从面试的过程中得到的反馈，大家对于Dubbo的关注以及掌握程度基本都处于会基本使用的程度，基本没遇到有对Dubbo框架做学习研究的求职者。</p><p>求职者一般只会聊下面两个话题：</p><ol><li>Dubbo 是什么东西？<ul><li>答：RPC框架/微服务框架，在实际工作中用Dubbo做业务功能服务化。</li></ul></li><li>Dubbo的工作原理是什么样的？<ul><li>答：Provider端将服务注册到Zookeeper中，Consumer端从Zookeeper获取Provider，然后就可以调用API了。</li></ul></li></ol><a id="more"></a><p>一般情况下关于Dubbo的基本都聊到此结束了，虽然说没回答错，但也忒简洁了吧，连Dubbo架构图中（下图）的内容都没说完整，而这并不是面试官想得到的讯息。</p><p><img src="/2018/04/22/Dubbo源码解析-Dubbo可以这么学/img-1.png" alt="image"></p><hr><p>Dubbo作为主流的微服务技术框架，必然有其优秀的一面，也是学习RPC框架思想很好的素材</p><p>Dubbo 应该掌握哪些内容？（个人思路）</p><ol><li>阅读Dubbo的用户手册以及开发手册。<a href="http://dubbo.apache.org" target="_blank" rel="noopener">Dubbo.io</a><ul><li>知晓Dubbo支持的功能</li><li>知晓Dubbo的各种扩展点</li><li>知晓Dubbo的设计思想（这里不得不说Dubbo.io的文档说明写的非常详细、到位，甚至一度让我觉得没有写Blog的必要）</li></ul></li><li>Dubbo 核心流程源码实现<ol><li>Dubbo Bean的集成</li><li>Provider 注册、暴露服务</li><li>Consumer 注册、订阅服务</li><li>Consumer 调用实现</li><li>Provider 处理请求</li><li>Dubbo SPI机制</li><li>Dubbo Filter机制</li></ol></li><li>思考些高级的<ol><li>Dubbo各可配机制主流选择的优缺点<ul><li>register</li><li>remoting</li><li>rpc</li></ul></li><li>Dubbo Cluster</li><li>Dubbo 怎么做服务治理<ul><li>策略路由</li><li>降级</li><li>熔断</li></ul></li><li>Dubbo 性能基线&amp;性能调优</li><li>框架扩展<ul><li>服务监控</li><li>流量分析</li></ul></li></ol></li></ol><p>那么，逐步的去落实吧！如果开始、请务必坚持！</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty 核心对象梳理-1</title>
      <link href="/2018/04/08/Netty-%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86-1/"/>
      <content type="html"><![CDATA[<p>《Netty In Action》阅读笔记摘要</p><p><img src="/2018/04/08/Netty-核心对象梳理-1/img-1.png" alt="image"></p><a id="more"></a><h2 id="What-is-Netty"><a href="#What-is-Netty" class="headerlink" title="What is Netty"></a>What is Netty</h2><p>Netty是一款用于快速<code>开发高性能的网络应用程序的Java框架</code> </p><ul><li>它封装了网络编程的复杂性</li></ul><p><strong>Key words:</strong>  </p><ol><li>是一款Java语言的开发框架</li><li>封装、提供程序快速网络编程的能力</li><li>高性能</li></ol><h5 id="Netty是完全异步和事件驱动的"><a href="#Netty是完全异步和事件驱动的" class="headerlink" title="Netty是完全异步和事件驱动的"></a>Netty是完全异步和事件驱动的</h5><hr><h2 id="Netty-核心组件"><a href="#Netty-核心组件" class="headerlink" title="Netty 核心组件"></a>Netty 核心组件</h2><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 是Java NIO的一个基本构造  </p><p>可以将Channel 看作是连接的载体。因此，它可以被打开、被关闭、连接、断开连接。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Channel连接上发生的事件。可以等价的理解为 epoll 中关于每个Socket事件，例如：EPOLLIN, EPOLLOUT, EPOLLHUP的回调    </p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>类似于常见的回调，Netty内部用回调来处理事件；  </p><p>可理解为 epoll 中关于每个Socket事件的回调，例如：EPOLLIN, EPOLLOUT, EPOLLHUP的回调。</p><p>应用程序可以自定义回调，感知Netty网络通信的事件。</p><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>Future提供了另一种在操作完成时通知应用程序的方式。</p><p>JDK中的java.util.concurrent.Future 在使用上是阻塞调用的，不优雅。Netty 提供了另一种实现：ChannelFuture，用于在执行异步操作的时候使用。  </p><p>Netty的每个出站I/O都将返回一个ChannelFuture。  </p><p>使用ChannelFuture时，可以配合使用ChannelFutureListener。只要实现operationComplete() 回调即可，非常方便。且支持多ChannelFuture。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line"><span class="comment">//Does not block </span></span><br><span class="line">ChannelFuture future = channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"192.168.0.1"</span>, <span class="number">25</span>));</span><br><span class="line">​</span><br><span class="line">future.addListener(<span class="keyword">new</span> ChannelFuturelistener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess())&#123;</span><br><span class="line">            ByteBuf buffer = Unpooled.copiedBuffer(<span class="string">"Hello"</span>, Charset.defaultCharset());</span><br><span class="line">            ChannelFuture wf = future.channel().writeAndFlush(buffer);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Throwable cause = future.cause();</span><br><span class="line">            cause.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><pre><code>可以初步理解为每个ChannelHandler实例都类似于一种为了响应特定事件而被执行的回调。</code></pre><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a><code>PS</code></h3><p>Netty 的内部实现细节跟Linux epoll的用法很相似，熟悉Linux Epoll以及编程模型的朋友来说可以对比着来学习，寻找类同点、差异点以及差异的原因。  </p><p>Netty 同时支持OIO, NIO, EPOLL等多路复用模式，我是以熟悉的epoll作为切入熟悉的内部流程原理。</p><hr><h2 id="Netty的组件和设计"><a href="#Netty的组件和设计" class="headerlink" title="Netty的组件和设计"></a>Netty的组件和设计</h2><ul><li>Channel  ———— Socket；</li><li>EventLoop ———— 控制流、多线程处理、并发；</li><li>ChannelFuture ———— 异步通知；</li></ul><h3 id="Channel-接口"><a href="#Channel-接口" class="headerlink" title="Channel 接口"></a>Channel 接口</h3><p>Netty的Channel接口所提供的API，大大地降低了使用Socket类的复杂性。</p><h3 id="EventLoopGroup-接口"><a href="#EventLoopGroup-接口" class="headerlink" title="EventLoopGroup 接口"></a>EventLoopGroup 接口</h3><p>主要作用</p><ol><li>用于注册Channel</li><li>执行部分Runnable任务</li></ol><p>这里重点讲下“注册Channel”，在实际编程或应用时，每个Channel都是向EventLoopGroup注册的，由EventLoopGroup按照指定的策略方法，将Channel注册到EventLoopGroup下某个具体的EventLoop当中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventLoopGroup</span> <span class="keyword">extends</span> <span class="title">EventExecutorGroup</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register a &#123;<span class="doctag">@link</span> Channel&#125; with this &#123;<span class="doctag">@link</span> EventLoop&#125;. The returned &#123;<span class="doctag">@link</span> ChannelFuture&#125;</span></span><br><span class="line"><span class="comment">     * will get notified once the registration was complete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">MultithreadEventExecutorGroup</span> <span class="keyword">implements</span> <span class="title">EventLoopGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next().register(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadEventExecutorGroup</span> <span class="keyword">extends</span> <span class="title">AbstractEventExecutorGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> chooser.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="EventLoop-接口"><a href="#EventLoop-接口" class="headerlink" title="EventLoop 接口"></a>EventLoop 接口</h3><p>EventLoop定义了Netty的核心抽象，用于处理连接的生命周期中所发生的事件。</p><p><img src="/2018/04/08/Netty-核心对象梳理-1/img-3.png" alt="image"></p><ul><li>一个EventLoopGroup包含一个或者多个EventLoop；</li><li>一个EventLoop在它的生命周期内只和一个Thread绑定；</li><li>所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理；</li><li>一个Channel在它的生命周期内只注册于一个EventLoop；</li><li>一个EventLoop可能会被分配给一个或多个Channel；</li></ul><p>在这种设计中，一个给定的Channel的I/O操作都是由相同的Thread执行的，实际上消除了对于同步的需要。</p><h3 id="ChannelFuture-接口"><a href="#ChannelFuture-接口" class="headerlink" title="ChannelFuture 接口"></a>ChannelFuture 接口</h3><p>Netty中所有的I/O操作都是异步的。所有我们需要一种用于在之后的某个时间点确定其结果的方法。</p><p>为此，Netty提供了ChannelFuture接口，其addListener()方法注册了一个ChannelFutureListener，以便在某个操作完成时得到通知。</p><h3 id="ChannelHandler-接口"><a href="#ChannelHandler-接口" class="headerlink" title="ChannelHandler 接口"></a>ChannelHandler 接口</h3><p>顾名思义，Channel的Handler，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler的方法是由网络事件触发的。</p><h3 id="ChannelPipeline-接口"><a href="#ChannelPipeline-接口" class="headerlink" title="ChannelPipeline 接口"></a>ChannelPipeline 接口</h3><p>ChannelPipeline为ChannelHandler链提供了容器，并定义了用于在该链上传播入站和出站事件流的API。当Channel被创建时，它会被自动的分配到它专属的ChannelPipeline。</p><ul><li>ChannelPipleline中的ChannelHandler的执行顺序是由它们被添加的顺序所决定的。</li></ul><h3 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h3><p>Netty用于网络通信，天然需要编码和解码。也是用ChannelPipeline + ChannelHandler的机制实现的。  </p><ul><li>所有由Netty提供的编码器/解码器适配器类都实现了ChannelOutboundHandler或者ChannelInboundHandler接口。</li></ul><h3 id="引导（Bootstrap）"><a href="#引导（Bootstrap）" class="headerlink" title="引导（Bootstrap）"></a>引导（Bootstrap）</h3><p>Netty的引导类为应用程序的网络层配置提供了容器。</p><table><thead><tr><th>类别</th><th>Bootstrap</th><th>ServerBootstrap</th></tr></thead><tbody><tr><td>网络编程中的作用</td><td>连接到远程主机和端口</td><td>绑定到一个本地端口</td></tr><tr><td>EventLoopGroup的数目</td><td>1</td><td>2</td></tr></tbody></table><ul><li><p>使用Netty的ChannelOption和属性</p><p>  在每个Channel创建时都手动配置它可能会变得相当乏味。幸运的是，你不必这样做。相反，你可以使用option()方法来将ChannelOption应用到Bootstrap上。你所提供的值将会被自动应用到Bootstrap所创建的所有Channel。</p></li></ul><p><strong>引导DatagramChannel</strong></p><p>Bootstrap除了引导基于TCP协议的SocketChannel，也可以用于引导无连接的协议。Netty提供了各种DatagramChannel的实现。与面向连接的TCP相比，唯一区别是不再调用connect()方法，而是只调用bind()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用Bootstrap和DatagramChannel</span></span><br><span class="line">Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">bootstap.group(<span class="keyword">new</span> OioEventLoopGroup())</span><br><span class="line">    .channel(OioDatagramChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;DatagramPacket&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, DatagramPacket msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//Do something with the packet</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">ChannelFuture future = bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>));</span><br><span class="line">future.addListener(<span class="keyword">new</span> ChannelFutureListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channelFuture.isSuccess())&#123;</span><br><span class="line">            System.out.println(<span class="string">"Channel bound"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Bind attempt failed"</span>);</span><br><span class="line">            channelFuture.cause().printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a><code>我的理解</code></h3><ol><li><p>引导的根对象是 EventLoopGroup，间接的负责监听、处理所有Channel的网络事件。</p></li><li><p>EventLoop是EventLoopGroup内的成员，每个EventLoop与具体的线程绑定。也可以理解一个线程，一个EventLoop。<br> EventLoop直接负责处理其下所有Channel的网络事件。</p></li><li><p>ChannelHadler是Channel网络事件逻辑处理的容器，应用逻辑开发的重点就在此。</p></li><li><p>当一个Channel上来一个网络事件时，对应的EventLoop首先进行响应，并找到Channel所属的ChannelPipeline，Channel作为输入驱动一次ChannelPipeline。</p></li><li><p>ChannelPipeline 遍历其下ChannelHandler，逐个处理Channel的网络事件。</p></li></ol><ul><li>ChannelFuture可以同步等结果，也可以异步通知结果，都支持，自己选！</li></ul><p><img src="/2018/04/08/Netty-核心对象梳理-1/img-2.png" alt="image"></p><hr><h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><p>网络数据的基本单位是字节。Java NIO提供了ByteBuffer作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。  </p><p>Netty的ByteBuffer替代品是ByteBuf，一个强大的实现，既解决了JDK API的局限性，又为网络应用程序的开发者提供了更好的API。</p><ul><li><p>ByteBuf优点：  </p><ol><li>对于同一个数据buffer，维护readIndex, writeIndex两份索引</li></ol></li><li><p>ByteBuf模式</p><ol><li>堆缓冲区模式：<ul><li>将数据存储在JVM的堆空间中，应用代码可直接访问缓冲区中的数据。</li></ul></li><li>直接缓冲区模式：<ul><li>JDK 1.4引入的ByteBuffer类允许JVM实现直接使用操作系统的本地内容，这就避免了JAVA 应用在每次调用本地I/O操作前/后 需要将缓冲区的内容复制到一个与操作系统结合的中间缓冲区中。</li><li>缺点：因为数据不是在堆上，所以业务代码处理时不得不经过一次复制。</li></ul></li><li>复合缓冲区：<ul><li>为多个ByteBuf提供一个统一的聚合视图，可以根据需要向复合缓冲区中添加或者删除ByteBuf实例。</li></ul></li></ol></li><li><p>字节级操作</p><p>  可以以字节的操作方式使用ByteBuf</p></li></ul><ol><li>随机访问索引</li><li>顺序访问索引</li><li>可丢弃字节</li><li>可读字节</li><li>可写字节</li><li>索引管理</li><li>indexOf / ByteBufProcessor</li><li>派生缓冲区</li><li>读/写操作</li></ol><ul><li><p>ByteBuf池化分配</p><p>  为了降低分配和释放内存的开销，Netty通过interface ByteBufAllocator实现了ByteBuf的池化。</p></li><li><p>Unpooled 缓冲区</p><p>  如果未能获取到一个ByteBufAllocator的引用，Netty提供一个简单的Unpooled工具类，它提供创建未池化的ByteBuf实例。</p></li></ul><hr><h2 id="关于-ChannelFuture-和-ChannelPromise"><a href="#关于-ChannelFuture-和-ChannelPromise" class="headerlink" title="关于 ChannelFuture 和 ChannelPromise"></a>关于 ChannelFuture 和 ChannelPromise</h2><ul><li><p>ChannelFuture</p><ul><li>read-only</li><li>没有返回值的异步通知、调用</li><li>DefaultFutureListeners -&gt; listeners[N]</li></ul></li><li><p>ChannelPromise</p><ul><li>writeable</li><li>可写异步执行结果的通知、调用</li><li>notifyListenerNow -&gt; 回到Listeners -&gt; 取出对应的Channel进行回调操作</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅聊分布式事务</title>
      <link href="/2018/03/30/%E6%B5%85%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <content type="html"><![CDATA[<hr><blockquote><p>前言</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>最近很久没有写博客了，一方面是因为公司事情最近比较忙，另外一方面是因为在进行 CAP 的下一阶段的开发工作，不过目前已经告一段落了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>接下来还是开始我们今天的话题，说说分布式事务，或者说是我眼中的分布式事务，因为每个人可能对其的理解都不一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免，本文就分布式事务来简单聊一下。</p><a id="more"></a><hr><blockquote><p>数据库事务</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>在说分布式事务之前，我们先从数据库事务说起。 数据库事务可能大家都很熟悉，在开发过程中也会经常使用到。但是即使如此，可能对于一些细节问题，很多人仍然不清楚。比如很多人都知道数据库事务的几个特性：原子性(Atomicity )、一致性( Consistency )、隔离性或独立性( Isolation)和持久性(Durabilily)，简称就是ACID。但是再往下比如问到隔离性指的是什么的时候可能就不知道了，或者是知道隔离性是什么但是再问到数据库实现隔离的都有哪些级别，或者是每个级别他们有什么区别的时候可能就不知道了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>本文并不打算介绍这些数据库事务的这些东西，有兴趣可以搜索一下相关资料。不过有一个知识点我们需要了解，就是假如数据库在提交事务的时候突然断电，那么它是怎么样恢复的呢？ 为什么要提到这个知识点呢？ 因为分布式系统的核心就是处理各种异常情况，这也是分布式系统复杂的地方，因为分布式的网络环境很复杂，这种“断电”故障要比单机多很多，所以我们在做分布式系统的时候，最先考虑的就是这种情况。这些异常可能有 机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的TCP、存储数据丢失、其他异常等等…</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>我们接着说本地事务数据库断电的这种情况，它是怎么保证数据一致性的呢？我们使用SQL Server来举例，我们知道我们在使用 SQL Server 数据库是由两个文件组成的，一个数据库文件和一个日志文件，通常情况下，日志文件都要比数据库文件大很多。数据库进行任何写入操作的时候都是要先写日志的，同样的道理，我们在执行事务的时候数据库首先会记录下这个事务的redo操作日志，然后才开始真正操作数据库，在操作之前首先会把日志文件写入磁盘，那么当突然断电的时候，即使操作没有完成，在重新启动数据库时候，数据库会根据当前数据的情况进行undo回滚或者是redo前滚，这样就保证了数据的强一致性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>接着，我们就说一下分布式事务。</p><hr><blockquote><p>分布式理论</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>当我们的单个数据库的性能产生瓶颈的时候，我们可能会对数据库进行分区，这里所说的分区指的是物理分区，分区之后可能不同的库就处于不同的服务器上了，这个时候单个数据库的ACID已经不能适应这种情况了，而在这种ACID的集群环境下，再想保证集群的ACID几乎是很难达到，或者即使能达到那么效率和性能会大幅下降，最为关键的是再很难扩展新的分区了，这个时候如果再追求集群的ACID会导致我们的系统变得很差，这时我们就需要引入一个新的理论原则来适应这种集群的情况，就是 CAP 原则或者叫CAP定理，那么CAP定理指的是什么呢？</p><h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足一下3个属性：</p><ul><li>一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效)</li><li>可用性(Availability) ： 每个操作都必须以可预期的响应结束</li><li>分区容错性(Partition tolerance) ： 即使出现单个组件无法可用,操作依然可以完成</li></ul><p>具体地讲在分布式系统中，在任何数据库设计中，一个Web应用至多只能同时支持上面的两个属性。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在一致性与可用性之间做出选择。</p><p><strong>这个定理在迄今为止的分布式系统中都是适用的！ </strong>为什么这么说呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>这个时候有同学可能会把数据库的2PC（两阶段提交）搬出来说话了。OK，我们就来看一下数据库的两阶段提交。</p><p>对数据库分布式事务有了解的同学一定知道数据库支持的2PC，又叫做 XA Transactions。</p><pre><code>MySQL从5.5版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段：</p><ul><li>第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.</li><li>第二阶段：事务协调器要求每个数据库提交数据。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。这样做的缺陷是什么呢? 咋看之下我们可以在数据库分区之间获得一致性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>如果CAP 定理是对的，那么它一定会影响到可用性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>如果说系统的可用性代表的是执行某项操作相关所有组件的可用性的和。那么在两阶段提交的过程中，可用性就代表了涉及到的每一个数据库中可用性的和。我们假设两阶段提交的过程中每一个数据库都具有99.9%的可用性，那么如果两阶段提交涉及到两个数据库，这个结果就是99.8%。根据系统可用性计算公式，假设每个月43200分钟，99.9%的可用性就是43157分钟, 99.8%的可用性就是43114分钟，相当于每个月的宕机时间增加了43分钟。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>以上，可以验证出来，CAP定理从理论上来讲是正确的，CAP我们先看到这里，等会再接着说。</p><h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>在分布式系统中，我们往往追求的是可用性，它的重要程序比一致性要高，那么如何实现高可用性呢？ 前人已经给我们提出来了另外一个理论，就是BASE理论，它是用来对CAP定理进行进一步扩充的。BASE理论指的是：</p><ul><li>Basically Available（基本可用）</li><li>Soft state（软状态）</li><li>Eventually consistent（最终一致性）</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：<strong>我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>有了以上理论之后，我们来看一下分布式事务的问题。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>在分布式系统中，要实现分布式事务，无外乎那几种解决方案。</p><h4 id="一、两阶段提交（2PC）"><a href="#一、两阶段提交（2PC）" class="headerlink" title="一、两阶段提交（2PC）"></a>一、两阶段提交（2PC）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>和上一节中提到的数据库XA事务一样，两阶段提交就是使用XA协议的原理，我们可以从下面这个图的流程来很容易的看出中间的一些比如commit和abort的细节。</p><p><img src="/2018/03/30/浅聊分布式事务/img-1.png" alt="image"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>两阶段提交这种解决方案属于牺牲了一部分可用性来换取的一致性。在实现方面，在 .NET 中，可以借助 TransactionScop 提供的 API 来编程实现分布式系统中的两阶段提交，比如WCF中就有实现这部分功能。不过在多服务器之间，需要依赖于DTC来完成事务一致性，Windows下微软搞的有MSDTC服务，Linux下就比较悲剧了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>另外说一句，TransactionScop 默认不能用于异步方法之间事务一致，因为事务上下文是存储于当前线程中的，所以如果是在异步方法，需要显式的传递事务上下文。</p><ul><li><strong>优点：</strong> 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）  </li><li><strong>缺点：</strong> 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景，如果分布式系统跨接口调用，目前 .NET 界还没有实现方案。</li></ul><h4 id="二、补偿事务（TCC）"><a href="#二、补偿事务（TCC）" class="headerlink" title="二、补偿事务（TCC）"></a>二、补偿事务（TCC）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><ol><li><p>Try 阶段主要是对业务系统做检测及资源预留</p></li><li><p>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</p></li><li><p>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</p></li></ol><p>举个例子，假入 Bob 要向 Smith 转账，思路大概是：<br>我们有一个本地方法，里面依次调用<br>1、首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。<br>2、在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。<br>3、如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。  </p><ul><li><strong>优点：</strong> 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些</li><li><strong>缺点：</strong> 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。</li></ul><h4 id="三、本地消息表（异步确保）"><a href="#三、本地消息表（异步确保）" class="headerlink" title="三、本地消息表（异步确保）"></a>三、本地消息表（异步确保）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理，这种思路是来源于ebay。我们可以从下面的流程图中看出其中的一些细节：</p><p><img src="/2018/03/30/浅聊分布式事务/img-2.png" alt="image"></p><p><strong>基本思路就是：</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>这种方案遵循BASE理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的，即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。</p><ul><li><strong>优点：</strong> 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。</li><li><strong>缺点：</strong> 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</li></ul><h4 id="四、MQ-事务消息"><a href="#四、MQ-事务消息" class="headerlink" title="四、MQ 事务消息"></a>四、MQ 事务消息</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p><p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p><ul><li>第一阶段Prepared消息，会拿到消息的地址。</li><li>第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。</li></ul><p>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p><p><img src="/2018/03/30/浅聊分布式事务/img-3.png" alt="image"></p><ul><li><strong>优点：</strong> 实现了最终一致性，不需要依赖本地数据库事务。</li><li><strong>缺点：</strong> 实现难度大，主流MQ不支持，没有.NET客户端，RocketMQ事务消息部分代码也未开源。</li></ul><h4 id="五、Sagas-事务模型"><a href="#五、Sagas-事务模型" class="headerlink" title="五、Sagas 事务模型"></a>五、Sagas 事务模型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>Saga事务模型又叫做长时间运行的事务（Long-running-transaction）, 它是由普林斯顿大学的H.Garcia-Molina等人提出，它描述的是另外一种在没有两阶段提交的的情况下解决分布式系统中复杂的业务事务问题。你可以在这里看到 Sagas 相关论文。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>我们这里说的是一种基于 Sagas 机制的工作流事务模型，这个模型的相关理论目前来说还是比较新的，以至于百度上几乎没有什么相关资料。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Sagas 工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Sagas工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>比如我们一次关于购买旅游套餐业务操作涉及到三个操作，他们分别是预定车辆，预定宾馆，预定机票，他们分别属于三个不同的远程接口。可能从我们程序的角度来说他们不属于一个事务，但是从业务角度来说是属于同一个事务的。</p><p><img src="/2018/03/30/浅聊分布式事务/img-4.png" alt="image"></p><p>他们的执行顺序如上图所示，所以当发生失败时，会依次进行取消的补偿操作。</p><p>因为长事务被拆分了很多个业务流，所以 Sagas 事务模型最重要的一个部件就是工作流或者你也可以叫流程管理器（Process Manager），工作流引擎和Process Manager虽然不是同一个东西，但是在这里，他们的职责是相同的。在选择工作流引擎之后，最终的代码也许看起来是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SagaBuilder saga = SagaBuilder.newSaga(&quot;trip&quot;)</span><br><span class="line">        .activity(&quot;Reserve car&quot;, ReserveCarAdapter.class) </span><br><span class="line">        .compensationActivity(&quot;Cancel car&quot;, CancelCarAdapter.class) </span><br><span class="line">        .activity(&quot;Book hotel&quot;, BookHotelAdapter.class) </span><br><span class="line">        .compensationActivity(&quot;Cancel hotel&quot;, CancelHotelAdapter.class) </span><br><span class="line">        .activity(&quot;Book flight&quot;, BookFlightAdapter.class) </span><br><span class="line">        .compensationActivity(&quot;Cancel flight&quot;, CancelFlightAdapter.class) </span><br><span class="line">        .end()</span><br><span class="line">        .triggerCompensationOnAnyError();</span><br><span class="line"></span><br><span class="line">camunda.getRepositoryService().createDeployment() </span><br><span class="line">        .addModelInstance(saga.getModel()) </span><br><span class="line">        .deploy();</span><br></pre></td></tr></table></figure><p>这里有一个 C# 相关示例，有兴趣的同学可以看一下。</p><ul><li><strong>优缺点</strong> 这里我们就不说了，因为这个理论比较新，目前市面上还没有什么解决方案，即使是 Java 领域，我也没有搜索的太多有用的信息。</li></ul><hr><p>转自：<a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html</a></p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>认识鱼骨图</title>
      <link href="/2018/03/29/%E8%AE%A4%E8%AF%86%E9%B1%BC%E9%AA%A8%E5%9B%BE/"/>
      <content type="html"><![CDATA[<p><img src="/2018/03/29/认识鱼骨图/img-2.png" alt="image"></p><a id="more"></a><p>今天，偶然的机会在同事电脑上漂见“鱼骨图”。晚上吃完饭就在思考这个问题：“为什么我从来没用过鱼骨图分析问题？鱼骨图适用于什么类型的分析？”</p><p>查了些资料追求普及，介绍的内容大同小异</p><h3 id="概念摘要"><a href="#概念摘要" class="headerlink" title="概念摘要"></a>概念摘要</h3><p>鱼骨分析法，又名 因果分析法，是一种发现问题”根本原因”的分析方法。</p><p>鱼骨图可以进一步被划分为：</p><ol><li><p>整理问题型鱼骨图（各要素与特性值间不存在原因关系，而是结构构成关系）</p></li><li><p>原因型鱼骨图（鱼头在右，特性值通常以“为什么……”来写）</p></li><li><p>对策型鱼骨图（鱼头在左，特性值通常以“如何提高/改善……”来写）</p></li></ol><h3 id="怎么作图"><a href="#怎么作图" class="headerlink" title="怎么作图"></a>怎么作图</h3><h4 id="分析结构"><a href="#分析结构" class="headerlink" title="分析结构"></a>分析结构</h4><ul><li><p>A、针对问题点，选择层别方法（如人机料法环等）；  </p></li><li><p>B、按头脑风暴分别对各层别类别找出所有可能原因（因素）；</p></li><li><p>C、将找出的各要素进行归类、整理，明确其从属关系；</p></li><li><p>D、分析选取重要因素；</p></li><li><p>E、检查各要素的描述方法，确保语法简明、意思明确;</p></li></ul><h4 id="分析要点"><a href="#分析要点" class="headerlink" title="分析要点"></a>分析要点</h4><ul><li><p>A、确定大要因（大骨）时，现场作业一般从“人机料法环”着手,管理类问题一般从“人事时地物”层别，应视具体情况决定；  </p></li><li><p>B、大要因必须用中性词描述（不说明好坏），中、小要因必须使用价值判断（如…不良）；</p></li><li><p>C、头脑风暴时，应尽可能多而全地找出所有可能原因，而不仅限于自己能完全掌控或正在执行的内容。对人的原因，宜从行动而非思想态度面着手分析；</p></li><li><p>D、中要因跟特性值、小要因跟中要因间有直接的原因-问题关系，小要因应分析至可以直接下对策；</p></li><li><p>E、如果某种原因可同时归属于两种或两种以上因素，请以关联性最强者为准（必要时考虑三现主义：即现时到现场看现物，通过相对条件的比较，找出相关性最强的要因归类。）；</p></li><li><p>F、选取重要原因时，不要超过7项，且应标识在最未端原因。</p></li></ul><h4 id="绘图过程"><a href="#绘图过程" class="headerlink" title="绘图过程"></a>绘图过程</h4><ul><li><p>A、填写鱼头（按为什么不好的方式描述），画出主骨；  </p></li><li><p>B、画出大骨，填写大要因；</p></li><li><p>C、画出中骨、小骨，填写中小要因；</p></li><li><p>D、用特殊符号标识重要因素；</p></li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>(1) 查找要解决的问题；  </p><p>(2) 把问题写在鱼骨的头上；  </p><p>(3) 召集同事共同讨论问题出现的可能原因，尽可能多地找出问题；  </p><p>(4) 把相同的问题分组，在鱼骨上标出；  </p><p>(5) 根据不同问题征求大家的意见，总结出正确的原因；  </p><p>(6) 拿出任何一个问题，研究为什么会产生这样的问题；  </p><p>(7) 针对问题的答案再问为什么？这样至少深入五个层次（连续问五个问题）；  </p><p>(8) 当深入到第五个层次后，认为无法继续进行时，列出这些问题的原因，而后列出至少20个解决方法。   </p><hr><blockquote><p>看了鱼骨图的概念介绍后，在脑海中立马出现了新的问题：”鱼骨图和思维导图有什么区别？”</p></blockquote><h3 id="鱼骨图和思维导图有什么区别？"><a href="#鱼骨图和思维导图有什么区别？" class="headerlink" title="鱼骨图和思维导图有什么区别？"></a>鱼骨图和思维导图有什么区别？</h3><h4 id="类同点"><a href="#类同点" class="headerlink" title="类同点"></a>类同点</h4><ol><li>都是基于主题逐步分解、细化的过程</li><li>都是类树形结构</li></ol><h4 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h4><h5 id="理解-1"><a href="#理解-1" class="headerlink" title="理解-1"></a>理解-1</h5><p>首先、思维导图和鱼骨图都是图形思维，而图形思维最大的特点就是<code>将我们的思维结构化，并由此实现图形化</code>。  </p><p>而所谓的结构化一般就是构建逻辑思维，任何的逻辑思维都是基于这两个出发点而来的：1、分类；2、顺序；所以只要你的分类与顺序是一样的，那么你的逻辑思维是一样的，由此产生的图形思维也是一样的。而图形、分列、表格……只是图形思维具体的呈现方式。换句话说，在图形思维一样的前提下，不同的人选择了自己认为好的呈现方式让图形思维更可视化、更清晰化、更感性化。  </p><p>另外，还有不同之处在于思维导图不仅仅能用于构建逻辑思维，还能<code>扩展发散思维</code>，以及还能强化思维记忆。这是和鱼骨图的区别之一！</p><h5 id="理解-2"><a href="#理解-2" class="headerlink" title="理解-2"></a>理解-2</h5><ul><li><p>【思维导图】在实际应用中，思维导图<code>常用于个人</code>，<code>侧重于个人思维的发散，以求思维的全面性</code>，思维导图的层次感是逻辑思维自然的产出。<code>应用场景广泛</code>。</p></li><li><p>【鱼骨图】常用在多人同时参与的<code>头脑风暴场景</code>，侧重于发挥团队智力<code>逐层解剖问题，找到问题原因</code>。往往会以”问题原因分析 + 跟进Action”作为结果产出。</p></li></ul><h3 id="鱼骨图作图工具"><a href="#鱼骨图作图工具" class="headerlink" title="鱼骨图作图工具"></a>鱼骨图作图工具</h3><ul><li>Xmind<br><img src="/2018/03/29/认识鱼骨图/img-3.png" alt="image">  </li></ul>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分析图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo写作技巧</title>
      <link href="/2018/03/17/Hexo%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
      <content type="html"><![CDATA[<p>Hexo 写作的技巧与备忘，不喜勿喷。</p><a id="more"></a><ul><li>链接：<ul><li><a href="https://hexo.io/docs/commands.html" target="_blank" rel="noopener">Hexo命令</a></li></ul></li></ul><h2 id="文章插入图片"><a href="#文章插入图片" class="headerlink" title="文章插入图片"></a>文章插入图片</h2><h4 id="原生Markdown语法"><a href="#原生Markdown语法" class="headerlink" title="原生Markdown语法"></a>原生Markdown语法</h4><p>原生Markdown语法插入图片有三种方式</p><h5 id="1-插入本地图片"><a href="#1-插入本地图片" class="headerlink" title="1. 插入本地图片"></a>1. 插入本地图片</h5><p>只需要在基础语法的括号中填入图片的位置路径即可，支持绝对路径和相对路径。<br>例如： </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">image</span>](<span class="link">/home/picture/1.png</span>)</span><br></pre></td></tr></table></figure><p>评价：不灵活不好分享，本地图片的路径更改或丢失都会造成markdown文件调不出图。</p><h5 id="2-插入网络图片"><a href="#2-插入网络图片" class="headerlink" title="2. 插入网络图片"></a>2. 插入网络图片</h5><p>只需要在基础语法的括号中填入图片的网络链接即可，现在已经有很多免费/收费图床和方便传图的小工具可选。<br>例如： </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">image</span>](<span class="link">http://baidu.com/pic/doge.png</span>)</span><br></pre></td></tr></table></figure><p>评价：将图片存在网络服务器上，非常依赖网络和网络图片存储</p><h5 id="3-把图片存入markdown文件"><a href="#3-把图片存入markdown文件" class="headerlink" title="3. 把图片存入markdown文件"></a>3. 把图片存入markdown文件</h5><p>用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置。<br>基础用法： </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">avatar</span>](<span class="link">data:image/png;base64,iVBORw0......</span>)</span><br></pre></td></tr></table></figure><p>这个时候会发现插入的这一长串字符串会把整个文章分割开，非常影响编写文章时的体验。如果能够把大段的base64字符串放在文章末尾，然后在文章中通过一个id来调用，文章就不会被分割的这么乱了。<br>比如： </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">avatar</span>][<span class="symbol">doge</span>] </span><br><span class="line">[<span class="symbol">doge</span>]:<span class="link">data:image/png;base64,iVBORw0......</span></span><br></pre></td></tr></table></figure><p>评价：麻烦，费劲。</p><h4 id="Hexo方式"><a href="#Hexo方式" class="headerlink" title="Hexo方式"></a>Hexo方式</h4><h5 id="安装插件与配置"><a href="#安装插件与配置" class="headerlink" title="安装插件与配置"></a>安装插件与配置</h5><ol><li>把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true</li><li>在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件</li><li>等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹</li></ol><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">你想输入的替代文字</span>](<span class="link">xxxx/图片名.jpg</span>)</span><br></pre></td></tr></table></figure><p>注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo装修记录</title>
      <link href="/2018/03/17/Hexo%E8%A3%85%E4%BF%AE%E8%AE%B0%E5%BD%95/"/>
      <content type="html"><![CDATA[<p>前篇《<a href="https://veryjj.github.io/2018/03/17/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-%E7%BB%93%E7%BC%98Hexo/">个人博客搭建-结缘Hexo</a>》  </p><p>从时间投入上来说，搭建Hexo可谓是分分钟的事情，装修可花了我近一天的时间。</p><p>Hexo 是一个开放、扩展性强的框架，样式风格、功能都可以通过主题包、插件来实现。完全可以根据个人口味来装修你的博客。</p><a id="more"></a><hr><h1 id="选主题"><a href="#选主题" class="headerlink" title="选主题"></a>选主题</h1><p>关于Hexo的主题，你可以问度娘”Hexo Themes”网友好评度高的主题，也可以去官网自行挑选<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p><ul><li>需要提前说明的是：不是选上对应主题，所有功能就有了，这也是我为什么会单独写这篇备忘的原因。</li></ul><p>经过各种试用和对比，我最终选择了：NexT这个主题 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Go Github</a>，理由如下：</p><ol><li>（Most Important）界面符合我口味。NexT 中的Pisces主题，样例：<a href="http://notes.iissnan.com/" target="_blank" rel="noopener">IIssNan’s Notes</a></li><li>NexT主题集成的插件多，极大的方便了初级的小白用户，详见：NexT主题的_config.xml配置项<ul><li>博客评论</li><li>Baidu Analytics / Google Analytics</li><li>文章阅读数量</li><li>baidu push</li><li>algolia_search / local_search</li><li>背景画布特效</li><li>highlight_theme</li><li>等等</li></ul></li><li>支持手机端</li></ol><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>Hexo theme 统一放在Hexo根目录的themes目录下，每个主题一个子目录。<br><img src="/2018/03/17/Hexo装修记录/themes-dir.png" alt="image"></p><p>如果主题是Github上的，推荐使用如下命令下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure><p>然后修改hexo根目录下的_config.xml，切换主题<br><img src="/2018/03/17/Hexo装修记录/change-theme.png" alt="image"></p><p>OK, hexo g -&gt; hexo s 看下效果吧</p><h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><p>找到 hexo/themes/next/_config.xml，一项项阅读熟悉吧，注释写的很详细。</p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>基础配置项：</p><ol><li>菜单配置：主页、关于、标签、分类、归档等</li><li>头像</li><li>打赏</li><li>社交主页</li><li>侧边栏</li></ol><p>主题的_config.xml会引用hexo的_config.xml中基础配置，所以请同时配置hexo的_config.xml，例如：博客抬头、语种、相关数据目录等</p><h2 id="背景特效"><a href="#背景特效" class="headerlink" title="背景特效"></a>背景特效</h2><p>效果图示<br><img src="/2018/03/17/Hexo装修记录/bg-show.png" alt="image"></p><p>配置next主题的_config.xml<br><img src="/2018/03/17/Hexo装修记录/bg-config.png" alt="image"></p><h2 id="支持搜索"><a href="#支持搜索" class="headerlink" title="支持搜索"></a>支持搜索</h2><p><img src="/2018/03/17/Hexo装修记录/search-show.png" alt="image"><br><img src="/2018/03/17/Hexo装修记录/search-config.png" alt="image"></p><h2 id="文章阅读计数"><a href="#文章阅读计数" class="headerlink" title="文章阅读计数"></a>文章阅读计数</h2><p>NexT提供两种插件方式：1、leancloud_visitors（国内的）   和  2、firestore(谷歌的)<br>我选用的是leancloud_visitors，配置相对简单一些</p><ul><li>配置LeanCloud</li></ul><p>注册：<a href="https://leancloud.cn" target="_blank" rel="noopener">https://leancloud.cn</a><br>打开LeanCloud官网，进入注册页面注册。完成邮箱激活后，点击头像，进入控制台页面创建新应用，如下：<br><img src="/2018/03/17/Hexo装修记录/leancloud-config-1.png" alt="image"></p><p>创建名称为Counter的Class<br><img src="/2018/03/17/Hexo装修记录/leancloud-config-2.png" alt="image"><br><img src="/2018/03/17/Hexo装修记录/leancloud-config-3.png" alt="image"></p><p>修改NexT的_config.xml配置文件<br><img src="/2018/03/17/Hexo装修记录/leancloud-config-4.png" alt="image">  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: "你的App Id"</span><br><span class="line">  app_key: "你的App Key"</span><br></pre></td></tr></table></figure><h2 id="PV-UV"><a href="#PV-UV" class="headerlink" title="PV/UV"></a>PV/UV</h2><p><img src="/2018/03/17/Hexo装修记录/pv-config.png" alt="image">  </p><h2 id="Google-Analytics"><a href="#Google-Analytics" class="headerlink" title="Google Analytics"></a>Google Analytics</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Google Analytics</span><br><span class="line">google_analytics: '你的Google Analytics Code'</span><br></pre></td></tr></table></figure><hr><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="标签和分类页面不显示问题"><a href="#标签和分类页面不显示问题" class="headerlink" title="标签和分类页面不显示问题"></a>标签和分类页面不显示问题</h2><p>当时切换NexT主题后，侧边栏的标签、分类点击时，是无法正常显示标签和分类的，属：Cannot Get /tags/</p><p>若出现此问题，请按下方式解决<br>在hexo 目录下执行</p><ul><li>步骤一：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page 'tags'</span><br></pre></td></tr></table></figure><ul><li>步骤二：</li></ul><p>编辑刚新建的页面，将页面的类型设置为tags，主题会自动为这个页面显示标签云。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: TagCloud</span><br><span class="line">date: 2018-03-17 15:31:21</span><br><span class="line">type: "tags"</span><br><span class="line">comments: false   #注意：如果有启动多说或Disqus评论，需要关闭评论，添加comments字段并设置为false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><img src="/2018/03/17/Hexo装修记录/show-tags.png" alt="image"></p><p><strong>“分类”同理~</strong></p><p><img src="/2018/03/17/Hexo装修记录/show-categories.png" alt="image"></p><hr><h1 id="其他推荐"><a href="#其他推荐" class="headerlink" title="其他推荐"></a>其他推荐</h1><ul><li><a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">hexo的next主题个性化配置教程</a></li></ul>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>个人博客搭建-结缘Hexo</title>
      <link href="/2018/03/17/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-%E7%BB%93%E7%BC%98Hexo/"/>
      <content type="html"><![CDATA[<h2 id="Github-Pages-Hexo-搭建个人博客"><a href="#Github-Pages-Hexo-搭建个人博客" class="headerlink" title="Github Pages + Hexo 搭建个人博客"></a>Github Pages + Hexo 搭建个人博客</h2><p>偶然的机会，看到”***.github.io”域名的个人博客，瞬间就来了兴趣，莫非Github能方便的创建个人博客？</p><p>咨询了下度娘，知道了用GitHub Pages + Hexo 搭建个人博客的方式，于是说干就干！</p><a id="more"></a><blockquote><p>PS: 我用的是Macbook + Shell，某些操作Windows的朋友可能要转化翻译成Windows上的命令。</p></blockquote><h3 id="1-创建Github仓库"><a href="#1-创建Github仓库" class="headerlink" title="1. 创建Github仓库"></a>1. 创建Github仓库</h3><p>首先，个人Github账号应该有吧？如果没有，先去注册一个。</p><p>然后，在Github上新建一个仓库，如下图：<br><img src="/2018/03/17/个人博客搭建-结缘Hexo/veryjj-github-io.png" alt="image"></p><p>确保新建的仓库以Github Pages方式发布<br><img src="/2018/03/17/个人博客搭建-结缘Hexo/github-2.png" alt="image"><br><img src="/2018/03/17/个人博客搭建-结缘Hexo/github-3.png" alt="image"></p><p>OK，此步骤完成了！</p><hr><h3 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装Hexo</h3><pre><code>正式使用Hexo前，请先安装Node.js 和Git</code></pre><ul><li><p>安装Node.js<br>去官网下载并安装：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Link</a></p></li><li><p>安装Git</p><ul><li>作为玩Github的程序员，默认你已经安装了Git  </li></ul></li></ul><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><ol><li>新建一个目录作为Hexo的根目录（PS: 后续Hexo相关的功能以及写博客都基于此目录）</li><li>进入新建的目录  </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init  #初始化网站</span><br><span class="line">npm install</span><br><span class="line">hexo g     #hexo generate的简写，意思生成博客站点</span><br><span class="line">hexo s     #hexo server的简写，即启动运行hexo的站点，这一步之后就可以通过http://localhost:4000  查看了</span><br></pre></td></tr></table></figure><ul><li>常用Hexo命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo c : hexo clean 清除hexo已生成的public</span><br><span class="line">hexo g : hexo generate 重新生成hexo站点</span><br><span class="line">hexo s : hexo server 运行hexo站点。注：本地运行时，在hexo上做的修改保存后即生效的，不用重新hexo g</span><br><span class="line">hexo d : hexo deploy 将hexo发布到github上去。</span><br></pre></td></tr></table></figure><hr><h3 id="3-Hexo-deploy-到Github"><a href="#3-Hexo-deploy-到Github" class="headerlink" title="3. Hexo deploy 到Github"></a>3. Hexo deploy 到Github</h3><ul><li>编辑根目录下_config.yml文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https://github.com/VeryJJ/VeryJJ.github.io.git  #这里的网址填你自己的</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><ul><li><p>安装hexo deploy插件：</p><ul><li>npm install hexo-deployer-git –save   </li></ul></li><li><p>在Hexo目录下执行hexo d </p></li></ul><hr><p>hexo d 成功后，就大工告成拉！你可以在浏览器输入***.github.io(你新建的github.io仓库)，就能看到你的个人博客拉！</p><p>以后写博客的步骤为：</p><ol><li>在电脑本地hexo new ‘文章名’</li><li>丰富你的文章</li><li>hexo g</li><li>hexo d 发布</li></ol><p><strong>博客搭建好了，但相信你会觉得它好丑，没关系，请继续阅读下一篇Hexo的装修总结</strong></p><h5 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h5><ul><li><a href="https://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="noopener">我是如何利用Github Pages搭建起我的博客，细数一路的坑</a> </li></ul>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 场景化下的命令备忘</title>
      <link href="/2018/03/15/Git%20%E5%9C%BA%E6%99%AF%E5%8C%96%E4%B8%8B%E7%9A%84%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/"/>
      <content type="html"><![CDATA[<h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line">git branch -a        查看远端所有分支</span><br><span class="line">git branch -v        查看本地分支，以及分支上最新的commit提交信息</span><br><span class="line">git branch -vv      在-v基础上，多现实本地分支和远程分支的关联关系</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="查看某次commit的修改"><a href="#查看某次commit的修改" class="headerlink" title="查看某次commit的修改"></a>查看某次commit的修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show commit号</span><br></pre></td></tr></table></figure><h2 id="查看某个文件的历史修改记录"><a href="#查看某个文件的历史修改记录" class="headerlink" title="查看某个文件的历史修改记录"></a>查看某个文件的历史修改记录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">git log 文件名</span><br><span class="line">git log -p 文件名</span><br><span class="line">git log --author=提交人     只查看提交人的提交记录</span><br><span class="line">git log --pretty=oneline 单行显示提交记录</span><br><span class="line">git log --name-only    显示每次commit修改的文件列表</span><br><span class="line">git log --name-status     查看commit记录里的文件修改状态</span><br><span class="line">git log --grep=&apos;abc&apos;    显示commit描述匹配abc的commit记录</span><br><span class="line">git log -S &quot;代码内容&quot;   按代码内容搜索commit记录，如果代码内容部分想用正则表达式，则将-S换成-G</span><br><span class="line">git log --pretty=&apos;%H %Cblue%cd %C(yellow)%cn %Cred%s&apos; 按commit号+提交日期+提交人+commit标题 显示</span><br><span class="line"></span><br><span class="line">pretty格式</span><br><span class="line">%H   提交对象（commit）的完整哈希字串 </span><br><span class="line">%h   提交对象的简短哈希字串 </span><br><span class="line">%T   树对象（tree）的完整哈希字串 </span><br><span class="line">%t   树对象的简短哈希字串 </span><br><span class="line">%P   父对象（parent）的完整哈希字串 </span><br><span class="line">%p   父对象的简短哈希字串 </span><br><span class="line">%an  作者（author）的名字 </span><br><span class="line">%_ae  作者的电子邮件地址 （由于新浪博客显示问题，请去除 %_ae 中的 _ ）</span><br><span class="line">%_ad  作者修订日期（可以用 -date= 选项定制格式）（由于新浪博客显示问题，请去除 % ad 中的 _ ）</span><br><span class="line">%ar  作者修订日期，按多久以前的方式显示 </span><br><span class="line">%cn  提交者(committer)的名字 </span><br><span class="line">%_ce 提交者的电子邮件地址（由于新浪博客显示问题，请去除 %_ce 中的 _ ）</span><br><span class="line">%_cd  提交日期 （由于新浪博客显示问题，请去除 %_cd 中的 _ ）</span><br><span class="line">%cr  提交日期，按多久以前的方式显示 </span><br><span class="line">%d:  ref名称</span><br><span class="line">%s:  提交的信息标题</span><br><span class="line">%b:  提交的信息内容</span><br><span class="line">%Cred: 切换到红色 </span><br><span class="line">%Cgreen: 切换到绿色 </span><br><span class="line">%_Cblue: 切换到蓝色 （由于新浪博客显示问题，请去除 %_Cblue 中的 _）</span><br><span class="line">%Creset: 重设颜色 </span><br><span class="line">%C(...): 制定颜色, as described in color.branch.* config option </span><br><span class="line">%n:  换行</span><br></pre></td></tr></table></figure><h2 id="查看未commit的本地修改"><a href="#查看未commit的本地修改" class="headerlink" title="查看未commit的本地修改"></a>查看未commit的本地修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff </span><br><span class="line">git diff  文件名</span><br></pre></td></tr></table></figure><h2 id="git-diff-比较commit之间的差异"><a href="#git-diff-比较commit之间的差异" class="headerlink" title="git diff 比较commit之间的差异"></a>git diff 比较commit之间的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff commit                                      比较HEAD与commit之间的差异</span><br><span class="line">git diff commit_1 commit_2                 比较两个commit之间的差异</span><br><span class="line">git diff commit_1..commit_2                与git diff commit_1 commit_2 一样效果</span><br></pre></td></tr></table></figure><h2 id="从服务器拉代码"><a href="#从服务器拉代码" class="headerlink" title="从服务器拉代码"></a>从服务器拉代码</h2><pre><code>git pull --rebase     (推荐)会把本地未push得commit放到缓冲区，然后把远程最新版本拉过来，再应用本地commit，这样不会造成本地有新commit时，merge的效果。git pull       直接更新，若本地和远端都有新commit，都执行自动merge。</code></pre><h2 id="拉分支"><a href="#拉分支" class="headerlink" title="拉分支"></a>拉分支</h2><pre><code>git checkout -b branchName       创建本地新分支git checkout -b branchName remotes/origin/branchName  以远端分支创建本地新分支git push origin $newBranch:$newBranch             将本地分支提交到远端进行创建</code></pre><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :master</span><br><span class="line"># 等同于</span><br><span class="line">$ git push origin --delete master</span><br></pre></td></tr></table></figure><h2 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h2><pre><code>git add .            将修改加到stage状态区git commint -m &quot;注释&quot; git push             推送所有分支git push origin develop       只推送develop分支</code></pre><h2 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h2><pre><code>git add -A</code></pre><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><pre><code>git rm 文件名git rm -r 目录名       </code></pre><h2 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h2><pre><code>git push                                    push所有分支git push origin master              将本地主分支推到远程主分支git push –u origin master          将本地主分支推到远程（如无远程主分支则创建，用于初始化远程仓库）git push origin &lt;local_branch&gt;                                  创建远程分支，origin是远程仓库名。git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;    创建远程分支</code></pre><h3 id="强制push"><a href="#强制push" class="headerlink" title="强制push"></a>强制push</h3><pre><code>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。        git push --force origin</code></pre><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><pre><code>git merge remotes/origin/mc-s-3    将远端mc-s-3分支merge到本地 </code></pre><h4 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h4><pre><code>git rebase developgit rebase remotes/origin/develop</code></pre><h4 id="配置mergetool"><a href="#配置mergetool" class="headerlink" title="配置mergetool"></a>配置mergetool</h4><pre><code>git config –global merge.tool bc3git config –global mergetool.bc3.path 软件执行文件地址</code></pre><h4 id="merge策略"><a href="#merge策略" class="headerlink" title="merge策略"></a>merge策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Git merge 策略的总结:</span><br><span class="line"></span><br><span class="line">1、使用 -s 指定策略，使用 -X 指定策略的选项</span><br><span class="line">2、默认策略是recursive</span><br><span class="line">3、策略有 ours，但是没有theirs (Git老版本好像有)</span><br><span class="line">4、策略ours直接 忽略 合并分支的任何内容，只做简单的合并，保留分支改动的存在</span><br><span class="line">5、默认策略recursive有选项ours 和 theirs</span><br><span class="line">6、-s recursive -X ours 和 -s ours 不同，后者如第3点提到直接忽略内容，但是前者会做合并，遇到冲突时以自己的改动为主</span><br><span class="line">7、-s recursive -X theirs的对立面是 -s recursive -X ours</span><br><span class="line"></span><br><span class="line">`注：-s recursive -X ours   合并分支，冲突时以本地为主`</span><br></pre></td></tr></table></figure><h2 id="回退未commit的修改"><a href="#回退未commit的修改" class="headerlink" title="回退未commit的修改"></a>回退未commit的修改</h2><pre><code>git checkout [path] 将指定路径的修改还原到最新版本</code></pre><h2 id="回退已commit，未push的修改"><a href="#回退已commit，未push的修改" class="headerlink" title="回退已commit，未push的修改"></a>回退已commit，未push的修改</h2><pre><code>git reset HEAD &lt;file&gt; --mixed 选项：默认的--soft 选项：改动会回退到stage状态  --hard 选项：改动会直接丢失。git rebase -i 想要删除的commit的前一个commit号。出来的界面里，将想要删除的commit描述改为drop，保存即可。</code></pre><h2 id="回退已push的修改"><a href="#回退已push的修改" class="headerlink" title="回退已push的修改"></a>回退已push的修改</h2><pre><code>git revert 指定的commit号。跳出来的界面，选择要回退的commit内容（取消前面的#）   可以随便选某个commit删除  若revert一个merge的commit，则要指定parent 号git revert commit 号 -m 1。        这样就选parent 1，那么parent 1又是哪一个呢？一般来说，如果你在master上mergezhc_branch,那么parent 1就是master，parent 2就是zhc_branch.</code></pre><h2 id="重排commit顺序"><a href="#重排commit顺序" class="headerlink" title="重排commit顺序"></a>重排commit顺序</h2><pre><code>git rebase -i commit号出来的界面中，将列出来的commit行重新排序再保存，就等于修改commit顺序了。</code></pre><h2 id="修改commit的描述"><a href="#修改commit的描述" class="headerlink" title="修改commit的描述"></a>修改commit的描述</h2><h4 id="未push"><a href="#未push" class="headerlink" title="未push"></a>未push</h4><pre><code>方法一：git rebase -i commit号对应commit号前改为edit，保存。出来后git commit --amend。将commit描述修改掉，保存。出来后再git rebase --continue即可。方法二：git commit --amend    修改最近的一次commit</code></pre><h2 id="代码仓库迁移"><a href="#代码仓库迁移" class="headerlink" title="代码仓库迁移"></a>代码仓库迁移</h2><pre><code>git clone --bare robbin_site robbin_site.git git remote remove origingit remote add origin git@120.27.160.167:ZCY/doc-round-1.gitgit push –-all -–progress origin</code></pre><h2 id="导出指定版本的代码版本"><a href="#导出指定版本的代码版本" class="headerlink" title="导出指定版本的代码版本"></a>导出指定版本的代码版本</h2><pre><code>    git archive -o ../updated.zip HEAD $(git diff --name-only HEAD^)例如：git archive -o ./version.zip 指定commit号    或者  git archive --format zip -output &quot;./archive.zip&quot; HEAD</code></pre><h2 id="tag功能"><a href="#tag功能" class="headerlink" title="tag功能"></a>tag功能</h2><h4 id="创建tag"><a href="#创建tag" class="headerlink" title="创建tag"></a>创建tag</h4><pre><code>git tag -a v1.0.0 -m &apos;备注&apos;</code></pre><h4 id="查看tag"><a href="#查看tag" class="headerlink" title="查看tag"></a>查看tag</h4><pre><code>git tag</code></pre><h4 id="切换tag"><a href="#切换tag" class="headerlink" title="切换tag"></a>切换tag</h4><pre><code>git checkout tag名</code></pre><h4 id="删除tag"><a href="#删除tag" class="headerlink" title="删除tag"></a>删除tag</h4><pre><code>git tag -d v1.0.0</code></pre><h4 id="指定commit打tag"><a href="#指定commit打tag" class="headerlink" title="指定commit打tag"></a>指定commit打tag</h4><pre><code>git tag -a v1.0.0 commit号</code></pre><h4 id="发布标签"><a href="#发布标签" class="headerlink" title="发布标签"></a>发布标签</h4><pre><code>git push origin v1.0.0       将本地v1.0.0标签推送到git服务器git push origin -tags         将本地所有tag一次性推送到git服务器</code></pre><h2 id="创建补丁"><a href="#创建补丁" class="headerlink" title="创建补丁"></a>创建补丁</h2><h4 id="当前分支所有超前master的提交："><a href="#当前分支所有超前master的提交：" class="headerlink" title="当前分支所有超前master的提交："></a>当前分支所有超前master的提交：</h4><pre><code>git format-patch -M master</code></pre><h4 id="某次提交以后的所有patch"><a href="#某次提交以后的所有patch" class="headerlink" title="某次提交以后的所有patch:"></a>某次提交以后的所有patch:</h4><pre><code>git format-patch 4e16                --4e16指的是commit名</code></pre><h4 id="从根到指定提交的所有patch"><a href="#从根到指定提交的所有patch" class="headerlink" title="从根到指定提交的所有patch:"></a>从根到指定提交的所有patch:</h4><pre><code>git format-patch                          --root 4e16</code></pre><h4 id="某两次提交之间的所有patch"><a href="#某两次提交之间的所有patch" class="headerlink" title="某两次提交之间的所有patch:"></a>某两次提交之间的所有patch:</h4><pre><code>git format-patch 365a..4e16 -o &lt;patch_dir&gt;      --365a和4e16分别对应两次提交的名称</code></pre><h4 id="某次提交（含）之前的几次提交："><a href="#某次提交（含）之前的几次提交：" class="headerlink" title="某次提交（含）之前的几次提交："></a>某次提交（含）之前的几次提交：</h4><pre><code>git format-patch –n 07fe             --n指patch数，07fe对应提交的名称故，单次提交即为：git format-patch -1 07fe</code></pre><h1 id="应用补丁"><a href="#应用补丁" class="headerlink" title="应用补丁"></a>应用补丁</h1><p>方法一（推荐）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、在同一个仓库下找到对应的commit号</span><br><span class="line">2、切换到对应分支下，git cherry-pick commit 号</span><br><span class="line">3、如果冲突，git  mergetool 解决冲突。</span><br><span class="line">4、git status根据提示commit代码，并push</span><br><span class="line"></span><br><span class="line">cherry-pick 一个commit区间</span><br><span class="line">git cherry-pick &lt;start-commit-id&gt;^..&lt;end-commit-id&gt;    start-commit-id是版本树里较早的commit</span><br><span class="line"></span><br><span class="line">cherry-pick一个merge commit</span><br><span class="line">git cherry-pick &lt;commit-id&gt; -m parent-number   -m代表 --mainline</span><br><span class="line">实际例子：git cherry-pick 32b234 -m 1      1，2分别代表什么</span><br></pre></td></tr></table></figure></p><h1 id="查看未push到远程仓库的commit"><a href="#查看未push到远程仓库的commit" class="headerlink" title="查看未push到远程仓库的commit"></a>查看未push到远程仓库的commit</h1><h2 id="1、查看到未传送到远程代码库的提交次数"><a href="#1、查看到未传送到远程代码库的提交次数" class="headerlink" title="1、查看到未传送到远程代码库的提交次数"></a>1、查看到未传送到远程代码库的<code>提交次数</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    git status        //只能看次数</span><br><span class="line"></span><br><span class="line">显示结果类似于这样：</span><br><span class="line"># On branch master</span><br><span class="line"># Your branch is ahead of &apos;origin/master&apos; by 2 commits.</span><br></pre></td></tr></table></figure><h2 id="2、查看到未传送到远程代码库的提交描述-说明"><a href="#2、查看到未传送到远程代码库的提交描述-说明" class="headerlink" title="2、查看到未传送到远程代码库的提交描述/说明"></a>2、查看到未传送到远程代码库的<code>提交描述/说明</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git cherry -v</span><br><span class="line"></span><br><span class="line">显示结果类似于这样：</span><br><span class="line">+ b6568326134dc7d55073b289b07c4b3d64eff2e7 add default charset for table items_has_images</span><br><span class="line">+ 4cba858e87752363bd1ee8309c0048beef076c60 move Savant3 class into www/includes/class/</span><br></pre></td></tr></table></figure><h2 id="3、查看到未传送到远程代码库的提交详情"><a href="#3、查看到未传送到远程代码库的提交详情" class="headerlink" title="3、查看到未传送到远程代码库的提交详情"></a>3、查看到未传送到远程代码库的<code>提交详情</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git log master ^origin/master</span><br><span class="line">这是一个git log命令的过滤，^origin/master可改成其它分支。</span><br><span class="line">显示结果类似于这样：</span><br><span class="line">commit 4cba858e87752363bd1ee8309c0048beef076c60</span><br><span class="line">Author: Zam &lt;zam@iaixue.com&gt;</span><br><span class="line">Date:   Fri Aug 9 16:14:30 2013 +0800</span><br><span class="line"></span><br><span class="line">    move Savant3 class into www/includes/class/</span><br><span class="line"></span><br><span class="line">commit b6568326134dc7d55073b289b07c4b3d64eff2e7</span><br><span class="line">Author: Zam &lt;zam@iaixue.com&gt;</span><br><span class="line">Date:   Fri Aug 9 16:02:09 2013 +0800</span><br><span class="line"></span><br><span class="line">    add default charset for table items_has_images</span><br></pre></td></tr></table></figure><h2 id="查看两个分支的差异"><a href="#查看两个分支的差异" class="headerlink" title="查看两个分支的差异"></a>查看两个分支的差异</h2><h4 id="查看dev中有，而master中没有的"><a href="#查看dev中有，而master中没有的" class="headerlink" title="查看dev中有，而master中没有的"></a>查看dev中有，而master中没有的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log dev ^master</span><br><span class="line"></span><br><span class="line">反之：查看master中有，dev中没有的</span><br><span class="line">git log master ^dev</span><br></pre></td></tr></table></figure><h4 id="查看dev中比master多了哪些提交（A比B多了哪些，就把A放-右边）"><a href="#查看dev中比master多了哪些提交（A比B多了哪些，就把A放-右边）" class="headerlink" title="查看dev中比master多了哪些提交（A比B多了哪些，就把A放..右边）"></a>查看dev中比master多了哪些提交（A比B多了哪些，就把A放..右边）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log master..dev</span><br></pre></td></tr></table></figure><h4 id="不在乎谁多谁少，只想看差异的提交"><a href="#不在乎谁多谁少，只想看差异的提交" class="headerlink" title="不在乎谁多谁少，只想看差异的提交"></a>不在乎谁多谁少，只想看差异的提交</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --left-right dev...master      #--left-right 会帮助显示差异的commit属于哪个分支</span><br></pre></td></tr></table></figure><h4 id="整个目录比较差异详情"><a href="#整个目录比较差异详情" class="headerlink" title="整个目录比较差异详情"></a>整个目录比较差异详情</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git difftool develop..pre-online --dir</span><br></pre></td></tr></table></figure><h2 id="Git-stash-暂存"><a href="#Git-stash-暂存" class="headerlink" title="Git stash 暂存"></a>Git stash 暂存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git stash     </span><br><span class="line">    将当前工作区里未commit的修改放到暂存区，将代码恢复到最近的一次修改</span><br><span class="line"></span><br><span class="line">git stash list</span><br><span class="line">    查看暂存区的列表</span><br><span class="line"></span><br><span class="line">git show stash@&#123;0&#125; </span><br><span class="line">    see the last stash</span><br><span class="line">    </span><br><span class="line">git stash pop</span><br><span class="line">    apply lastest stash and remove it from th list</span><br><span class="line">    </span><br><span class="line">git stash clear</span><br><span class="line">    清空暂存栈</span><br><span class="line"></span><br><span class="line">git stash apply stash@&#123;1&#125;</span><br><span class="line">    指定暂存区里的某一次stash，应用到本地</span><br></pre></td></tr></table></figure><h2 id="删除本地git-branch-a-能看到，而远程已经删掉的分支记录"><a href="#删除本地git-branch-a-能看到，而远程已经删掉的分支记录" class="headerlink" title="删除本地git branch -a 能看到，而远程已经删掉的分支记录"></a>删除本地git branch -a 能看到，而远程已经删掉的分支记录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch -p</span><br></pre></td></tr></table></figure><h2 id="更改时间显示方式"><a href="#更改时间显示方式" class="headerlink" title="更改时间显示方式"></a>更改时间显示方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">--date=(relative|local|default|iso|rfc|short|raw)</span><br><span class="line">  Only takes effect for dates shown in human-readable format,</span><br><span class="line">  such as when using &quot;--pretty&quot;.  log.date config variable</span><br><span class="line">  sets a default value for log command’s --date option.</span><br><span class="line"></span><br><span class="line">--date=relative shows dates relative to the current time, e.g. &quot;2 hours ago&quot;.</span><br><span class="line"></span><br><span class="line">--date=local shows timestamps in user’s local timezone.</span><br><span class="line"></span><br><span class="line">--date=iso (or --date=iso8601) shows timestamps in ISO 8601 format.</span><br><span class="line"></span><br><span class="line">--date=rfc (or --date=rfc2822) shows timestamps in RFC 2822 format,</span><br><span class="line">  often found in E-mail messages.</span><br><span class="line"></span><br><span class="line">--date=short shows only date but not time, in YYYY-MM-DD format.</span><br><span class="line"></span><br><span class="line">--date=raw shows the date in the internal raw git format %s %z format.</span><br><span class="line"></span><br><span class="line">--date=default shows timestamps in the original timezone</span><br><span class="line">  (either committer’s or author’s).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####格式化显示</span><br><span class="line">例子：--date=format:&apos;%Y-%m-%d %H:%M:%S&apos;</span><br><span class="line">参数：</span><br><span class="line">%a        Abbreviated weekday name</span><br><span class="line">%A        Full weekday name</span><br><span class="line">%b        Abbreviated month name</span><br><span class="line">%B        Full month name</span><br><span class="line">%c        Date and time representation appropriate for locale</span><br><span class="line">%d        Day of month as decimal number (01 – 31)</span><br><span class="line">%H        Hour in 24-hour format (00 – 23)</span><br><span class="line">%I        Hour in 12-hour format (01 – 12)</span><br><span class="line">%j        Day of year as decimal number (001 – 366)</span><br><span class="line">%m        Month as decimal number (01 – 12)</span><br><span class="line">%M        Minute as decimal number (00 – 59)</span><br><span class="line">%p        Current locale&apos;s A.M./P.M. indicator for 12-hour clock</span><br><span class="line">%S        Second as decimal number (00 – 59)</span><br><span class="line">%U        Week of year as decimal number, with Sunday as first day of week (00 – 53)</span><br><span class="line">%w        Weekday as decimal number (0 – 6; Sunday is 0)</span><br><span class="line">%W        Week of year as decimal number, with Monday as first day of week (00 – 53)</span><br><span class="line">%x        Date representation for current locale</span><br><span class="line">%X        Time representation for current locale</span><br><span class="line">%y        Year without century, as decimal number (00 – 99)</span><br><span class="line">%Y        Year with century, as decimal number</span><br><span class="line">%z, %Z        Either the time-zone name or time zone abbreviation, depending on registry settings; no characters if time zone is unknown</span><br><span class="line">%%        Percent sign</span><br></pre></td></tr></table></figure><h4 id="全局更改方式"><a href="#全局更改方式" class="headerlink" title="全局更改方式"></a>全局更改方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global log.date relative</span><br></pre></td></tr></table></figure><hr><h2 id="代码量"><a href="#代码量" class="headerlink" title="代码量"></a>代码量</h2><h4 id="统计当天提交的代码量"><a href="#统计当天提交的代码量" class="headerlink" title="统计当天提交的代码量"></a>统计当天提交的代码量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;$(git config --get user.name)&quot; --no-merges --since=1am --stat</span><br></pre></td></tr></table></figure><h4 id="统计报告-gitstats"><a href="#统计报告-gitstats" class="headerlink" title="统计报告-gitstats"></a>统计报告-gitstats</h4><ul><li>用GitStatX图形化工具查看</li></ul><h4 id="统计报告-gitinspector"><a href="#统计报告-gitinspector" class="headerlink" title="统计报告-gitinspector"></a>统计报告-gitinspector</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitinspector --format=html --since=2018-01-01 --until=2018-12-30 --timeline --localize-output -w ./ &gt; ~/tmp/gitinspector/zcy-payment-center-201801.html</span><br></pre></td></tr></table></figure><p>gitinspector命令说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">➜  car-manage git:(master) gitinspector --help</span><br><span class="line">用法：/usr/local/bin/gitinspector [选项]... [目录] </span><br><span class="line">在目录列出有关库的信息,如果没有指定目录，那么将使用现目录。如果有多个目录，</span><br><span class="line">将采用指定的最后一个目录</span><br><span class="line"></span><br><span class="line">长选项的强制性参数对短选项也适用</span><br><span class="line">布尔参数只能给予长选项</span><br><span class="line">  -f, --file-types=EXTENSIONS    一串逗号分隔的文件类型</span><br><span class="line">                                   这些文件将会被用于计算统计数据.</span><br><span class="line">                                   默认文件类型:</span><br><span class="line">                                   java,c,cc,cpp,h,hh,hpp,py,glsl,rb,js,sql</span><br><span class="line">  -F, --format=FORMAT            指定生成的输出文件的格式；</span><br><span class="line">                                   默认格式是&apos;text&apos; 和</span><br><span class="line">                                   可选格式:</span><br><span class="line">                                   html,htmlembedded,text,xml</span><br><span class="line">      --grading[=BOOL]           按照学生成评判项目的格式，</span><br><span class="line">                                   显示统计数据和信息；</span><br><span class="line">                                   等同于 -HlmrTw 选项</span><br><span class="line">  -H, --hard[=BOOL]              记录行数并且寻找重复的内容;</span><br><span class="line">                                   如果数据库较大，这个可能会需要一些时间</span><br><span class="line">  -l, --list-file-types[=BOOL]   列出所有现在的数据库分支的文件格式</span><br><span class="line">  -L, --localize-output[=BOOL]   在翻译版本存在的前提下，将输出结果翻译到系统语言</span><br><span class="line">  -m  --metrics[=BOOL]           在分析提交时，检查特定指标</span><br><span class="line">  -r  --responsibilities[=BOOL]  显示每位作者主要职责</span><br><span class="line">      --since=DATE               只显示从特定时间起的结果</span><br><span class="line">  -T, --timeline[=BOOL]          显示提交时间轴, 包括作者名称</span><br><span class="line">      --until=DATE               只显示特定时间前的结果</span><br><span class="line">  -w, --weeks[=BOOL]             按周来显示统计数据，而非月</span><br><span class="line">  -x, --exclude=PATTERN          按特定格式排除不应该被统计</span><br><span class="line">                                   的文件，作者名字或邮箱;可以按文件名，作者名，</span><br><span class="line">                                   作者邮箱。可以重复</span><br><span class="line">  -h, --help                     显示这个帮助信息并退出</span><br><span class="line">      --version                  显示版本信息并退出</span><br><span class="line"></span><br><span class="line">gitinspector 会过滤信息并且仅统计那些修改，增加或减少，指定文件类型的提交，</span><br><span class="line">如需详细信息，请参考 -f 或 --file-types 选项</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
